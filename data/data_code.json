[
    {
        "output": "Prints 31 days using {} as a placeholder for the value (31).",
        "input": "println!({} days, 31);",
        "instruction": "Hello World"
    },
    {
        "output": "Prints Alice, this is Bob. Bob, this is Alice using positional arguments ({0}, {1}). Order matters!",
        "input": "println!({0}, this is {1}. {1}, this is {0}, Alice, Bob);",
        "instruction": "Hello World"
    },
    {
        "output": "Prints a sentence with named arguments, improving readability.",
        "input": "println!({subject} {verb} {object}, subject=the lazy dog, verb=jumps over, object=quick brown fox);",
        "instruction": "Hello World"
    },
    {
        "output": "Declares a boolean variable named 'logical' and initializes it with the value 'true'.",
        "input": "let logical: bool = true;",
        "instruction": "Primitives"
    },
    {
        "output": "Declares a floating-point variable named 'a_float' and initializes it with the value '1.0'. The type 'f64' represents a 64-bit floating-point number.",
        "input": "let a_float: f64 = 1.0;",
        "instruction": "Primitives"
    },
    {
        "output": "Declares an integer variable named 'an_integer' and initializes it with the value '5'. The suffix 'i32' indicates that this is a 32-bit signed integer.",
        "input": "let an_integer = 5i32;",
        "instruction": "Primitives"
    },
    {
        "output": "Declares a floating-point variable named 'default_float' and initializes it with the value '3.0'. In the absence of a suffix, Rust defaults to 'f64' for floating-point numbers.",
        "input": "let default_float = 3.0;",
        "instruction": "Primitives"
    },
    {
        "output": "Declares an integer variable named 'default_integer' and initializes it with the value '7'. In the absence of a suffix, Rust defaults to 'i32' for integers.",
        "input": "let default_integer = 7;",
        "instruction": "Primitives"
    },
    {
        "output": "Declares a mutable variable named 'inferred_type' and initializes it with the value '12'. On the next line, 'inferred_type' is assigned a 64-bit integer, which changes its inferred type to 'i64'.",
        "input": "let mut inferred_type = 12; inferred_type = 4294967296i64;",
        "instruction": "Primitives"
    },
    {
        "output": "Declares a mutable integer variable named 'mutable' and initializes it with the value '12'. On the next line, the value of 'mutable' is changed to '21'.",
        "input": "let mut mutable = 12; mutable = 21;",
        "instruction": "Primitives"
    },
    {
        "output": "Declares a boolean variable named 'mutable' and initializes it with the value 'true'. This is an example of variable shadowing, where a new variable with the same name is declared, effectively overwriting the previous 'mutable' variable.",
        "input": "let mutable = true;",
        "instruction": "Primitives"
    },
    {
        "output": "Clones the 'matrix' variable into a new variable 'cloned'.",
        "input": "let cloned = matrix.clone();",
        "instruction": "Primitives"
    },
    {
        "output": "Copies the 'matrix' variable into a new variable 'copied'.",
        "input": "let copied = matrix;",
        "instruction": "Primitives"
    },
    {
        "output": "Declares an array 'array' with five elements.",
        "input": "let array = [1, 2, 3, 4, 5];",
        "instruction": "Primitives"
    },
    {
        "output": "Declares a fixed-size array 'xs' of type i32 with 5 elements.",
        "input": "let xs: [i32; 5] = [1, 2, 3, 4, 5];",
        "instruction": "Primitives"
    },
    {
        "output": "Declares a fixed-size array 'ys' of type i32 with 500 elements, all initialized to 0.",
        "input": "let ys: [i32; 500] = [0; 500];",
        "instruction": "Primitives"
    },
    {
        "output": "Calls the function 'analyze_slice' with a slice of the whole array 'xs'.",
        "input": "analyze_slice(&xs);",
        "instruction": "Primitives"
    },
    {
        "output": "Calls the function 'analyze_slice' with a slice of the array 'ys' from index 1 to 3.",
        "input": "analyze_slice(&ys[1 .. 4]);",
        "instruction": "Primitives"
    },
    {
        "output": "Declares an empty array 'empty_array' of type u32.",
        "input": "let empty_array: [u32; 0] = [];",
        "instruction": "Primitives"
    },
    {
        "output": "Asserts that the 'empty_array' is equal to an empty slice.",
        "input": "assert_eq!(&empty_array, &[]);",
        "instruction": "Primitives"
    },
    {
        "output": "Defines a struct 'Person' with fields 'name' of type String and 'age' of type u8.",
        "input": "struct Person { name: String, age: u8, }",
        "instruction": "Custom Types\""
    },
    {
        "output": "Defines a unit struct 'Unit'.",
        "input": "struct Unit;",
        "instruction": "Custom Types"
    },
    {
        "output": "Defines a tuple struct 'Pair' with fields of type i32 and f32.",
        "input": "struct Pair(i32, f32);",
        "instruction": "Custom Types"
    },
    {
        "output": "Defines a struct 'Point' with fields 'x' and 'y' of type f32.",
        "input": "struct Point { x: f32, y: f32, }",
        "instruction": "Custom Types"
    },
    {
        "output": "Defines a struct 'Rectangle' with fields 'top_left' and 'bottom_right' of type 'Point'.",
        "input": "struct Rectangle { top_left: Point, bottom_right: Point, }",
        "instruction": "Custom Types"
    },
    {
        "output": "Creates an instance 'peter' of struct 'Person'.",
        "input": "let peter = Person { name, age };",
        "instruction": "Custom Types"
    },
    {
        "output": "Defines an enum 'WebEvent' with various variants.",
        "input": "enum WebEvent { PageLoad, PageUnload, KeyPress(char), Paste(String), Click { x: i64, y: i64 }, }",
        "instruction": "Custom Types\""
    },
    {
        "output": "Defines a function 'inspect' that takes a 'WebEvent' enum as an argument and prints a message based on the variant of the enum.",
        "input": "fn inspect(event: WebEvent) { ... }",
        "instruction": "Custom Types"
    },
    {
        "output": "Creates an instance 'pressed' of 'WebEvent' with the 'KeyPress' variant.",
        "input": "let pressed = WebEvent::KeyPress('x');",
        "instruction": "Custom Types"
    },
    {
        "output": "Creates an instance 'pasted' of 'WebEvent' with the 'Paste' variant.",
        "input": "let pasted  = WebEvent::Paste(\\my text\\\".to_owned());\"",
        "instruction": "Custom Types"
    },
    {
        "output": "Creates an instance 'click' of 'WebEvent' with the 'Click' variant.",
        "input": "let click   = WebEvent::Click { x: 20, y: 80 };",
        "instruction": "Custom Types"
    },
    {
        "output": "Creates an instance 'load' of 'WebEvent' with the 'PageLoad' variant.",
        "input": "let load    = WebEvent::PageLoad;",
        "instruction": "Custom Types"
    },
    {
        "output": "Creates an instance 'unload' of 'WebEvent' with the 'PageUnload' variant.",
        "input": "let unload  = WebEvent::PageUnload;",
        "instruction": "Custom Types"
    },
    {
        "output": "Calls the 'inspect' function with the 'pressed' instance.",
        "input": "inspect(pressed);",
        "instruction": "Custom Types"
    },
    {
        "output": "Defines an enum 'VeryVerboseEnumOfThingsToDoWithNumbers' with 'Add' and 'Subtract' variants.",
        "input": "enum VeryVerboseEnumOfThingsToDoWithNumbers { Add, Subtract, }",
        "instruction": "Custom Types"
    },
    {
        "output": "Creates a type alias 'Operations' for the 'VeryVerboseEnumOfThingsToDoWithNumbers' enum.",
        "input": "type Operations = VeryVerboseEnumOfThingsToDoWithNumbers;",
        "instruction": "Custom Types"
    },
    {
        "output": "Creates an instance 'x' of 'Operations' with the 'Add' variant.",
        "input": "let x = Operations::Add;",
        "instruction": "Custom Types"
    },
    {
        "output": "Implements a method 'run' for the 'VeryVerboseEnumOfThingsToDoWithNumbers' enum that performs the operation represented by the enum variant.",
        "input": "impl VeryVerboseEnumOfThingsToDoWithNumbers { fn run(&self, x: i32, y: i32) -> i32 { ... } }",
        "instruction": "Custom Types"
    },
    {
        "output": "Calls the 'run' method on the 'x' instance with arguments 5 and 6.",
        "input": "let result = x.run(5, 6);",
        "instruction": "Custom Types"
    },
    {
        "output": "Defines a static string 'LANGUAGE' and a constant 'THRESHOLD'.",
        "input": "static LANGUAGE: &str = \\Rust\\\"; const THRESHOLD: i32 = 10;\"",
        "instruction": "Custom Types"
    },
    {
        "output": "Defines a function 'is_big' that checks if a number 'n' is greater than the constant 'THRESHOLD'.",
        "input": "fn is_big(n: i32) -> bool { n > THRESHOLD }",
        "instruction": "Custom Types"
    },
    {
        "output": "Creates a variable 'n' with a value of 16.",
        "input": "let n = 16;",
        "instruction": "Custom Types"
    },
    {
        "output": "Defines a function 'add_one' that takes an integer 'x' and returns 'x + 1'.",
        "input": "fn add_one(x: i32) -> i32 { x + 1 }",
        "instruction": ""
    },
    {
        "output": "Declares a variable 'x' of type i32 and initializes it with the value 1.",
        "input": "let x: i32 = 1;",
        "instruction": ""
    },
    {
        "output": "Calls the 'add_one' function with 'x' as an argument and assigns the result back to 'x'.",
        "input": "let x = add_one(x);",
        "instruction": ""
    },
    {
        "output": "Asserts that the value of 'x' is equal to 2.",
        "input": "assert_eq!(x, 2);",
        "instruction": ""
    },
    {
        "output": "Defines a function 'diverges' that panics with a message. The return type '!' indicates that the function does not return.",
        "input": "fn diverges() -> ! { panic!(\\This function never returns!\\\"); }\"",
        "instruction": ""
    },
    {
        "output": "Attempts to call the 'diverges' function and assign its result to 'x'. This will not compile because 'diverges' does not return a value.",
        "input": "let x: i32 = diverges();",
        "instruction": ""
    },
    {
        "output": "Creates a variable 'x' of type i32 and initializes it with the value 5.",
        "input": "let x: i32 = 5;",
        "instruction": ""
    },
    {
        "output": "Creates a variable 'y' and uses a block to calculate its value based on 'x'.",
        "input": "let y: i32 = { let x_squared = x * x; x_squared + x };",
        "instruction": ""
    },
    {
        "output": "Creates a variable 'z' and uses a block to calculate its value. This will not compile because the block does not return a value.",
        "input": "let z: i32 = { 2 * x; };",
        "instruction": ""
    },
    {
        "output": "Creates a variable 'x' and initializes it with the value 5. The type of 'x' will be inferred as i32.",
        "input": "let x = 5;",
        "instruction": ""
    },
    {
        "output": "Creates a variable 'y' and uses a block to calculate its value based on 'x'. The type of 'y' will be inferred based on the block's return value.",
        "input": "let y = { let x_squared = x * x; x_squared + x };",
        "instruction": ""
    },
    {
        "output": "Creates a variable 'z' and uses a block to calculate its value. The type of 'z' will be inferred based on the block's return value.",
        "input": "let z = { 2 * x };",
        "instruction": ""
    },
    {
        "output": "Creates a variable 'y' and uses an if expression to assign a value based on the condition.",
        "input": "let y = if x == 5 { 10 } else { 15 };",
        "instruction": ""
    },
    {
        "output": "Creates a variable 'y' and uses an if expression with different types in the branches. This will not compile because the types must match.",
        "input": "let y = if x == 5 { 10 } else { \\hello\\\" };\"",
        "instruction": ""
    },
    {
        "output": "Creates a variable 'y' and uses a loop to calculate its value based on 'x'.",
        "input": "let y = loop { x += x; if x > 100 { break x; } };",
        "instruction": ""
    },
    {
        "output": "Creates a variable 'y' and uses a while loop to increment 'x' until it reaches 10.",
        "input": "let y = while x < 10 { x += 1; };",
        "instruction": ""
    },
    {
        "output": "Implements the basic and extended Euclidean algorithms for finding the greatest common divisor (GCD). Arguments: a, b",
        "input": "// Basic Euclidean Algorithm pub fn gcd_basic(mut a: i32, mut b: i32) -> i32 { while b != 0 { let temp = b; b = a % b; a = temp; } a.abs() } // Extended Euclidean Algorithm pub fn gcd_extended(a: i32, b: i32) -> (i32, i32, i32) { if b == 0 { (a, 1, 0) } else { let (g, x, y) = gcd_extended(b, a % b); (g, y, x - (a / b) * y) } } ",
        "instruction": ""
    },
    {
        "output": "Declares two variables 'a' and 'b', and assigns them the values 252 and 105, respectively.",
        "input": "let a = 252; let b = 105;",
        "instruction": ""
    },
    {
        "output": "Invokes the 'gcd_basic' function with arguments 'a' and 'b', and stores the result in the variable 'result'.",
        "input": "let result = gcd_basic(a, b);",
        "instruction": ""
    },
    {
        "output": "Invokes the 'gcd_extended' function with arguments 'a' and 'b', and destructures the returned tuple into variables 'gcd', 'x', and 'y'.",
        "input": "let (gcd, x, y) = gcd_extended(a, b);",
        "instruction": ""
    },
    {
        "output": "Checks if 'y' is a power of 'x' using recursion. Arguments: x, y",
        "input": "fn is_power_of(x: i32, y: i32) -> bool { if y == 1 || (x != 0 && y != 0 && y % x == 0 && is_power_of(x, y / x)) { return true; } else { return false; } } ",
        "instruction": ""
    },
    {
        "output": "Checks if a given number 'num' is divisible by 13. Argument: num",
        "input": "pub fn is_divisible_by_13(num: i32) -> bool { num % 13 == 0 } ",
        "instruction": ""
    },
    {
        "output": "Checks if a line, defined by two points (x1, y1) and (x2, y2), passes through the origin. Arguments: x1, y1, x2, y2",
        "input": "fn check_line_passes_origin(x1: i32, y1: i32, x2: i32, y2: i32) -> bool { // Calculate the slope let slope = (y2 - y1).abs() / (x2 - x1).abs(); // Calculate the y-intercept let y_intercept = y1 - slope * x1; // Check if the line passes through the origin y_intercept == 0 } ",
        "instruction": ""
    },
    {
        "output": "Checks if a number 'n' is a perfect square using an addition/subtraction method. Argument: n",
        "input": "fn is_perfect_square(n: i64) -> bool { let mut i = 1; let mut sum = 0; loop { sum += i; if sum == n { return true; } if sum > n { return false; } i += 2; } } ",
        "instruction": ""
    },
    {
        "output": "Counts the different ways to express 'n' as the sum of 1, 3, and 4 using dynamic programming. Argument: n",
        "input": "pub fn count_ways(n: usize) -> usize { let mut dp = vec![0; n + 1]; dp[0] = 1; for i in 1..=n { let mut j: usize = 1; while j <= 4 && j <= i { dp[i] += dp[i - j]; j += 1; } } dp[n] } ",
        "instruction": ""
    },
    {
        "output": "Counts the number of pairs (x, y) where x is from array 'a' and y is from array 'b' and x < y. Arguments: a, b",
        "input": "fn count_pairs(a: &[i32], b: &[i32]) -> usize { a.iter().zip(b.iter()).filter(|&&x, &&y| x < y).count() } ",
        "instruction": ""
    },
    {
        "output": "Counts the number of pairs in array 'arr' of size 'n' that have a difference equal to 'k'. Arguments: arr, n, k",
        "input": "use std::collections::HashMap; fn count_pairs_difference(arr: &Vec<i32>, n: usize, k: i32) -> i32 { let mut count = 0; let mut map = HashMap::new(); for &num in arr { let entry = map.entry(num).or_insert(0); *entry += 1; } for &num in arr { if map.contains_key(&(num + k)) { count += *map.get(&(num + k)).unwrap() * map.get(&num).unwrap(); } } count } ",
        "instruction": ""
    },
    {
        "output": "This function takes an array and its length as input. It counts the number of pairs in the array whose product is also present in the array. It does this by iterating over each pair of elements in the array and checking if their product is in the array. If it is, it increments a counter. The function finally returns this count.",
        "input": "fn count_product_pairs(arr: &[i32], n: usize) -> i32 { let mut count = 0; for i in 0..n { for j in (i+1)..n { if arr.contains(&(arr[i] * arr[j])) { count += 1; } } } count } ",
        "instruction": ""
    },
    {
        "output": "This function also counts the number of pairs in the array whose product is present in the array. However, it uses a HashSet for faster lookup of the product of pairs. It first creates a HashSet from the array, then iterates over each pair of elements in the array. If their product is in the HashSet, it increments a counter. The function finally returns this count.",
        "input": "use std::collections::HashSet; fn count_pairs(arr: &[i32], n: usize) -> i32 { let set: HashSet<i32> = arr.iter().cloned().collect(); let mut count = 0; for i in 0..n { for j in (i + 1)..n { if set.contains(&(arr[i] * arr[j])) { count += 1; } } } count } ",
        "instruction": ""
    },
    {
        "output": "This function counts the number of palindromic substrings in a given string. It uses dynamic programming to store whether a substring is palindromic or not.",
        "input": "pub fn count_palindrome_substrings(s: &str) -> i32 { let s = s.as_bytes(); let n = s.len(); let mut dp = vec![vec![false; n + 1]; n + 1]; let mut count = 0; // Single character substrings are always palindromic for i in 0..n { dp[i][i] = true; count += 1; } // Check for two character substrings for i in 0..n - 1 { if s[i] == s[i + 1] { dp[i][i + 1] = true; count += 1; } } // Check for substrings of length 3 to n for len in 3..=n { for i in 0..=n - len { let j = i + len - 1; if s[i] == s[j] && dp[i + 1][j - 1] { dp[i][j] = true; count += 1; } } } count } ",
        "instruction": ""
    },
    {
        "output": " This function calculates the average of two integers without causing overflow. It uses the checked_add and checked_div methods to prevent overflow.",
        "input": "pub fn average(a: i32, b: i32) -> Option<i32> { a.checked_add(b).and_then(|sum| sum.checked_div(2)) } ",
        "instruction": ""
    },
    {
        "output": "This is another version of the average function that works with unsigned integers. It calculates the average in a way that prevents overflow.",
        "input": "pub fn average(a: u32, b: u32) -> u32 { (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2) } ",
        "instruction": ""
    },
    {
        "output": "This function counts the number of ways to construct buildings given a number. It uses recursion and the concept of Fibonacci numbers.",
        "input": "pub fn count_ways(n: u32) -> u32 { match n { 0 => 1, 1 => 1, _ => count_ways(n - 1) + count_ways(n - 2), } } ",
        "instruction": ""
    },
    {
        "output": "This function counts the number of possible paths from the top-left to the bottom-right of a matrix. It uses dynamic programming to store the number of paths to each cell.",
        "input": "fn count_pcount palindrome sub strings string arguments: str,naths(n: usize, m: usize) -> usize { let mut paths = vec![vec![0; n]; m]; for i in 0..m { for j in 0..n { if i == 0 || j == 0 { paths[i][j] = 1; } else { paths[i][j] = paths[i-1][j] + paths[i][j-1]; } } } paths[m-1][n-1] } ",
        "instruction": ""
    },
    {
        "output": "This function counts the number of groups of size 2 or 3 in an array whose sum is a multiple of 3.",
        "input": "fn count_possible_groups(arr: &[i32], n: usize) -> i32 { let mut count = 0; for i in 0..n { for j in (i+1)..n { let sum = arr[i] + arr[j]; if sum % 3 == 0 { count += 1; } } } for i in 0..n { for j in (i+1)..n { for k in (j+1)..n { let sum = arr[i] + arr[j] + arr[k]; if sum % 3 == 0 { count += 1; } } } } count } ",
        "instruction": ""
    },
    {
        "output": "This function counts the number of palindromic subsequences in a given string. It uses dynamic programming to store the number of palindromic subsequences for each possible substring.",
        "input": "fn count_palindromic_subsequence(s: &str) -> i32 { let n = s.len(); let mut dp = vec![vec![0; n]; n]; for gap in 0..n { for j in gap..n { let i = j - gap; if gap == 0 { dp[i][j] = 1; } else if gap == 1 { dp[i][j] = 2; } else { dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]; if s.chars().nth(i) == s.chars().nth(j) { dp[i][j] += 1 + dp[i + 1][j - 1]; } } } } dp[0][n - 1] }",
        "instruction": ""
    },
    {
        "output": "This function counts the number of set bits (bits that are 1) in an integer. It uses bitwise operations to count the set bits.",
        "input": "pub fn count_set_bits(n: usize) -> usize { let mut count = 0; let mut n = n; while n > 0 { count += n & 1; n >>= 1; } count } ",
        "instruction": ""
    },
    {
        "output": "count set bits in an integer 1 arguments: n",
        "input": "use num_integer::Integer; fn counting_bits(n: i32) -> usize { n.popcount() } ",
        "instruction": ""
    },
    {
        "output": "count set bits in an integer 3 arguments: n",
        "input": "pub fn count_set_bits(n: i32) -> i32 { let mut count = 0; let mut n = n; while n > 0 { count += n & 1; n >>= 1; } count } ",
        "instruction": ""
    },
    {
        "output": "count strings adjacent characters difference one arguments: n",
        "input": "fn count_adjacent_diff_one(s: &str) -> usize { let s: Vec<char> = s.chars().collect(); let n = s.len(); let mut count = 0; for i in 0..n-1 { if (s[i+1] as u8 - s[i] as u8).abs() == 1 { count += 1; } } count } ",
        "instruction": ""
    },
    {
        "output": "count strings can formed using b c given constraints 1 arguments: n",
        "input": "pub fn count_strings(n: i32) -> i32 { let mut dp = vec![0; (n + 1) as usize]; dp[0] = 1; for i in 1..=n { dp[i as usize] = dp[(i - 1) as usize]; if i > 1 { dp[i as usize] += dp[(i - 2) as usize]; } } dp[n as usize] } ",
        "instruction": ""
    },
    {
        "output": "count subarrays equal number 1s 0s 1 arguments: arr,n",
        "input": "use std::collections::HashMap; fn count_subarrays(arr: &Vec<i32>, n: usize) -> i32 { let mut cnt_0 = 0; let mut cnt_1 = 0; let mut cnt_map: HashMap<i32, i32> = HashMap::new(); cnt_map.insert(0, 1); let mut result = 0; for i in 0..n { if arr[i] == 0 { cnt_0 += 1; } else { cnt_1 += 1; } let diff = cnt_0 - cnt_1; if cnt_map.contains_key(&diff) { result += cnt_map[&diff]; } *cnt_map.entry(diff).or_insert(0) += 1; } result } ",
        "instruction": ""
    },
    {
        "output": "count subarrays total distinct elements original array arguments: arr,n",
        "input": "pub fn count_subarrays(arr: &Vec<i32>, n: usize) -> Vec<Vec<i32>> { let mut count = [0; 100005]; let mut total = 0; let mut j = 0; let mut distinct_count = 0; let mut answer = Vec::new(); for i in 0..n { while j < n && count[arr[j] as usize] == 0 { count[arr[j] as usize] += 1; total += j - i + 1; distinct_count += 1; j += 1; } answer.push(total); count[arr[i] as usize] -= 1; distinct_count -= 1; } answer } ",
        "instruction": ""
    },
    {
        "output": "count subarrays with same even and odd elements arguments: arr,n",
        "input": "pub fn count_same_even_odd(arr: &[i32], n: usize) -> i32 { let mut odd = 0; let mut even = 0; let mut difference = 0; let mut count = 0; let mut prefix_count = [0; 2 * n + 1]; prefix_count[n] = 1; for &value in arr { if value % 2 == 0 { even += 1; } else { odd += 1; } difference = even - odd; count += prefix_count[(difference as usize) + n]; prefix_count[(difference as usize) + n] += 1; } count } ",
        "instruction": ""
    },
    {
        "output": "count substrings with same first and last characters arguments: s",
        "input": "fn count_substrings(s: &str) -> i32 { let mut count = 0; for i in 0..s.len() { for j in i..s.len() { if s.chars().nth(i) == s.chars().nth(j) { count += 1; } } } count } ",
        "instruction": ""
    },
    {
        "output": "count sum of digits in numbers from 1 to n arguments: n",
        "input": "pub fn sum_of_digits(n: u32) -> u32 { (1..=n).map(|i| i.to_string().chars().filter_map(|c| c.to_digit(10)).sum::<u32>()).sum() } ",
        "instruction": ""
    },
    {
        "output": "count total set bits in all numbers from 1 to n arguments: n",
        "input": "fn count_set_bits(n: i32) -> i32 { let mut total_set_bits = 0; for i in 1..=n { let mut num = i; while num > 0 { total_set_bits += num & 1; num >>= 1; } } total_set_bits } ",
        "instruction": ""
    },
    {
        "output": "count trailing zeroes factorial number arguments: n",
        "input": "pub fn count_trailing_zeroes(n: u64) -> u64 { let mut count = 0; let mut i = 5; while n / i >= 1 { count += n / i; i *= 5; } count } ",
        "instruction": ""
    },
    {
        "output": "count ways build street given constraints arguments: n",
        "input": "fn count_ways_recursive(n: i32) -> i32 { if n <= 0 { return 1; } if n == 1 { return 2; } let prev = count_ways_recursive(n - 1); let prev_prev = count_ways_recursive(n - 2); return prev + prev_prev; } fn count_ways_dp(n: i32) -> i32 { if n <= 0 { return 1; } if n == 1 { return 2; } let mut dp = vec![0; (n + 1) as usize]; dp[0] = 1; dp[1] = 2; for i in 2..=n as usize { dp[i] = dp[i - 1] + dp[i - 2]; } return dp[n as usize]; } ",
        "instruction": ""
    },
    {
        "output": "count ways divide circle using n non intersecting chords arguments: a",
        "input": "pub fn count_ways_to_divide_circle(n: usize) -> u64 { if n < 2 { return 1; } let mut dp = vec![0; n + 1]; dp[0] = 1; dp[1] = 1; for i in 2..=n { for j in 0..=i-1 { dp[i] += dp[j] * dp[i - 1 - j]; } } dp[n] } ",
        "instruction": ""
    },
    {
        "output": "count words appear exactly two times array words arguments: stri,n",
        "input": "pub fn count_exactly_two(arr: &[String]) -> usize { use std::collections::HashMap; let mut map = HashMap::new(); for word in arr { let counter = map.entry(word).or_insert(0); *counter += 1; } map.into_iter().filter(|(_k, v)| *v == 2).count() } ",
        "instruction": ""
    },
    {
        "output": "c program factorial number arguments: n",
        "input": "pub fn factorial(n: i32) -> i32 { if n == 0 { 1 } else { n * factorial(n - 1) } } ",
        "instruction": ""
    },
    {
        "output": "c program factorial number 1 arguments: n",
        "input": "pub fn factorial(n: u64) -> u64 { match n { 0 | 1 => 1, _ => n * factorial(n - 1), } } ",
        "instruction": ""
    },
    {
        "output": "c program factorial number 2 arguments: n",
        "input": "pub fn factorial(n: u32) -> u32 { (1..=n).product() } ",
        "instruction": ""
    },
    {
        "output": "fibonacci modulo p arguments: p",
        "input": "fn fibonacci_modulo(p: u32) -> u32 { let mut fib = (0, 1); return fib.0; } ",
        "instruction": ""
    },
    {
        "output": "finding power prime number p n 1 arguments: n,p",
        "input": "pub fn prime_power(n: i32, p: i32) -> i32 { let mut result = 1; for _ in 0..n { result *= p; } result } ",
        "instruction": ""
    },
    {
        "output": "find a fixed point in a given array arguments: arr,n",
        "input": "pub fn find_fixed_point(arr: &[i32]) -> Option<usize> { let n = arr.len(); for i in 0..n { if arr[i] == i as i32 { return Some(i); } } None } ",
        "instruction": ""
    },
    {
        "output": "find a rotation with maximum hamming distance arguments: arr,n",
        "input": "pub fn max_hamming_distance<T>(arr: &[T], n: usize) -> usize where T: Eq, { let mut rot_arr = vec![0; arr.len()]; let mut max_hamming = 0; for i in 1..n { max_hamming = std::cmp::max(max_hamming, hamming(&arr, &rotate(&mut rot_arr.clone(), arr, i))); } max_hamming } fn rotate<T>(rot_arr: &mut [T], arr: &[T], rot: usize) -> &[T] where T: Clone, { for i in 0..arr.len() { rot_arr[i] = arr[(i + rot) % arr.len()].clone(); } rot_arr } fn hamming<T>(arr1: &[T], arr2: &[T]) -> usize where T: Eq, { arr1.iter().zip(arr2.iter()).filter(|(a, b)| *a != *b).count() } ",
        "instruction": ""
    },
    {
        "output": "find a triplet that sum to a given value arguments: a,arr_size,sum",
        "input": "pub fn find_triplet(a: &[i32], arr_size: usize, sum: i32) -> Option<(i32, i32, i32)> { for i in 0..arr_size-2 { for j in i+1..arr_size-1 { for k in j+1..arr_size { if a[i] + a[j] + a[k] == sum { return Some((a[i], a[j], a[k])); } } } } None } ",
        "instruction": ""
    },
    {
        "output": "find a triplet that sum to a given value 1 arguments: a,arr_size,sum",
        "input": "pub fn find_triplet(a: &mut [i32], arr_size: usize, sum: i32) -> Option<(i32, i32, i32)> { for i in 0..arr_size-2 { for j in i+1..arr_size-1 { for k in j+1..arr_size { if a[i] + a[j] + a[k] == sum { return Some((a[i], a[j], a[k])); } } } } None } ",
        "instruction": ""
    },
    {
        "output": "find a triplet that sum to a given value 2 arguments: a,arr_size,sum",
        "input": "fn triplet_sum(a: &[i32], arr_size: usize, sum: i32) -> Option<(i32, i32, i32)> { for i in 0..arr_size-2 { for j in (i+1)..arr_size-1 { for k in (j+1)..arr_size { if a[i] + a[j] + a[k] == sum { return Some((a[i], a[j], a[k])); } } } } None } ",
        "instruction": ""
    },
    {
        "output": "find expression duplicate parenthesis not arguments: string_arg0",
        "input": "pub fn has_duplicate_parentheses(string_arg0: &str) -> bool { let mut stack = Vec::new(); for ch in string_arg0.chars() { if ch == '(' { stack.push(ch); } else if ch == ')' { if stack.is_empty() || stack.pop().unwrap() != '(' { return true; } } } return !stack.is_empty(); } ",
        "instruction": ""
    },
    {
        "output": "find harmonic mean using arithmetic mean geometric mean arguments: a,b",
        "input": "pub fn harmonic_mean(a: f64, b: f64) -> f64 { 2.0 / ((1.0 / a) + (1.0 / b)) } pub fn arithmetic_mean(a: f64, b: f64) -> f64 { (a + b) / 2.0 } pub fn geometric_mean(a: f64, b: f64) -> f64 { (a * b).sqrt() } ",
        "instruction": ""
    },
    {
        "output": "find index given fibonacci number constant time arguments: n",
        "input": "const SQRT_5: f64 = 2.23606797749979; const PHI: f64 = (1.0 + SQRT_5) / 2.0; pub fn find_fibonacci_index(n: f64) -> f64 { (n * SQRT_5 + SQRT_5 / 2.0).log(PHI) } ",
        "instruction": ""
    },
    {
        "output": "find index given fibonacci number constant time 1 arguments: n",
        "input": "pub fn find_fibonacci_index(n: i32) -> i32 { let sqrt_five = (5 as f64).sqrt(); let mut ans = ((n * sqrt_five).ln() / 2.302585092994046 as f64).floor() as i32; while get_fibonacci(ans) < n { ans += 1; } if get_fibonacci(ans) == n { return ans; } else { return -1; } } fn get_fibonacci(n: i32) -> i32 { let sqrt_five = (5 as f64).sqrt(); let ans = ((((1 + sqrt_five) / 2) as f64).powi(n) - (((1 - sqrt_five) / 2) as f64).powi(n)) / sqrt_five; (ans + 0.5) as i32 // Rounding to the nearest whole number } ",
        "instruction": ""
    },
    {
        "output": "find index of an extra element present in one sorted array 1 arguments: arr1,arr2,n",
        "input": "fn find_extra_element(arr1: &[i32], arr2: &[i32], n: usize) -> Option<usize> { let mut left = 0; let mut right = n - 1; while left <= right { let mid = (left + right) / 2; if arr1.get(mid) != arr2.get(mid) { return Some(mid); } if arr1[mid] > arr2[mid] { right = mid - 1; } else { left = mid + 1; } } None } ",
        "instruction": ""
    },
    {
        "output": "find largest d in array such that a b c d arguments: s,n",
        "input": "fn find_largest_d(arr: &mut [i32], n: usize) -> i32 { arr.sort_by(|a, b| b.cmp(a)); arr[0] } ",
        "instruction": ""
    },
    {
        "output": "find maximum height pyramid from the given array of objects arguments: boxes,n",
        "input": "// Box structure #[derive(Debug, Clone)] pub struct Box { width: i32, depth: i32, height: i32, } impl Box { // Construct Box pub fn new(width: i32, depth: i32, height: i32) -> Self { Self { width, depth, height, } } // Can this box be placed on the top of the other one pub fn can_be_above(&self, other: &Self) -> bool { self.width < other.width && self.depth < other.depth } // Sorting boxes by height (Descending) pub fn height_ascending(first: &Self, second: &Self) -> std::cmp::Ordering { second.height.cmp(&first.height) } } // Vector of Boxes type BoxStack = Vec<Box>; // Function to get maximum height stack pub fn create_stack(boxes: &mut BoxStack) -> i32 { if boxes.is_empty() { return 0; } // sorting boxes by height (Descending) boxes.sort_by(Box::height_ascending); let mut max_height = vec![0; boxes.len()]; (0..boxes.len()).for_each(|i| { max_height[i] = boxes[i].height; (0..i).for_each(|j| { if boxes[i].can_be_above(&boxes[j]) && max_height[j] + boxes[i].height > max_height[i] { max_height[i] = max_height[j] + boxes[i].height; } }); }); *max_height.iter().max().unwrap() } ",
        "instruction": ""
    },
    {
        "output": "find maximum product of a triplet in array arguments: arr,n",
        "input": "pub fn max_product(arr: &[i32], n: usize) -> i32 { // To store minimum and second minimum element in the array let (mut min, mut second_min) = (i32::MAX, i32::MAX); // To store maximum, second maximum and third maximum element in the array let (mut max, mut second_max, mut third_max) = (i32::MIN, i32::MIN, i32::MIN); for &num in arr.iter() { if num < min { second_min = min; min = num; } else if num < second_min { second_min = num; } if num > max { third_max = second_max; second_max = max; max = num; } else if num > second_max { third_max = second_max; second_max = num; } else if num > third_max { third_max = num; } } i32::max((min * second_min * max), (max * second_max * third_max)) } ",
        "instruction": ""
    },
    {
        "output": "find maximum product of a triplet in array 1 arguments: arr,n",
        "input": "fn find_max_product(arr: &mut [i32; 3], n: usize) -> i32 { arr.sort(); let max_product = arr[n - 1] * arr[n - 2] * arr[n - 3]; max_product } ",
        "instruction": ""
    },
    {
        "output": "find maximum sum possible equal sum three stacks arguments: stack1,stack2,stack3,n1,n2,n3",
        "input": "pub fn max_sum(stack1: &[i32], stack2: &[i32], stack3: &[i32]) -> i32 { let (mut sum1, mut sum2, mut sum3) = (stack1.iter().sum::<i32>(), stack2.iter().sum::<i32>(), stack3.iter().sum::<i32>()); let mut top1: usize = 0; let mut top2: usize = 0; let mut top3: usize = 0; while (sum1 != sum2 && sum2 != sum3 && sum3 != sum1) { if sum1 > sum2 && sum1 > sum3 { sum1 -= stack1[top1]; top1 += 1; } else if sum2 > sum1 && sum2 > sum3 { sum2 -= stack2[top2]; top2 += 1; } else if sum3 > sum1 && sum3 > sum2 { sum3 -= stack3[top3]; top3 += 1; } } return sum1; } ",
        "instruction": ""
    },
    {
        "output": "find minimum difference pair arguments: arr,n",
        "input": "fn find_min_diff_pair(arr: &mut [i32], n: usize) -> (i32, i32) { arr.sort_unstable(); let mut min_diff = i32::MAX; let mut res = (0, 0); for i in 1..n { if arr[i] - arr[i - 1] < min_diff { min_diff = arr[i] - arr[i - 1]; res = (arr[i - 1], arr[i]); } } res } ",
        "instruction": ""
    },
    {
        "output": "find minimum difference pair 1 arguments: arr,n",
        "input": "pub fn find_minimum_difference_pair(arr: &mut Vec<i32>, n: usize) -> Option<(i32, i32)> { let mut min_diff = i32::MAX; let mut result = None; arr.sort(); // Sort the array for i in 0..n-1 { if arr[i+1] - arr[i] < min_diff { min_diff = arr[i+1] - arr[i]; result = Some((arr[i], arr[i+1])); } } result } ",
        "instruction": ""
    },
    {
        "output": "This code defines a function that adds two numbers and returns the result.",
        "input": "fn add(a: i32, b: i32) -> i32 { a + b }",
        "instruction": ""
    },
    {
        "output": "Calculates the sum of the squares of the first 'n' natural numbers. Arguments: n",
        "input": "fn sum_of_squares(n: i32) -> i32 { (1..=n).map(|x| x * x).sum() } ",
        "instruction": ""
    },
    {
        "output": "Calculates the factorial of a given number 'n'. Arguments: n",
        "input": "fn factorial(n: u32) -> u32 { (1..=n).product() } ",
        "instruction": ""
    },
    {
        "output": "Checks if a number 'n' is a prime number. Arguments: n",
        "input": "fn is_prime(n: u32) -> bool { if n <= 1 { return false; } for i in 2..=((n as f64).sqrt() as u32) { if n % i == 0 { return false; } } true } ",
        "instruction": ""
    },
    {
        "output": "Calculates the greatest common divisor (GCD) of two numbers using the Euclidean algorithm. Arguments: a, b",
        "input": "fn gcd(a: u32, b: u32) -> u32 { if b == 0 { a } else { gcd(b, a % b) } } ",
        "instruction": ""
    },
    {
        "output": "Calculates the 'n'th Fibonacci number using recursion. Arguments: n",
        "input": "fn fibonacci(n: u32) -> u32 { match n { 0 => 0, 1 => 1, _ => fibonacci(n - 1) + fibonacci(n - 2), } } ",
        "instruction": ""
    },
    {
        "output": "Reverses a given string. Arguments: s",
        "input": "fn reverse_string(s: &str) -> String { s.chars().rev().collect() } ",
        "instruction": ""
    },
    {
        "output": "Checks if a given string is a palindrome, ignoring non-alphanumeric characters and case. Arguments: s",
        "input": "fn is_palindrome(s: &str) -> bool { let s: String = s.chars().filter(|c| c.is_alphanumeric()).collect(); let s = s.to_lowercase(); s == s.chars().rev().collect::<String>() } ",
        "instruction": ""
    },
    {
        "output": "Performs binary search on a sorted array 'arr' to find the target element. Returns the index of the target if found, otherwise returns None. Arguments: arr, target",
        "input": "fn binary_search(arr: &[i32], target: i32) -> Option<usize> { let mut low = 0; let mut high = arr.len(); while low < high { let mid = (low + high) / 2; if arr[mid] == target { return Some(mid); } else if arr[mid] < target { low = mid + 1; } else { high = mid; } } None } ",
        "instruction": ""
    },
    {
        "output": "Implements the merge sort algorithm to sort an array in place. Arguments: arr",
        "input": "fn merge_sort(arr: &mut [i32]) { if arr.len() > 1 { let mid = arr.len() / 2; merge_sort(&mut arr[..mid]); merge_sort(&mut arr[mid..]); let mut left = arr[..mid].to_vec(); let mut right = arr[mid..].to_vec(); let mut i = 0; let mut j = 0; for k in arr { if i >= left.len() { *k = right[j]; j += 1; } else if j >= right.len() { *k = left[i]; i += 1; } else if left[i] < right[j] { *k = left[i]; i += 1; } else { *k = right[j]; j += 1; } } } } ",
        "instruction": ""
    },
    {
        "output": "Implements the quicksort algorithm to sort an array in place. Arguments: arr",
        "input": "fn quicksort(arr: &mut [i32]) { if arr.len() <= 1 { return; } let pivot_index = partition(arr); let (left, right) = arr.split_at_mut(pivot_index); quicksort(left); quicksort(&mut right[1..]); } fn partition(arr: &mut [i32]) -> usize { let pivot = arr[arr.len() / 2]; let mut i = 0; let mut j = arr.len() - 1; loop { while arr[i] < pivot { i += 1; } while arr[j] > pivot { if j == 0 { break; } j -= 1; } if i >= j { break; } arr.swap(i, j); i += 1; if j > 0 { j -= 1; } } j } ",
        "instruction": ""
    },
    {
        "output": "Transposes a square matrix in place. Arguments: matrix",
        "input": "fn transpose(matrix: &mut Vec<Vec<i32>>) { let n = matrix.len(); for i in 0..n { for j in i+1..n { let temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } } ",
        "instruction": ""
    },
    {
        "output": "Calculates the dot product of two vectors. Arguments: vec1, vec2",
        "input": "fn dot_product(vec1: &[i32], vec2: &[i32]) -> i32 { vec1.iter().zip(vec2.iter()).map(|(x, y)| x * y).sum() } ",
        "instruction": ""
    },
    {
        "output": "Finds the maximum value in a given array. Returns None if the array is empty. Arguments: arr",
        "input": "fn find_max(arr: &[i32]) -> Option<i32> { arr.iter().cloned().max() } ",
        "instruction": ""
    },
    {
        "output": "Finds the minimum value in a given array. Returns None if the array is empty. Arguments: arr",
        "input": "fn find_min(arr: &[i32]) -> Option<i32> { arr.iter().cloned().min() } ",
        "instruction": ""
    },
    {
        "output": "Calculates the sum of all elements in an array. Arguments: arr",
        "input": "fn sum_elements(arr: &[i32]) -> i32 { arr.iter().sum() } ",
        "instruction": ""
    },
    {
        "output": "Counts the number of times a target element appears in an array. Arguments: arr, target",
        "input": "fn count_occurrences(arr: &[i32], target: i32) -> usize { arr.iter().filter(|&&x| x == target).count() } ",
        "instruction": ""
    },
    {
        "output": "Returns a vector containing only the unique elements of the input array. Arguments: arr",
        "input": "fn unique_elements(arr: &[i32]) -> Vec<i32> { let mut unique = Vec::new(); for &item in arr { if !unique.contains(&item) { unique.push(item); } } unique } ",
        "instruction": ""
    },
    {
        "output": "Removes duplicate elements from a vector in place. Arguments: arr",
        "input": "fn remove_duplicates(arr: &mut Vec<i32>) { arr.sort(); arr.dedup(); } ",
        "instruction": ""
    },
    {
        "output": "Returns a vector containing the common elements of two input arrays. Arguments: arr1, arr2",
        "input": "fn common_elements(arr1: &[i32], arr2: &[i32]) -> Vec<i32> { let mut common = Vec::new(); for &item in arr1 { if arr2.contains(&item) && !common.contains(&item) { common.push(item); } } common } ",
        "instruction": ""
    },
    {
        "output": "Rotates an array to the left by 'k' positions. Arguments: arr, k",
        "input": "fn rotate_left(arr: &mut [i32], k: usize) { let len = arr.len(); let k = k % len; arr.reverse(); arr[..len-k].reverse(); arr[len-k..].reverse(); } ",
        "instruction": ""
    },
    {
        "output": "Rotates an array to the right by 'k' positions. Arguments: arr, k",
        "input": "fn rotate_right(arr: &mut [i32], k: usize) { let len = arr.len(); let k = k % len; arr.reverse(); arr[..k].reverse(); arr[k..].reverse(); } ",
        "instruction": ""
    },
    {
        "output": "Calculates the power of a base number raised to an exponent using iterative multiplication. Arguments: base, exp",
        "input": "fn power(base: i32, exp: u32) -> i32 { (0..exp).fold(1, |acc, _| acc * base) } ",
        "instruction": ""
    },
    {
        "output": "Implements the bubble sort algorithm to sort an array in place. Arguments: arr",
        "input": "fn bubble_sort(arr: &mut [i32]) { let mut n = arr.len(); while n > 0 { let mut new_n = 0; for i in 1..n { if arr[i-1] > arr[i] { arr.swap(i-1, i); new_n = i; } } n = new_n; } } ",
        "instruction": ""
    },
    {
        "output": "Implements the selection sort algorithm to sort an array in place. Arguments: arr",
        "input": "fn selection_sort(arr: &mut [i32]) { let n = arr.len(); for i in 0..n { let mut min_index = i; for j in (i+1)..n { if arr[j] < arr[min_index] { min_index = j; } } arr.swap(i, min_index); } } ",
        "instruction": ""
    },
    {
        "output": "Implements the insertion sort algorithm to sort an array in place. Arguments: arr",
        "input": "fn insertion_sort(arr: &mut [i32]) { let n = arr.len(); for i in 1..n { let key = arr[i]; let mut j = i; while j > 0 && arr[j-1] > key { arr[j] = arr[j-1]; j -= 1; } arr[j] = key; } } ",
        "instruction": ""
    },
    {
        "output": "Finds the median value of a given array. Arguments: arr",
        "input": "fn find_median(arr: &mut [i32]) -> f64 { arr.sort(); let len = arr.len(); if len % 2 == 0 { (arr[len/2 - 1] + arr[len/2]) as f64 / 2.0 } else { arr[len/2] as f64 } } ",
        "instruction": ""
    },
    {
        "output": "Finds the mode (the most frequently occurring element) in an array. Arguments: arr",
        "input": "fn mode(arr: &[i32]) -> i32 { let mut occurrences = std::collections::HashMap::new(); for &value in arr { *occurrences.entry(value).or_insert(0) += 1; } *occurrences.iter().max_by_key(|&(_, count)| count).unwrap().0 } ",
        "instruction": ""
    },
    {
        "output": "Flattens a two-dimensional vector into a one-dimensional vector. Arguments: v",
        "input": "fn flatten<T: Clone>(v: &Vec<Vec<T>>) -> Vec<T> { v.iter().flat_map(|inner| inner.iter().cloned()).collect() } ",
        "instruction": ""
    },
    {
        "output": "Transposes a two-dimensional matrix and returns the result. Arguments: matrix",
        "input": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> { let mut transposed = vec![vec![0; matrix.len()]; matrix[0].len()]; for i in 0..matrix.len() { for j in 0..matrix[0].len() { transposed[j][i] = matrix[i][j]; } } transposed } ",
        "instruction": ""
    },
    {
        "output": "Checks if a number is even. Arguments: n",
        "input": "fn is_even(n: i32) -> bool { n % 2 == 0 } ",
        "instruction": ""
    },
    {
        "output": "Checks if a number is odd. Arguments: n",
        "input": "fn is_odd(n: i32) -> bool { n % 2 != 0 } ",
        "instruction": ""
    },
    {
        "output": "Swaps the values of two integers. Arguments: a, b",
        "input": "fn swap(a: &mut i32, b: &mut i32) { let temp = *a; *a = *b; *b = temp; } ",
        "instruction": ""
    },
    {
        "output": "Converts a string to uppercase. Arguments: s",
        "input": "fn to_uppercase(s: &str) -> String { s.chars().map(|c| c.to_ascii_uppercase()).collect() } ",
        "instruction": ""
    },
    {
        "output": "Converts a string to lowercase. Arguments: s",
        "input": "fn to_lowercase(s: &str) -> String { s.chars().map(|c| c.to_ascii_lowercase()).collect() } ",
        "instruction": ""
    },
    {
        "output": "Calculates the factorial of a number using recursion. Arguments: n",
        "input": "fn factorial_recursive(n: u32) -> u32 { if n == 0 { 1 } else { n * factorial_recursive(n - 1) } } ",
        "instruction": ""
    },
    {
        "output": "Counts the number of vowels in a string. Arguments: s",
        "input": "fn count_vowels(s: &str) -> usize { s.chars().filter(|&c| \\aeiouAEIOU\\\".contains(c)).count() } \"",
        "instruction": ""
    },
    {
        "output": "Reverses a vector. Arguments: v",
        "input": "fn reverse_vector<T: Clone>(v: &[T]) -> Vec<T> { v.iter().cloned().rev().collect() } ",
        "instruction": ""
    },
    {
        "output": "Checks if two strings are anagrams. Arguments: s1, s2",
        "input": "fn is_anagram(s1: &str, s2: &str) -> bool { let mut v1: Vec<char> = s1.chars().collect(); let mut v2: Vec<char> = s2.chars().collect(); v1.sort_unstable(); v2.sort_unstable(); v1 == v2 } ",
        "instruction": ""
    },
    {
        "output": "Converts a binary string to a decimal number. Arguments: binary",
        "input": "fn binary_to_decimal(binary: &str) -> Result<u32, std::num::ParseIntError> { u32::from_str_radix(binary, 2) } ",
        "instruction": ""
    },
    {
        "output": "Converts a decimal number to a binary string. Arguments: num",
        "input": "fn decimal_to_binary(mut num: u32) -> String { let mut binary = String::new(); while num > 0 { binary.push_str(&(num % 2).to_string()); num /= 2; } binary.chars().rev().collect() } ",
        "instruction": ""
    },
    {
        "output": "Calculates the 'n'th Fibonacci number using iteration. Arguments: n",
        "input": "fn nth_fibonacci(n: u32) -> u32 { if n == 0 { 0 } else if n == 1 { 1 } else { let mut a = 0; let mut b = 1; for _ in 2..=n { let temp = a + b; a = b; b = temp; } b } } ",
        "instruction": ""
    },
    {
        "output": "Checks if a number is an Armstrong number. Arguments: num",
        "input": "fn is_armstrong_number(num: u32) -> bool { let digits: Vec<u32> = num.to_string().chars().map(|d| d.to_digit(10).unwrap()).collect(); let len = digits.len() as u32; num == digits.iter().map(|&d| d.pow(len)).sum::<u32>() } ",
        "instruction": ""
    },
    {
        "output": "Checks if a number is a perfect square. Arguments: num",
        "input": "fn is_perfect_square(num: i32) -> bool { if num < 0 { return false; } let root = (num as f64).sqrt() as i32; root * root == num } ",
        "instruction": ""
    },
    {
        "output": "Checks if a number is a power of two. Arguments: num",
        "input": "fn is_power_of_two(num: u32) -> bool { num > 0 && (num & (num - 1)) == 0 } ",
        "instruction": ""
    },
    {
        "output": "Calculates the greatest common divisor (GCD) of two numbers using an iterative approach. Arguments: a, b",
        "input": "fn gcd_iterative(mut a: u32, mut b: u32) -> u32 { while b != 0 { let temp = b; b = a % b; a = temp; } a } ",
        "instruction": ""
    },
    {
        "output": "Calculates the least common multiple (LCM) of two numbers using their GCD. Arguments: a, b",
        "input": "fn lcm(a: u32, b: u32) -> u32 { a * b / gcd(a, b) } ",
        "instruction": ""
    },
    {
        "output": "Finds the 'n'th prime number. Arguments: n",
        "input": "fn nth_prime(n: usize) -> u32 { let mut count = 0; let mut candidate = 2; while count < n { if (2..=candidate/2).all(|i| candidate % i != 0) { count += 1; } if count < n { candidate += 1; } } candidate } ",
        "instruction": ""
    },
    {
        "output": "Calculates the sum of the cubes of the first 'n' natural numbers. Arguments: n",
        "input": "fn sum_of_cubes(n: i32) -> i32 { (1..=n).map(|x| x * x * x).sum() } ",
        "instruction": ""
    },
    {
        "output": "Checks if a number is palindromic. Arguments: num",
        "input": "fn is_palindromic_number(num: i32) -> bool { let s = num.to_string(); s == s.chars().rev().collect::<String>() } ",
        "instruction": ""
    },
    {
        "output": "Finds the longest common prefix string amongst an array of strings. Arguments: strs",
        "input": "fn longest_common_prefix(strs: Vec<&str>) -> String { if strs.is_empty() { return String::new(); } let mut prefix = strs[0].to_string(); for s in strs.iter().skip(1) { while !s.starts_with(&prefix) { prefix.pop(); if prefix.is_empty() { return String::new(); } } } prefix } ",
        "instruction": ""
    },
    {
        "output": "Finds two numbers in an array that add up to a specific target and returns their indices. Arguments: nums, target",
        "input": "fn two_sum(nums: Vec<i32>, target: i32) -> Option<(usize, usize)> { let mut map = std::collections::HashMap::new(); for (i, num) in nums.iter().enumerate() { if let Some(&index) = map.get(&(target - num)) { return Some((index, i)); } map.insert(num, i); } None } ",
        "instruction": ""
    },
    {
        "output": "Reverses the words in a string. Arguments: s",
        "input": "fn reverse_words(s: &str) -> String { s.split_whitespace().rev().collect::<Vec<&str>>().join(\\ \\\") } \"",
        "instruction": ""
    },
    {
        "output": "Counts the number of prime numbers less than or equal to 'n'. Arguments: n",
        "input": "fn count_primes(n: u32) -> u32 { let mut is_prime = vec![true; (n + 1) as usize]; is_prime[0] = false; if n > 0 { is_prime[1] = false; } for i in 2..=((n as f64).sqrt() as u32) { if is_prime[i as usize] { for j in ((i * i)..=n).step_by(i as usize) { is_prime[j as usize] = false; } } } is_prime.iter().filter(|&&x| x).count() as u32 } ",
        "instruction": ""
    },
    {
        "output": "Flattens a nested list (vector of vectors) into a single vector. Arguments: nested",
        "input": "fn flatten_nested_list(nested: &[Vec<i32>]) -> Vec<i32> { nested.iter().flat_map(|v| v.iter().cloned()).collect() } ",
        "instruction": ""
    },
    {
        "output": "Returns all elements of a matrix in spiral order. Arguments: matrix",
        "input": "fn spiral_order(matrix: Vec<Vec<i32>>) -> Vec<i32> { let mut result = vec![]; if matrix.is_empty() { return result; } let mut top = 0; let mut bottom = matrix.len() as i32 - 1; let mut left = 0; let mut right = matrix[0].len() as i32 - 1; while top <= bottom && left <= right { for i in left..=right { result.push(matrix[top as usize][i as usize]); } top += 1; for i in top..=bottom { result.push(matrix[i as usize][right as usize]); } right -= 1; if top <= bottom { for i in (left..=right).rev() { result.push(matrix[bottom as usize][i as usize]); } bottom -= 1; } if left <= right { for i in (top..=bottom).rev() { result.push(matrix[i as usize][left as usize]); } left += 1; } } result } ",
        "instruction": ""
    },
    {
        "output": "Transposes a non-square matrix and returns the result. Arguments: matrix",
        "input": "fn transpose_non_square(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> { let mut transposed = vec![vec![0; matrix.len()]; matrix[0].len()]; for i in 0..matrix.len() { for j in 0..matrix[0].len() { transposed[j][i] = matrix[i][j]; } } transposed } ",
        "instruction": ""
    },
    {
        "output": "Finds the missing number in an array containing numbers from 1 to 'n'. Arguments: arr, n",
        "input": "fn find_missing_number(arr: &[i32], n: i32) -> i32 { let expected_sum: i32 = (n * (n + 1)) / 2; let actual_sum: i32 = arr.iter().sum(); expected_sum - actual_sum } ",
        "instruction": ""
    },
    {
        "output": "Merges two sorted arrays into one sorted array. Arguments: arr1, arr2",
        "input": "fn merge_sorted_arrays(arr1: &[i32], arr2: &[i32]) -> Vec<i32> { let mut merged = Vec::with_capacity(arr1.len() + arr2.len()); let mut i = 0; let mut j = 0; while i < arr1.len() && j < arr2.len() { if arr1[i] < arr2[j] { merged.push(arr1[i]); i += 1; } else { merged.push(arr2[j]); j += 1; } } merged.extend_from_slice(&arr1[i..]); merged.extend_from_slice(&arr2[j..]); merged } ",
        "instruction": ""
    },
    {
        "output": "Checks if a string of parentheses is valid. Arguments: s",
        "input": "fn is_valid_parentheses(s: &str) -> bool { let mut stack = Vec::new(); for c in s.chars() { match c { '(' => stack.push(')'), '{' => stack.push('}'), '[' => stack.push(']'), ')' | '}' | ']' => if stack.pop() != Some(c) { return false; }, _ => () } } stack.is_empty() } ",
        "instruction": ""
    },
    {
        "output": "Removes all instances of a value in place and returns the new length. Arguments: arr, val",
        "input": "fn remove_element(arr: &mut Vec<i32>, val: i32) -> usize { arr.retain(|&x| x != val); arr.len() } ",
        "instruction": ""
    },
    {
        "output": "Finds the single number in an array where every element appears twice except for one. Arguments: nums",
        "input": "fn find_single_number(nums: Vec<i32>) -> i32 { nums.iter().fold(0, |acc, &num| acc ^ num) } ",
        "instruction": ""
    },
    {
        "output": "Finds the maximum sum of a contiguous subarray. Arguments: nums",
        "input": "fn max_subarray_sum(nums: Vec<i32>) -> i32 { let mut max_sum = nums[0]; let mut current_sum = nums[0]; for &num in &nums[1..] { current_sum = std::cmp::max(num, current_sum + num); max_sum = std::cmp::max(max_sum, current_sum); } max_sum } ",
        "instruction": ""
    },
    {
        "output": "Finds the majority element in an array (element that appears more than half the time). Arguments: nums",
        "input": "fn find_majority_element(nums: Vec<i32>) -> i32 { let mut count = 0; let mut candidate = 0; for &num in &nums { if count == 0 { candidate = num; } count += if num == candidate { 1 } else { -1 }; } candidate } ",
        "instruction": ""
    },
    {
        "output": "Finds the minimum path sum from the top left to the bottom right in a grid. Arguments: grid",
        "input": "fn min_path_sum(grid: Vec<Vec<i32>>) -> i32 { let mut grid = grid; let rows = grid.len(); let cols = grid[0].len(); for i in 1..rows { grid[i][0] += grid[i-1][0]; } for j in 1..cols { grid[0][j] += grid[0][j-1]; } for i in 1..rows { for j in 1..cols { grid[i][j] += std::cmp::min(grid[i-1][j], grid[i][j-1]); } } grid[rows-1][cols-1] } ",
        "instruction": ""
    },
    {
        "output": "Calculates the greatest common divisor (GCD) of two integers using the Euclidean algorithm. Arguments: a, b",
        "input": "fn gcd(mut a: i32, mut b: i32) -> i32 { while b != 0 { let temp = b; b = a % b; a = temp; } a } ",
        "instruction": ""
    },
    {
        "output": "Calculates the least common multiple (LCM) of two integers. Arguments: a, b",
        "input": "fn lcm(a: i32, b: i32) -> i32 { (a * b) / gcd(a, b) } ",
        "instruction": ""
    },
    {
        "output": "Counts the number of vowels in a string. Arguments: s",
        "input": "fn count_vowels(s: &str) -> usize { s.chars().filter(|c| \\aeiouAEIOU\\\".contains(*c)).count() } \"",
        "instruction": ""
    },
    {
        "output": "Reverses a string. Arguments: s",
        "input": "fn reverse_string(s: &str) -> String { s.chars().rev().collect() } ",
        "instruction": ""
    },
    {
        "output": "Checks if two strings are anagrams. Arguments: s1, s2",
        "input": "fn are_anagrams(s1: &str, s2: &str) -> bool { let mut chars1: Vec<char> = s1.chars().collect(); let mut chars2: Vec<char> = s2.chars().collect(); chars1.sort_unstable(); chars2.sort_unstable(); chars1 == chars2 } ",
        "instruction": ""
    },
    {
        "output": "Generates a specific row of Pascal's Triangle. Arguments: row",
        "input": "fn pascal_triangle_row(row: usize) -> Vec<i32> { let mut row_vec = vec![1]; for k in 1..=row { row_vec.push(row_vec[k - 1] * (row - k + 1) as i32 / k as i32); } row_vec } ",
        "instruction": ""
    },
    {
        "output": "Generates a list of prime numbers up to 'n' using the Sieve of Eratosthenes. Arguments: n",
        "input": "fn sieve_of_eratosthenes(n: usize) -> Vec<usize> { let mut is_prime = vec![true; n + 1]; is_prime[0] = false; if n > 0 { is_prime[1] = false; } for i in 2..=((n as f64).sqrt() as usize) { if is_prime[i] { for j in (i*i..=n).step_by(i) { is_prime[j] = false; } } } (2..=n).filter(|&x| is_prime[x]).collect() } ",
        "instruction": ""
    },
    {
        "output": "Rotates an array to the right by 'k' steps. Arguments: arr, k",
        "input": "fn rotate_array(arr: &mut [i32], k: usize) { let len = arr.len(); arr.reverse(); arr[..k % len].reverse(); arr[k % len..].reverse(); } ",
        "instruction": ""
    },
    {
        "output": "Counts the number of 1 bits in the binary representation of a number. Arguments: n",
        "input": "fn count_bits(n: u32) -> u32 { let mut count = 0; let mut num = n; while num != 0 { count += num & 1; num >>= 1; } count } ",
        "instruction": ""
    },
    {
        "output": "Finds a peak element in the array (an element that is greater than its neighbors). Arguments: arr",
        "input": "fn find_peak_element(arr: &[i32]) -> Option<usize> { for i in 1..arr.len() - 1 { if arr[i] > arr[i - 1] && arr[i] > arr[i + 1] { return Some(i); } } None } ",
        "instruction": ""
    },
    {
        "output": "Converts a string into a zigzag pattern on a given number of rows. Arguments: s, num_rows",
        "input": "fn zigzag_conversion(s: &str, num_rows: usize) -> String { if num_rows == 1 { return s.to_string(); } let mut rows = vec![String::new(); num_rows.min(s.len())]; let mut cur_row = 0; let mut going_down = false; for c in s.chars() { rows[cur_row].push(c); if cur_row == 0 || cur_row == num_rows - 1 { going_down = !going_down; } cur_row = if going_down { cur_row + 1 } else { cur_row.saturating_sub(1) }; } rows.concat() } ",
        "instruction": ""
    },
    {
        "output": "Finds the longest palindromic substring in a given string. Arguments: s",
        "input": "fn longest_palindromic_substring(s: &str) -> String { let s = s.as_bytes(); let n = s.len(); if n == 0 { return String::new(); } let mut start = 0; let mut end = 0; for i in 0..n { let (mut l, mut r) = (i, i); while r < n && s[l] == s[r] { if r - l > end - start { start = l; end = r; } if l == 0 { break; } l -= 1; r += 1; } let (mut l, mut r) = (i, i + 1); while r < n && s[l] == s[r] { if r - l > end - start { start = l; end = r; } if l == 0 { break; } l -= 1; r += 1; } } s[start..=end].iter().map(|&c| c as char).collect() } ",
        "instruction": ""
    },
    {
        "output": "Converts a Roman numeral to its integer representation. Arguments: s",
        "input": "fn roman_to_integer(s: &str) -> i32 { let mut roman_map = std::collections::HashMap::new(); roman_map.insert('I', 1); roman_map.insert('V', 5); roman_map.insert('X', 10); roman_map.insert('L', 50); roman_map.insert('C', 100); roman_map.insert('D', 500); roman_map.insert('M', 1000); let chars: Vec<char> = s.chars().collect(); let mut total = 0; for i in 0..chars.len() { let value = roman_map[&chars[i]]; if i < chars.len() - 1 && value < roman_map[&chars[i + 1]] { total -= value; } else { total += value; } } total } ",
        "instruction": ""
    },
    {
        "output": "Converts an Excel sheet column title to its corresponding column number. Arguments: s",
        "input": "fn title_to_number(s: &str) -> i32 { s.chars().rev().enumerate().map(|(i, c)| (c as i32 - 'A' as i32 + 1) * 26_i32.pow(i as u32)).sum() } ",
        "instruction": ""
    },
    {
        "output": "Converts a column number to its corresponding Excel sheet column title. Arguments: n",
        "input": "fn number_to_title(mut n: i32) -> String { let mut title = String::new(); while n > 0 { n -= 1; title.push((b'A' + (n % 26) as u8) as char); n /= 26; } title.chars().rev().collect() } ",
        "instruction": ""
    },
    {
        "output": "Determines if a number is a happy number. Arguments: n",
        "input": "fn is_happy_number(mut n: i32) -> bool { let mut seen = std::collections::HashSet::new(); while n != 1 && !seen.contains(&n) { seen.insert(n); n = n.to_string().chars().map(|c| c.to_digit(10).unwrap().pow(2)).sum::<u32>() as i32; } n == 1 } ",
        "instruction": ""
    },
    {
        "output": "Adds two binary numbers represented as strings. Arguments: a, b",
        "input": "fn add_binary(a: String, b: String) -> String { let mut a = a.chars().rev().peekable(); let mut b = b.chars().rev().peekable(); let mut carry = 0; let mut result = String::new(); while a.peek().is_some() || b.peek().is_some() || carry != 0 { let mut sum = carry; if let Some(ch) = a.next() { sum += ch.to_digit(2).unwrap(); } if let Some(ch) = b.next() { sum += ch.to_digit(2).unwrap(); } result.push(std::char::from_digit(sum % 2, 2).unwrap()); carry = sum / 2; } result.chars().rev().collect() } ",
        "instruction": ""
    },
    {
        "output": "Adds two numbers represented by linked lists. Arguments: l1, l2",
        "input": "fn add_two_numbers(l1: Option<Box<ListNode>>, l2: Option<Box<ListNode>>) -> Option<Box<ListNode>> { let mut l1 = l1; let mut l2 = l2; let mut head = None; let mut tail = &mut head; let mut carry = 0; while l1.is_some() || l2.is_some() || carry != 0 { let sum = carry + l1.as_ref().map_or(0, |node| node.val) + l2.as_ref().map_or(0, |node| node.val); carry = sum / 10; let node = Box::new(ListNode { val: sum % 10, next: None }); if let Some(ref mut tail_node) = tail { tail_node.next = Some(node); tail = &mut tail_node.next; } else { head = Some(node); tail = &mut head; } l1 = l1.and_then(|node| node.next); l2 = l2.and_then(|node| node.next); } head } ",
        "instruction": ""
    },
    {
        "output": "Checks if a Sudoku board is valid. Arguments: board",
        "input": "fn is_valid_sudoku(board: Vec<Vec<char>>) -> bool { let mut rows = vec![vec![false; 9]; 9]; let mut cols = vec![vec![false; 9]; 9]; let mut boxes = vec![vec![false; 9]; 9]; for i in 0..9 { for j in 0..9 { if board[i][j] == '.' { continue; } let num = board[i][j] as usize - '1' as usize; if rows[i][num] || cols[j][num] || boxes[(i / 3) * 3 + j / 3][num] { return false; } rows[i][num] = true; cols[j][num] = true; boxes[(i / 3) * 3 + j / 3][num] = true; } } true } ",
        "instruction": ""
    },
    {
        "output": "Creates a RawT struct instance with sty::ty_nil and None as fields",
        "input": "enum sty { ty_nil, }struct RawT { struct_: sty, cname: Option<String>, hash: usize }fn mk_raw_ty(st: sty, cname: Option<String>) -> RawT { return RawT { struct_: st, cname: cname, hash: 0 }; }pub fn main() { mk_raw_ty(sty::ty_nil, None::<String>); }",
        "instruction": "Defines an enum sty with one variant ty_nil, a struct RawT with fields struct_ of type sty, cname as an optional String, and hash as usize. The function mk_raw_ty creates and returns a RawT instance with the provided parameters. The main function calls mk_raw_ty with sty::ty_nil and None as arguments."
    },
    {
        "output": "The code defines a Rust struct named 'Foo' with the attributes 'Copy' and 'Clone'. It also includes an empty main function.",
        "input": "#[derive(Copy, Clone)]\npub struct Foo;\n\npub fn main() {}",
        "instruction": "The code demonstrates how to define a struct in Rust with the derived traits 'Copy' and 'Clone'. The main function is empty and serves as the entry point of the program."
    },
    {
        "output": "Defines multiple functions with different generic and lifetime constraints, showcasing type mismatch errors",
        "input": "fn main() { f1(|_: (), _: ()| {}); f2(|_: (), _: ()| {}); f3(|_: (), _: ()| {}); f4(|_: (), _: ()| {}); f5(|_: (), _: ()| {}); g1(|_: (), _: Box<dyn Fn(&())>| {}); g2(|_: (), _: fn(&())| {}); g3(|_: (), _: Box<dyn Fn(&())>| {}); g4(|_: (), _: fn(&())| {}); h1(|_: (), _: Box<dyn Fn(&())>, _: (), _: fn(&(), &())| {}); h2(|_: (), _: Box<dyn Fn(&())>, _: &(), _: fn(&(), &())| {});}fn f1<F>(_: F) where F: Fn(&(), &()) {}fn f2<F>(_: F) where F: for<'a> Fn(&'a (), &()) {}fn f3<'a, F>(_: F) where F: Fn(&'a (), &()) {}fn f4<F>(_: F) where F: for<'r> Fn(&(), &'r ()) {}fn f5<F>(_: F) where F: for<'r> Fn(&'r (), &'r ()) {}fn g1<F>(_: F) where F: Fn(&(), Box<dyn Fn(&())>) {}fn g2<F>(_: F) where F: Fn(&(), fn(&())) {}fn g3<F>(_: F) where F: for<'s> Fn(&'s (), Box<dyn Fn(&())>) {}fn g4<F>(_: F) where F: Fn(&(), for<'r> fn(&'r ())) {}fn h1<F>(_: F) where F: Fn(&(), Box<dyn Fn(&())>, &(), fn(&(), &())) {}fn h2<F>(_: F) where F: for<'t0> Fn(&(), Box<dyn Fn(&())>, &'t0 (), fn(&(), &())) {}",
        "instruction": "The code defines various functions with different generic and lifetime parameters, leading to type mismatch errors when called in the main function."
    },
    {
        "output": "The Rust code defines a function named 'f' that returns the integer 3. It then calls this function from the 'main' function and asserts that the returned value is 3.",
        "input": "fn f() -> isize { return 3; } fn main() { assert_eq!(f(), 3); }",
        "instruction": "Defines a function 'f' that returns 3, then asserts that calling 'f' in the 'main' function returns 3."
    },
    {
        "output": "Performs various type-casting operations and asserts the expected results",
        "input": "fn main() { assert_eq!(3 as usize * 3, 9); assert_eq!(3 as usize * 3, 9); assert_eq!(3 as usize / 3, 1); assert_eq!(3 as usize + 3, 6); assert_eq!(3 as usize + 3, 6); }",
        "instruction": "Demonstrates type-casting in Rust using the 'as' keyword and asserts the results of arithmetic operations."
    },
    {
        "output": "Demonstrates assignment expressions resulting in nil values",
        "input": "fn test_assign() {    let mut x: isize;    let y: () = x = 10;    assert_eq!(x, 10);    assert_eq!(y, ());    let mut z: () = x = 11;    assert_eq!(x, 11);    assert_eq!(z, ());    z = x = 12;    assert_eq!(x, 12);    assert_eq!(z, ());}fn test_assign_op() {    let mut x: isize = 0;    let y: () = x += 10;    assert_eq!(x, 10);    assert_eq!(y, ());    let mut z: () = x += 11;    assert_eq!(x, 21);    assert_eq!(z, ());    z = x += 12;    assert_eq!(x, 33);    assert_eq!(z, ());}pub fn main() { test_assign(); test_assign_op(); }",
        "instruction": "The code shows how assignment expressions result in nil values, where assignment to a variable that is not a unit type results in unit type (). The code includes two functions: test_assign() for simple assignments and test_assign_op() for assignments with operators like +=. The main function calls both test functions to demonstrate the behavior."
    },
    {
        "output": "Prints 'v=1' and 'v=2' to the console",
        "input": "fn main() {\n    let mut v: isize;\n    v = 1;\n    println!(\"v={}\", v);\n    v = 2;\n    println!(\"v={}\", v);\n}",
        "instruction": "Declares a mutable variable 'v', assigns it the values 1 and 2, then prints the values to the console. Demonstrates mutable variable declaration and assignment in Rust."
    },
    {
        "output": "Defines a trait and a struct in Rust",
        "input": "trait Foo {    #[lang = \"dummy_lang_item_1\"] //~ ERROR definition    fn foo() {}    #[lang = \"dummy_lang_item_2\"] //~ ERROR definition    fn bar();    #[lang = \"dummy_lang_item_3\"] //~ ERROR definition    type MyType;}struct Bar;impl Bar {    #[lang = \"dummy_lang_item_4\"] //~ ERROR definition    fn test() {}}fn main() {}",
        "instruction": "Defines a trait 'Foo' with methods, associated type, and a struct 'Bar' with an implementation block. Shows the structure of defining traits and structs in Rust."
    },
    {
        "output": "Returns the sum of a specific element from two different arrays based on a condition",
        "input": "fn that_odd_parse(c: bool, n: usize) -> u32 {let x = 2;let a = [1, 2, 3, 4];let b = [5, 6, 7, 7];x + if c { a } else { b }[n]}fn main() {assert_eq!(4, that_odd_parse(true, 1));assert_eq!(8, that_odd_parse(false, 1));}",
        "instruction": "Defines a function that takes a boolean and an index, accesses elements from two arrays based on the boolean value, and returns the sum of the element and a constant value. Demonstrates the use of arrays, conditional expressions, and function calls with assertions in Rust."
    },
    {
        "output": "Defines multiple variables with associated paths starting with `<<`",
        "input": "fn main() { let _: <<A>::B>::C; let _ = <<A>::B>::C; let _ = <<A>::B>::C; let _ = 0 ..= <<A>::B>::C; <<A>::B>::C; }",
        "instruction": "The code demonstrates defining variables with associated paths starting with `<<` which are not found in the scope, leading to compilation errors."
    },
    {
        "output": "Creates a mutable reference to an AtomicU64 value initialized to 0 but fails due to the 'from_mut' function not being found for the struct 'AtomicU64'.",
        "input": "fn main() {\n    let _ = core::sync::atomic::AtomicU64::new(0);\n}",
        "instruction": "Demonstrates creating a new AtomicU64 instance and initializing it with the value 0 in a Rust program."
    },
    {
        "output": "Demonstrates error messages for attempting to access fields on primitive types in Rust",
        "input": "fn main() { let x = 0; let _ = x.foo; let _ = x.bar; let _ = 0.f; let _ = 2.l; let _ = 12.F; let _ = 34.L; }",
        "instruction": "The code attempts to access fields on primitive integer types which is not allowed in Rust, triggering compiler errors. This showcases Rust's strong typing and compile-time checks."
    },
    {
        "output": "The code contains an error pattern with the message 'expected item'.",
        "input": "fn main() { //@ error-pattern: expected item\n    #![attr = \"val\"]\n    #[attr = \"val\"]\n}",
        "instruction": "In Rust, attributes can be used to provide additional information to the compiler. The code demonstrates defining attributes using different syntax like '#!' and '#'. The 'error-pattern' attribute specifies the expected error message pattern."
    },
    {
        "output": "Defines a public function named 'main' with no parameters",
        "input": "fn main() { }",
        "instruction": "This code defines a basic Rust program with a public function named 'main'. In Rust, the 'main' function is the entry point of the program."
    },
    {
        "output": "Defines the entry point of a Rust program using the `#[start]` attribute.",
        "input": "fn main() { println!(\"Hello, world!\"); }",
        "instruction": "The original code snippet was defining the program entry point using the unstable `#[start]` attribute. This snippet replaces it with the standard `fn main()` function that prints 'Hello, world!' to the console."
    },
    {
        "output": "Defines a struct named I with a field i of type u8",
        "input": "struct I { i: u8, }",
        "instruction": "Declaring a struct in Rust with a single field of type u8."
    },
    {
        "output": "Defines an enum `FooEnum` with variant `Bar` containing an integer value, and a struct `FooStruct` with a field `bar`. Creates instances of `FooEnum` and `FooStruct`, and performs pattern matching on them.",
        "input": "enum FooEnum { Bar(i32), } struct FooStruct { bar: i32, } fn main() { let foo_enum_bar = FooEnum::Bar(1); match foo_enum_bar { FooEnum::Bar(x) => {}, _ => {} } let foo_struct = FooStruct { bar: 1 }; match foo_struct { FooStruct { bar } => {} } match 1 { 0 => {}, _ => {} } let _another_foo_struct = FooStruct { bar: 1 }; }",
        "instruction": "Demonstrates defining enums and structs in Rust, creating instances of them, and performing pattern matching to extract values."
    },
    {
        "output": "Defines an enum 'FooEnum' with a variant 'Bar' containing an integer, and a struct 'FooStruct' with a field 'bar' of type integer. In the main function, creates instances of 'FooEnum' and 'FooStruct', matches on them, and also matches on an integer literal.",
        "input": "enum FooEnum { Bar(i32) } struct FooStruct { bar: i32 } fn main() { let foo_enum_bar = FooEnum::Bar(1); match foo_enum_bar { FooEnum::Bar(x) => {} _ => {} } let foo_struct = FooStruct { bar: 1 }; match foo_struct { FooStruct { bar } => {} } match 1 { 0 => {} _ => {} } let _another_foo_struct = FooStruct { bar: 1 }; }",
        "instruction": "Demonstrates defining enums and structs, creating instances, pattern matching on them, and matching on integer literals in Rust."
    },
    {
        "output": "Increments the value of a custom type 'Int' by 1",
        "input": "extern crate augmented_assignments;\nuse augmented_assignments::Int;\nfn main() {\n    let mut x = Int(0);\n    x += 1;\n}",
        "instruction": "The code demonstrates the usage of augmented assignments in Rust by incrementing a custom integer type 'Int' by 1."
    },
    {
        "output": "Demonstrates various assignment and bitwise operations on custom integer type Int and slice operations on arrays",
        "input": "//@ run-pass\n#![allow(unused_imports)]\n#![deny(unused_assignments)]\nuse std::mem;\nuse std::ops::{AddAssign, BitAndAssign, BitOrAssign, BitXorAssign, DivAssign, Index, MulAssign, RemAssign, ShlAssign, ShrAssign, SubAssign};\n\n#[derive(Debug, PartialEq)]\nstruct Int(i32);\n\nstruct Slice([i32]);\n\nimpl Slice {\n    fn new(slice: &mut [i32]) -> &mut Slice {\n        unsafe {\n            mem::transmute(slice)\n        }\n    }\n}\n\nstruct View<'a>(&'a mut [i32]);\n\nfn main() {\n    let mut x = Int(1);\n    x += Int(2);\n    assert_eq!(x, Int(0b11));\n    x &= Int(0b01);\n    assert_eq!(x, Int(0b01));\n    x |= Int(0b10);\n    assert_eq!(x, Int(0b11));\n    x ^= Int(0b01);\n    assert_eq!(x, Int(0b10));\n    x /= Int(2);\n    assert_eq!(x, Int(1));\n    x *= Int(3);\n    assert_eq!(x, Int(3));\n    x %= Int(2);\n    assert_eq!(x, Int(1));\n    // overloaded RHS\n    x <<= 1u8;\n    assert_eq!(x, Int(2));\n    x <<= 1u16;\n    assert_eq!(x, Int(4));\n    x >>= 1u8;\n    assert_eq!(x, Int(2));\n    x >>= 1u16;\n    assert_eq!(x, Int(1));\n    x -= Int(1);\n    assert_eq!(x, Int(0));\n    // indexed LHS\n    let mut v = vec![Int(1), Int(2)];\n    v[0] += Int(2);\n    assert_eq!(v[0], Int(3));\n    // unsized RHS\n    let mut array = [0, 1, 2];\n    *Slice::new(&mut array) += 1;\n    assert_eq!(array[0], 1);\n    assert_eq!(array[1], 2);\n    assert_eq!(array[2], 3);\n    // sized indirection\n    // check that this does *not* trigger the unused_assignments lint\n    let mut array = [0, 1, 2];\n    let mut view = View(&mut array);\n    view += 1;\n}\n\nimpl AddAssign for Int {\n    fn add_assign(&mut self, rhs: Int) {\n        self.0 += rhs.0;\n    }\n}\n\nimpl BitAndAssign for Int {\n    fn bitand_assign(&mut self, rhs: Int) {\n        self.0 &= rhs.0;\n    }\n}\n\nimpl BitOrAssign for Int {\n    fn bitor_assign(&mut self, rhs: Int) {\n        self.0 |= rhs.0;\n    }\n}\n\nimpl BitXorAssign for Int {\n    fn bitxor_assign(&mut self, rhs: Int) {\n        self.0 ^= rhs.0;\n    }\n}\n\nimpl DivAssign for Int {\n    fn div_assign(&mut self, rhs: Int) {\n        self.0 /= rhs.0;\n    }\n}\n\nimpl MulAssign for Int {\n    fn mul_assign(&mut self, rhs: Int) {\n        self.0 *= rhs.0;\n    }\n}\n\nimpl RemAssign for Int {\n    fn rem_assign(&mut self, rhs: Int) {\n        self.0 %= rhs.0;\n    }\n}\n\nimpl ShlAssign<u8> for Int {\n    fn shl_assign(&mut self, rhs: u8) {\n        self.0 <<= rhs;\n    }\n}\n\nimpl ShlAssign<u16> for Int {\n    fn shl_assign(&mut self, rhs: u16) {\n        self.0 <<= rhs;\n    }\n}\n\nimpl ShrAssign<u8> for Int {\n    fn shr_assign(&mut self, rhs: u8) {\n        self.0 >>= rhs;\n    }\n}\n\nimpl ShrAssign<u16> for Int {\n    fn shr_assign(&mut self, rhs: u16) {\n        self.0 >>= rhs;\n    }\n}\n\nimpl SubAssign for Int {\n    fn sub_assign(&mut self, rhs: Int) {\n        self.0 -= rhs.0;\n    }\n}\n\nimpl AddAssign<i32> for Slice {\n    fn add_assign(&mut self, rhs: i32) {\n        for lhs in &mut self.0 {\n            *lhs += rhs;\n        }\n    }\n}\n\nimpl<'a> AddAssign<i32> for View<'a> {\n    fn add_assign(&mut self, rhs: i32) {\n        for lhs in self.0.iter_mut() {\n            *lhs += rhs;\n        }\n    }\n}\n",
        "instruction": "The code defines a custom integer type `Int` and demonstrates various assignment and bitwise operations on it. It also shows slice operations on arrays. The code implements traits for assignment operators like `+=`, `&=`, `|=`, `^=`, `/=`, `*=`, `%=`, `<<=`, and `>>=`. This showcases how operator overloading and custom types work in Rust."
    },
    {
        "output": "Defines a custom struct 'Int' and implements the 'AddAssign' trait for it. Attempts to perform an addition assignment operation on 'x' and 'y' instances of 'Int' struct.",
        "input": "use std::ops::AddAssign;#[derive(Clone)]\nstruct Int(i32);\nimpl AddAssign for Int {\n    fn add_assign(&mut self, _: Int) {\n        unimplemented!()\n    }\n}\nfn main() {\n    let mut x = Int(1);\n    x += x;\n    let y = Int(2);\n    y += Int(1);\n}",
        "instruction": "The code showcases struct definition, trait implementation, and usage of the 'AddAssign' trait in Rust, demonstrating borrowing and mutation concepts."
    },
    {
        "output": "Prints the value of 'x' field of a Pair struct containing a Triple struct and an integer",
        "input": "//@ run-pass\n#![allow(dead_code)]\n#[derive(Debug)]\nstruct Pair<T, U> {\n    a: T,\n    b: U\n}\n\nstruct Triple {\n    x: isize,\n    y: isize,\n    z: isize\n}\n\nfn f<T, U>(x: T, y: U) -> Pair<T, U> {\n    return Pair { a: x, b: y };\n}\n\npub fn main() {\n    println!(\"{}\", f(Triple { x: 3, y: 4, z: 5 }, 4).a.x);\n    println!(\"{}\", f(5, 6).a);\n}",
        "instruction": "Defines a Pair struct with two generic types, a Triple struct with three integer fields, and a function f that returns a Pair instance. In the main function, it creates Pair instances with different types and prints the 'x' field of the 'a' field of each Pair instance."
    },
    {
        "output": "Demonstrates method lookup in Rust and borrowing behavior",
        "input": "fn main() { let mut a = vec![0]; a.test_mut(); a.test(); ([1]).test(); (&[1]).test(); } trait MyIter { fn test_mut(&mut self); fn test(&self); } impl<'a> MyIter for &'a [isize] { fn test_mut(&mut self) { } fn test(&self) { } } impl<'a> MyIter for &'a str { fn test_mut(&mut self) { } fn test(&self) { } }",
        "instruction": "Defines a trait with methods for mutable and immutable references and implements it for slices and strings to show method lookup and borrowing rules in Rust."
    },
    {
        "output": "Defines two structs, Clam and Fish, each containing a Boxed isize field. Instantiates instances of Clam and Fish with values. Adds the x field of Clam 'a' and the y field of Clam 'b' to get 'z'. Adds the a field of Fish 'forty' and the a field of Fish 'two' to get 'answer'. Prints 'z' and 'answer' to the console and asserts their values.",
        "input": "struct Clam { x: Box<isize>, y: Box<isize>, } struct Fish { a: Box<isize>, } fn main() { let a: Clam = Clam{ x: Box::new(1), y: Box::new(2) }; let b: Clam = Clam{ x: Box::new(10), y: Box::new(20) }; let z: isize = *a.x + *b.y; println!(\"{}\", z); assert_eq!(z, 21); let forty: Fish = Fish{ a: Box::new(40) }; let two: Fish = Fish{ a: Box::new(2) }; let answer: isize = *forty.a + *two.a; println!(\"{}\", answer); assert_eq!(answer, 42); }",
        "instruction": "Defines structs with Boxed isize fields, instantiates them, performs addition operations, prints the results, and asserts their values. Demonstrates working with Boxed values and basic arithmetic operations in Rust."
    },
    {
        "output": "Prints 'hello' to the console and concatenates two strings 'foo' and 'bar' to return 'foobar'",
        "input": "fn call_f<F:FnMut()>(mut f: F) { f(); }fn f() { println!(\"hello\"); }fn call_g<G:FnMut(String,String) -> String>(mut g: G, x: String, y: String) -> String { g(x, y) }fn g(mut x: String, y: String) -> String { x.push_str(&y); x }fn main() { call_f(f); assert_eq!(call_g(g, \"foo\".to_string(), \"bar\".to_string()), \"foobar\"); }",
        "instruction": "Defines functions to call a function 'f' that prints 'hello' and another function 'g' that concatenates two strings. The 'main' function calls 'f' using 'call_f' and asserts the result of calling 'g' with 'foo' and 'bar' strings."
    },
    {
        "output": "Prints 'foo' to the console",
        "input": "fn main() { let x: &'static str = \"foo\"; println!(\"{}\", x); }",
        "instruction": "Defines a static string variable 'x' with value 'foo' and then prints the value of 'x' to the console using println macro."
    },
    {
        "output": "Checks various equality assertions related to overflowing literals in Rust",
        "input": "fn main() {\n    assert_eq!(0xffffffff, (!0 as u32));\n    assert_eq!(4294967295, (!0 as u32));\n    assert_eq!(0xffffffffffffffff, (!0 as u64));\n    assert_eq!(18446744073709551615, (!0 as u64));\n    assert_eq!((-2147483648i32).wrapping_sub(1), 2147483647);\n    assert_eq!(-3.40282356e+38_f32, f32::MIN);\n    assert_eq!(3.40282356e+38_f32, f32::MAX);\n    assert_eq!(-1.7976931348623158e+308_f64, f64::MIN);\n    assert_eq!(1.7976931348623158e+308_f64, f64::MAX);\n}",
        "instruction": "The code contains assertions to test overflowing literals in Rust, comparing them with their respective maximum and minimum values for different data types."
    },
    {
        "output": "Creates an Arc smart pointer containing a boolean value, wraps it in a Some option, matches on the option to handle Some case by calling a dispose function with the wrapped value and panics for None case",
        "input": "use std::sync::Arc;fn dispose(_x: Arc<bool>) { }fn main() { let p = Arc::new(true); let x = Some(p); match x { Some(z) => { dispose(z); }, None => panic!() }}",
        "instruction": "Defines an Arc smart pointer, uses an option to wrap the pointer, matches on the option to handle the wrapped value or None case, illustrating pattern matching and smart pointer usage in Rust."
    },
    {
        "output": "Swaps two integers using bitwise XOR operations and performs various bitwise operations",
        "input": "fn main() { let mut a: isize = 1; let mut b: isize = 2; a ^= b; b ^= a; a = a ^ b; println!(\"{}\", a); println!(\"{}\", b); assert_eq!(b, 1); assert_eq!(a, 2); assert_eq!(!0xf0_isize & 0xff, 0xf); assert_eq!(0xf0_isize | 0xf, 0xff); assert_eq!(0xf_isize << 4, 0xf0); assert_eq!(0xf0_isize >> 4, 0xf); assert_eq!(-16 >> 2, -4); assert_eq!(0b1010_1010_isize | 0b0101_0101, 0xff); }",
        "instruction": "The code demonstrates swapping two integers using XOR operations and performs various bitwise operations like AND, OR, left shift, right shift, and binary OR."
    },
    {
        "output": "Prints 'rgb' to the console",
        "input": "enum Color { Rgb(isize, isize, isize), Rgba(isize, isize, isize, isize), } fn main() { let red: Color = Color::Rgb(255, 0, 0); match red { Color::Rgb(r, g, b) => { println!(\"rgb\"); } _ => {} } }",
        "instruction": "Defines an enum representing color with variants Rgb and Rgba, initializes a red color Rgb(255, 0, 0), and uses a match statement to print 'rgb' when matching the Rgb variant."
    },
    {
        "output": "Calls the custom method 'foo' on a vector of integers",
        "input": "//@ run-passtrait Foo { fn foo(self); } impl<'a> Foo for &'a [isize] { fn foo(self) {} } pub fn main() { let items = vec![3, 5, 1, 2, 4]; items.foo(); }",
        "instruction": "Defines a trait 'Foo' with a method 'foo' and implements it for a reference to a slice of signed integers. The 'main' function creates a vector of integers and calls the 'foo' method on it."
    },
    {
        "output": "Defines multiple custom function types A, B, C, D, and E with different lifetime and generic type parameters",
        "input": "type A = for<'b, 'a: 'b> fn();\ntype B = for<'b, 'a: 'b> fn();\ntype C = for<'b, 'a: 'b> fn();\ntype D = for<'a, T> fn();\ntype E = for<'a, T> fn();",
        "instruction": "Demonstrates the declaration of custom function types with lifetime and generic type parameters in Rust."
    },
    {
        "output": "Demonstrates breaking a loop and returning a value using a block",
        "input": "fn loop_break_return() -> i32 {    let loop_value = loop { break return 0 }; }",
        "instruction": "The function 'loop_break_return' defines a loop where it breaks and returns a value of 0 using a block."
    },
    {
        "output": "Demonstrates breaking a loop and continuing the loop using a block",
        "input": "fn loop_break_loop() -> i32 {    let loop_value = loop { break loop {} }; }",
        "instruction": "The function 'loop_break_loop' shows breaking a loop and continuing the loop using a block."
    },
    {
        "output": "Contains an error due to mismatched types when trying to break a loop with another break",
        "input": "fn loop_break_break() -> i32 {    let loop_value = loop { break break; }; }",
        "instruction": "This code has a type mismatch error as it tries to break a loop with another break statement."
    },
    {
        "output": "Illustrates breaking a loop and returning a value using a block with a return statement",
        "input": "fn loop_break_return_2() -> i32 {    let loop_value = loop { break { return 0; () }; }; }",
        "instruction": "The function 'loop_break_return_2' demonstrates breaking a loop and returning a value of 0 using a block with a return statement."
    },
    {
        "output": "Demonstrates mismatched types error when trying to break a loop with a function returning a custom type",
        "input": "fn loop_break_void() -> i32 {    let loop_value = loop { break get_void(); }; }",
        "instruction": "This snippet produces a type mismatch error as it tries to break a loop with a function 'get_void' returning a custom type."
    },
    {
        "output": "Shows breaking a loop with a function returning the never type",
        "input": "fn loop_break_never() -> i32 {    let loop_value = loop { break get_never(); }; }",
        "instruction": "The function 'loop_break_never' exemplifies breaking a loop with a function 'get_never' returning the never type."
    },
    {
        "output": "Demonstrates cleaning up resources in case of unwinding by panic in `Clone` implementation",
        "input": "use std::thread;use std::rc::Rc;struct S(Rc<()>);impl Clone for S {    fn clone(&self) -> Self {        if Rc::strong_count(&self.0) == 7 {            panic!(\"oops\");        }        S(self.0.clone())    }}fn main() {    let counter = Rc::new(());    let ccounter = counter.clone();    let result = std::panic::catch_unwind(move || {        let _ = (            S(ccounter.clone()),            S(ccounter.clone()),            S(ccounter.clone()),            S(ccounter)        ).clone();    });    assert!(result.is_err());    assert_eq!(        1,        Rc::strong_count(&counter)    );    let ccounter = counter.clone();    let child = std::panic::catch_unwind(move || {        let _ = [            S(ccounter.clone()),            S(ccounter.clone()),            S(ccounter.clone()),            S(ccounter)        ].clone();    });    assert!(child.is_err());    assert_eq!(        1,        Rc::strong_count(&counter)    );}",
        "instruction": "The code defines a `S` struct with a `Rc` reference counter inside. The `Clone` implementation checks the strong count and panics if it's 7. The `main` function demonstrates unwinding behavior by cloning tuples and arrays, ensuring resources are cleaned up correctly in case of panic."
    },
    {
        "output": "Defines a function that takes a generic type parameter that must implement the Copy trait and assigns the parameter to two variables",
        "input": "fn can_copy_copy<T:Copy>(v: T) { let _a = v; let _b = v; } pub fn main() {}",
        "instruction": "The function can_copy_copy demonstrates that types implementing the Copy trait can be implicitly copied. In this case, the generic type T must implement the Copy trait, allowing the function to assign the parameter v to two separate variables _a and _b."
    },
    {
        "output": "Creates a mutable reference to a box containing the value 4, then changes the value inside the box to 5.",
        "input": "fn foo(x: &mut Box<u8>) { *x = Box::new(5); } fn main() { foo(&mut Box::new(4)); }",
        "instruction": "Defines a function 'foo' that takes a mutable reference to a box of u8 and changes the value inside the box. In the 'main' function, it creates a box with the value 4, passes a mutable reference to it to 'foo', and changes the value inside the box to 5."
    },
    {
        "output": "Attempts to assign a new value to variable 'x' and read input into a buffer, triggering compile-time errors due to immutability",
        "input": "fn main() { let x = 1; let s = std::io::stdin(); }",
        "instruction": "Illustrates Rust's concept of immutability by trying to mutate 'x' and borrow 's' as mutable without declaring them as mutable, resulting in compile-time errors."
    },
    {
        "output": "Returns an error because capturing a dynamic environment in a function item is not allowed",
        "input": "fn main() { let bar: isize = 5; fn foo() -> isize { bar } }",
        "instruction": "This code attempts to define a function `foo` inside the `main` function that tries to access the variable `bar` from the outer scope, which is not allowed in Rust."
    },
    {
        "output": "The Rust code defines a function named 'worker' that is expected to never return a value (denoted by '!'). Inside this function, it panics using the 'panic!' macro, causing the program to terminate abruptly. The 'main' function then attempts to catch the panic by calling 'catch_unwind' from the 'std::panic' module and unwrapping the result. Since the 'worker' function panics, 'unwrap_err()' is called, which returns the caught panic value.",
        "input": "fn worker() -> ! { panic!(); } fn main() { std::panic::catch_unwind(worker).unwrap_err(); }",
        "instruction": "The code demonstrates the use of panics and panic handling in Rust. The 'worker' function panics intentionally, and the 'main' function catches this panic using 'catch_unwind' and handles the error by unwrapping it."
    },
    {
        "output": "Creates an enum `E` with a variant `A` and implements the `Drop` trait for it, which prints 'Drop' when the variant is dropped. Attempts to cast the enum variant `A` to an unsigned integer `u32`, triggering a compile-time error due to the `Drop` implementation.",
        "input": "#![deny(cenum_impl_drop_cast)]\nenum E {\n    A = 0,\n}\n\nimpl Drop for E {\n    fn drop(&mut self) {\n        println!(\"Drop\");\n    }\n}\n\nfn main() {\n    let e = E::A;\n    let i = e as u32;\n}",
        "instruction": "Defines an enum with a variant and demonstrates the effect of implementing the `Drop` trait on enum variants, showing that casting is not allowed for types that implement `Drop`."
    },
    {
        "output": "Prints 'hello, world' to the console",
        "input": "fn main() {\n    println!(\"hello, world\");\n}",
        "instruction": "Defines a main function that uses the println! macro to print 'hello, world' to the console."
    },
    {
        "output": "Validates equality assertions between char variables and character literals",
        "input": "fn main() { let c: char = 'x'; let d: char = 'x'; assert_eq!(c, 'x'); assert_eq!('x', c); assert_eq!(c, c); assert_eq!(c, d); assert_eq!(d, c); assert_eq!(d, 'x'); assert_eq!('x', d); }",
        "instruction": "Defines two char variables 'c' and 'd' with value 'x'. Compares them using assert_eq! macro to check equality with character literals and each other."
    },
    {
        "output": "Defines a Cat struct and implements methods for eating, meowing, and speaking. Creates a noisy Cat instance and calls the eat method on it.",
        "input": "trait Noisy {  fn speak(&mut self);}struct Cat {  meows: usize,  how_hungry: isize,  name: String,}impl Cat {  pub fn eat(&mut self) -> bool {    if self.how_hungry > 0 {        println!(\"OM NOM NOM\");        self.how_hungry -= 2;        return true;    }    else {        println!(\"Not hungry!\");        return false;    }  }}impl Noisy for Cat {  fn speak(&mut self) { self.meow(); }}impl Cat {  fn meow(&mut self) {    println!(\"Meow\");    self.meows += 1;    if self.meows % 5 == 0 {        self.how_hungry += 1;    }  }}fn cat(in_x: usize, in_y: isize, in_name: String) -> Cat {  Cat {    meows: in_x,    how_hungry: in_y,    name: in_name  }}fn main() {  let nyan: Box<dyn Noisy> = Box::new(cat(0, 2, \"nyan\".to_string())) as Box<dyn Noisy>;  nyan.speak();}",
        "instruction": "Defines a Cat struct with methods for eating, meowing, and speaking. Demonstrates trait implementation and dynamic dispatch by creating a noisy Cat instance and calling the speak method on it."
    },
    {
        "output": "Defines a trait `Animal` with a method `eat`, a struct `Cat` with a field `meows`, and implements the `Animal` trait for `Cat`. It defines a function `cat` that creates a `Cat` instance with the provided number of meows. The `main` function calls `cat(0)` to create a `Cat` instance named `nyan`.",
        "input": "trait Animal {    fn eat(&self);}struct Cat {    meows: usize,}impl Animal for Cat {}fn cat(in_x: usize) -> Cat {    Cat {        meows: in_x    } }fn main() {    let nyan = cat(0);}",
        "instruction": "Defines a trait, a struct, and a function in Rust. Demonstrates trait implementation and struct initialization in Rust."
    },
    {
        "output": "Prints 'flags 0, expected 0\\nflags 0, expected 1' to the console",
        "input": "static mut FLAGS: u64 = 0;struct Box<T> { f: T }struct AddFlags { bits: u64 }fn AddFlags(bits: u64) -> AddFlags { AddFlags { bits: bits }}fn arg(exp: u64, _x: &AddFlags) { check_flags(exp);}fn pass<T>(v: T) -> T { v}fn check_flags(exp: u64) { unsafe { let x = FLAGS; FLAGS = 0; println!(\"flags {}, expected {}\", x, exp); assert_eq!(x, exp); }}impl AddFlags { fn check_flags(&self, exp: u64) -> &AddFlags { check_flags(exp); self } fn bits(&self) -> u64 { self.bits }}impl Drop for AddFlags { fn drop(&mut self) { unsafe { FLAGS = FLAGS + self.bits; } }}pub fn main() { for x in &[AddFlags(1)] { check_flags(0); } check_flags(1); }",
        "instruction": "The code defines a struct AddFlags with a u64 field, implements methods for the struct, and a main function. It demonstrates the use of lifetimes, mutable static variables, unsafe code blocks, and the Drop trait in Rust."
    },
    {
        "output": "Demonstrates Rust borrow checker preventing pointers to temporaries with statement lifetimes from escaping",
        "input": "use std::ops::Drop;static mut FLAGS: u64 = 0;struct StackBox<T> { f: T }struct AddFlags { bits: u64 }fn AddFlags(bits: u64) -> AddFlags { AddFlags { bits: bits }}fn arg(x: &AddFlags) -> &AddFlags { x }impl AddFlags { fn get(&self) -> &AddFlags { self }}pub fn main() { let x1 = arg(&AddFlags(1)); let x2 = AddFlags(1).get(); let x3 = &*arg(&AddFlags(1)); let ref x4 = *arg(&AddFlags(1)); let &ref x5 = arg(&AddFlags(1)); let x6 = AddFlags(1).get(); let StackBox { f: x7 } = StackBox { f: AddFlags(1).get() }; (x1, x2, x3, x4, x5, x6, x7); }",
        "instruction": "Shows various scenarios where temporary values are borrowed and how the borrow checker prevents them from being used after the temporary values are dropped."
    },
    {
        "output": "Demonstrates the behavior of destructors for rvalue temporaries in Rust, showing when they run at the end of a statement or block.",
        "input": "fn main() {end_of_block!(_x, AddFlags(1));end_of_block!(_x, &AddFlags(1));end_of_block!(_x, & &AddFlags(1));end_of_block!(_x, Box { f: AddFlags(1) });end_of_block!(_x, Box { f: &AddFlags(1) });end_of_block!(_x, Box { f: &AddFlags(1) });end_of_block!(_x, pass(AddFlags(1)));end_of_block!(ref _x, AddFlags(1));end_of_block!(AddFlags { bits: ref _x }, AddFlags(1));end_of_block!(&AddFlags { bits }, &AddFlags(1));end_of_block!((_, ref _y), (AddFlags(1), 22));end_of_block!(box ref _x, std::boxed::Box::new(AddFlags(1)));end_of_block!(box _x, std::boxed::Box::new(AddFlags(1)));end_of_block!(_, { { check_flags(0); &AddFlags(1) } });end_of_block!(_, &((Box { f: AddFlags(1) }).f));end_of_block!(_, &(([AddFlags(1)])[0]));end_of_stmt!(_, AddFlags(1));end_of_stmt!((_, _), (AddFlags(1), 22));end_of_stmt!(ref _x, arg(0, &AddFlags(1)));end_of_stmt!(ref _x, AddFlags(1).check_flags(0).bits());end_of_stmt!(AddFlags { bits }, AddFlags(1));}",
        "instruction": "Illustrating Rust's temporary lifetime rules by using macros to create different scenarios where destructors of rvalue temporaries run either at the end of a statement or block."
    },
    {
        "output": "The Rust code creates a struct and an enum, where the enum variant contains a struct with a boxed integer field. It defines functions that panic intentionally. The 'fails' function creates a vector of boxed enums by calling 'do_it' with the output of 'get_bar'. The 'main' function spawns a thread that executes the 'fails' function.",
        "input": "fn main() {\n    use std::thread;\n\n    enum Conzabble {\n        Bickwick(Foo)\n    }\n    struct Foo {\n        field: Box<usize>\n    }\n    fn do_it(x: &[usize]) -> Foo {\n        panic!()\n    }\n    fn get_bar(x: usize) -> Vec<usize> {\n        vec![x * 2]\n    }\n    pub fn fails() {\n        let x = 2;\n        let mut y: Vec<Box<_>> = Vec::new();\n        y.push(Box::new(Conzabble::Bickwick(do_it(&get_bar(x))));\n    }\n    thread::spawn(fails).join();\n}",
        "instruction": "Defines structs, enums, functions that panic intentionally, and a 'fails' function that manipulates vectors of boxed enums. The 'main' function spawns a thread that executes 'fails'."
    },
    {
        "output": "Test that cleanups for the RHS of shortcircuiting operators work, raising a segfault if arguments include 'signal'",
        "input": "fn main() {\n    let args: Vec<String> = std::env::args().collect();\n    if args.len() >= 2 && args[1] == \"signal\" {\n        unsafe { *std::ptr::null_mut::<isize>() = 0; }\n    }\n}",
        "instruction": "The code collects command-line arguments into a vector and checks if the second argument is 'signal'. Demonstrates short-circuiting logic and unsafe Rust code for causing a segfault."
    },
    {
        "output": "Assigns the value 42 to variable x and then tries to reassign it to 43 which will cause a compilation error due to trying to mutate a variable defined as immutable.",
        "input": "fn main() { let mut x = 42; x = 43; }",
        "instruction": "Demonstrates the concept of mutability in Rust where variables can be defined as mutable using the 'mut' keyword allowing them to be reassigned new values."
    },
    {
        "output": "Prints the value of x, 'hello, world', and 10 to the console",
        "input": "//@ run-pass\n#![allow(unconditional_recursion)]\n#![allow(non_camel_case_types)]\n#![allow(dead_code)]\n#![allow(unused_mut)]\ntype t = isize;\nfn nothing() { }\nfn putstr(_s: String) { }\nfn putint(_i: isize) {\n    let mut i: isize = 33;\n    while i < 36 {\n        putstr(\"hi\".to_string());\n        i = i + 1;\n    }\n}\nfn zerg(i: isize) -> isize {\n    return i;\n}\nfn foo(x: isize) -> isize {\n    let mut y: t = x + 2;\n    putstr(\"hello\".to_string());\n    while y < 10 {\n        putint(y);\n        if y * 3 == 4 {\n            y = y + 2;\n            nothing();\n        }\n    }\n    let mut z: t;\n    z = 0x55;\n    foo(z);\n    return 0;\n}\npub fn main() {\n    let x: isize = 2 + 2;\n    println!(\"{}\", x);\n    println!(\"hello, world\");\n    println!(\"{}\", 10);\n}",
        "instruction": "Defines functions to print strings and integers, performs some arithmetic operations, loops, and function calls. The 'main' function initializes a variable, prints its value, as well as two other strings and an integer."
    },
    {
        "output": "Defines a function named 'will_ice' that takes a reference to a u32 and returns an iterator of references to u32 values. The function signature specifies that it returns a type that implements the Iterator trait. The code snippet contains an error related to the return type not matching the expected Iterator type.",
        "input": "fn will_ice(something: &u32) -> impl Iterator<Item = &u32> { } fn main() {}",
        "instruction": "The code demonstrates defining a function in Rust that should return an iterator over references to u32 values. The error message indicates a mismatch in the return type definition."
    },
    {
        "output": "Defines a struct `S` and an enum `E` with lifetime parameters, and creates instances of these types with references to u8 values",
        "input": "struct S<'a, 'b>(&'a u8, &'b u8);enum E<'a, 'b> { V(&'a u8), U(&'b u8), }fn main() { S(&0, &0); E::V(&0); }",
        "instruction": "This code demonstrates defining a struct and an enum with lifetime parameters in Rust. It then creates instances of these types using references to u8 values."
    },
    {
        "output": "Creates a struct Foo with a field i of type isize, implements the Drop trait for Foo, defines a function foo that takes an isize parameter and returns an instance of Foo, then in the main function, creates an instance of Foo using the foo function, attempts to clone the instance which results in a compilation error, and finally prints the debug representation of the original instance x.",
        "input": "#[derive(Debug)]\nstruct Foo {\n    i: isize,\n}\n\nimpl Drop for Foo {\n    fn drop(&mut self) {}\n}\n\nfn foo(i: isize) -> Foo {\n    Foo {\n        i: i\n    }\n}\n\nfn main() {\n    let x = foo(10);\n    let _y = x.clone();\n    //~^ ERROR no method named `clone` found\n    println!(\"{:?}\", x);\n}",
        "instruction": "Defines a struct Foo, implements the Drop trait for custom cleanup logic, creates a function to instantiate Foo instances, demonstrates an attempt to clone an instance resulting in a method not found error, and prints the debug representation of the original instance."
    },
    {
        "output": "Drops a value of type usize using the mem::drop function.",
        "input": "fn main() { use ::std::mem; mem::drop(2_usize); }",
        "instruction": "The code showcases the use of mem::drop function to explicitly drop a value of type usize. This function is used to release resources associated with the value before it goes out of scope."
    },
    {
        "output": "Defines a main function that uses functions from an external crate to manipulate data",
        "input": "fn main() {\n    use crate_method_reexport_grrrrrrr2::rust::add;\n    use crate_method_reexport_grrrrrrr2::rust::cx;\n    let x: Box<_> = Box::new(());\n    x.cx();\n    let y = ();\n    y.add(\"hi\".to_string());\n}",
        "instruction": "The code demonstrates importing and using functions from an external crate to call methods on objects, including using a function to add a string to a tuple."
    },
    {
        "output": "Defines a Rust program entry point function",
        "input": "fn main() {}",
        "instruction": "The 'main' function is the entry point of a Rust program where the execution starts."
    },
    {
        "output": "Defines a Rust program with a main function",
        "input": "fn main() {}",
        "instruction": "A basic Rust program structure with an empty main function."
    },
    {
        "output": "Defines a main function with no statements",
        "input": "fn main() {}",
        "instruction": "A basic Rust program with an empty main function."
    },
    {
        "output": "Defines a custom test framework in Rust that runs test cases with specific parameters",
        "input": "#![feature(custom_test_frameworks)]\n#![test_runner(crate::foo_runner)]\n#[cfg(test)]\nfn foo_runner(ts: &[&dyn Fn(usize)->()]) {\n    for (i, t) in ts.iter().enumerate() {\n        t(i);\n    }\n}\n\n#[test_case]\nfn test1(i: usize) {\n    println!(\"Hi #{}\", i);\n}\n\n#[test_case]\nfn test2(i: usize) {\n    println!(\"Hey #{}\", i);\n}",
        "instruction": "This Rust code snippet demonstrates defining a custom test framework that runs test cases with specific parameters. The `foo_runner` function takes an array of closures that accept a `usize` parameter and returns `()`. It iterates over the closures, passing the index `i` to each closure to run the test cases. Test cases `test1` and `test2` are defined to print messages using the `println!` macro with the index value."
    },
    {
        "output": "Defines a main function that declares a variable x and assigns an empty tuple to it",
        "input": "fn main() { let x = (); x }",
        "instruction": "The code snippet demonstrates defining a main function in Rust, declaring a variable x, assigning an empty tuple to it, and returning the value of x."
    },
    {
        "output": "Defines a struct named S and an empty main function",
        "input": "struct S; fn main() {}",
        "instruction": "The code defines a simple struct named S and an empty main function, demonstrating the basic structure of a Rust program."
    },
    {
        "output": "The function 'f' recursively calculates the sum of numbers from 1 to the input 'x' and returns the result. The 'main' function asserts that calling 'f' with the input 5000 results in 5000.",
        "input": "fn f(x: isize) -> isize { if x == 1 { return 1; } else { let y: isize = 1 + f(x - 1); return y; } } pub fn main() { assert_eq!(f(5000), 5000); }",
        "instruction": "The code demonstrates recursion in Rust by calculating the sum of numbers recursively and then asserts the result with the expected value of 5000."
    },
    {
        "output": "Defines a trait 'Foo' with a method 'm' that takes a reference to 'self' and an 'isize' parameter. The method has an empty body. Also, declares a 'main' function with an empty body.",
        "input": "trait Foo { fn m(&self, _:isize); } pub fn main() { }",
        "instruction": "Declares a trait with a method that takes a reference to 'self' and an 'isize' parameter. Additionally, a 'main' function is declared with no implementation."
    },
    {
        "output": "Prints 'Hello!' followed by 'Goodbye!' to the console",
        "input": "trait Foo {    fn f(&self) {        println!(\"Hello!\");        self.g();    }    fn g(&self);}struct A {    x: isize}impl Foo for A {    fn g(&self) {        println!(\"Goodbye!\");    }}pub fn main() {    let a = A { x: 1 };    a.f();}",
        "instruction": "Defines a trait with two methods, 'f' and 'g', implements the trait for struct 'A', and calls 'f' on an instance of 'A' which prints 'Hello!' followed by 'Goodbye!'."
    },
    {
        "output": "Defines various Rust structs, traits, and implementations with different type parameters and trait bounds",
        "input": "trait Trait<T> {}\nstruct Foo<U, V=i32>(U, V) where U: Trait<V>;\ntrait Marker {}\nstruct TwoParams<T, U>(T, U);\nimpl Marker for TwoParams<i32, i32> {}\nstruct IndividuallyBogus<T = i32, U = i32>(TwoParams<T, U>) where TwoParams<T, U>: Marker;\nstruct BogusTogether<T = u32, U = i32>(T, U) where TwoParams<T, U>: Marker;\nstruct NonDefaultedInClause<T, U = i32>(TwoParams<T, U>) where TwoParams<T, U>: Marker;\nstruct DefaultedLhs<U, V=i32>(U, V) where V: Trait<U>;\nstruct Dependent<T, U = T>(T, U) where U: Copy;\ntrait SelfBound<T: Copy=Self> {}\nstruct WellFormedProjection<A, T=<A as Iterator>::Item>(A, T);\ntrait Scope<'a> {}\nstruct Request<'a, S: Scope<'a> = i32>(S, &'a ());\nfn main() {}",
        "instruction": "Demonstrates defining Rust structs, traits, implementations, and trait bounds with various type parameters and constraints."
    },
    {
        "output": "Defines a main function with no code inside",
        "input": "fn main() { }",
        "instruction": "This Rust program defines a main function with no statements inside. In Rust, the entry point of the program is the main function. This snippet is a valid, but empty, Rust program."
    },
    {
        "output": "Panics with a message because a dereference operation on the integer 1 is attempted, which is not allowed",
        "input": "fn main() { match *1 { _ => { panic!(); } }}",
        "instruction": "Demonstrates a match expression in Rust where an attempt to dereference the integer 1 leads to a compilation error, triggering a panic due to an invalid operation."
    },
    {
        "output": "Creates a reference-counted smart pointer 'x' pointing to an array with elements 1, 2, 3, 4. Then, it asserts that the value pointed to by 'x' is equal to the array [1, 2, 3, 4].",
        "input": "fn main() {\n    use std::rc::Rc;\n    let x = Rc::new([1, 2, 3, 4]);\n    assert_eq!(*x, [1, 2, 3, 4]);\n}",
        "instruction": "The code demonstrates the usage of a reference-counted smart pointer 'Rc' to share ownership of the array. It asserts that the dereferenced value of 'x' is equal to the specified array."
    },
    {
        "output": "Creates a box containing an integer value of 10 and then dereferences the box to get the value and assign it to a variable",
        "input": "fn main() { let x: Box<isize> = Box::new(10); let _y: isize = *x; }",
        "instruction": "Defines a main function that demonstrates using a box to store an integer value and then dereferencing the box to access the value."
    },
    {
        "output": "Prints the value of the variable 'x' using the Debug trait, showing the variant 'Bar' with the associated u8 value",
        "input": "#[derive(Debug)]\nenum Void {}\n\n#[derive(Debug)]\nenum Foo {\n    Bar(#[allow(dead_code)] u8),\n    Void(Void),\n}\n\nfn main() {\n    let x = Foo::Bar(42);\n    println!(\"{:?}\", x);\n}",
        "instruction": "Defines two enums, 'Void' and 'Foo' with variants 'Bar' and 'Void'. 'Bar' takes an associated u8 value. The program creates a variable 'x' of type 'Foo' and initializes it with 'Bar(42)'. It then prints the value of 'x' using the Debug trait to display the variant and its associated value."
    },
    {
        "output": "Demonstrates trait reference destructuring in Rust and shows different scenarios of dereferencing and type mismatch errors",
        "input": "trait T { fn foo(&self) {} }impl T for isize {}fn main() { let &x = &(&1isize as &dyn T); let &x = &&(&1isize as &dyn T); let &&x = &&(&1isize as &dyn T); let &x = &1isize as &dyn T; let &&x = &(&1isize as &dyn T); let box x = Box::new(1isize) as Box<dyn T>; let &&x = &1isize as &dyn T; let &&&x = &(&1isize as &dyn T); let box box x = Box::new(1isize) as Box<dyn T>; }",
        "instruction": "The code showcases different scenarios of destructuring trait references, demonstrating cases of dereferencing, type mismatch errors, and trait objects in Rust."
    },
    {
        "output": "Prints the number 22 to the console",
        "input": "fn produce<T>() -> Result<&'static str, T> {    Ok(\"22\")}\n\nfn main() {    let x: usize = produce()        .and_then(|x| x.parse())        .unwrap_or_else(|_| panic!());    println!(\"{}\", x); }",
        "instruction": "Defines a function named produce that returns a static string '22'. In the main function, it calls produce, parses the returned string to a usize, and prints the parsed value to the console."
    },
    {
        "output": "Creates an Option containing a diverging expression",
        "input": "fn main() { let c = Some({ return; }); c.unwrap(); }",
        "instruction": "The code creates an Option containing a diverging expression using `Some({ return; })`. Diverging expression is a type that signifies that the function does not return normally. The `unwrap()` method is called on the Option to extract the value."
    },
    {
        "output": "Demonstrates using unsafe Rust code to force a panic and transmute a f64 into an array of 8 bytes",
        "input": "fn assert_sizeof() -> ! { unsafe { ::std::mem::transmute::<f64, [u8; 8]>(panic!()) }} fn main() { }",
        "instruction": "The code uses unsafe Rust to transmute a panic from a floating-point number (f64) into an array of 8 bytes. This showcases advanced Rust concepts like transmutation and panicking."
    },
    {
        "output": "Demonstrates different levels of reference nesting in Rust with type annotations",
        "input": "fn check_expr() {    let _: &usize = &1;    let _: &&usize = &&1;    let _: &&&usize = &&&1;    let _: &&&usize = & &&1;    let _: &&&&usize = &&&&1;    let _: &&&&usize = & &&&1;    let _: &&&&&usize = &&&&&1;}fn check_ty() {    let _: &usize = &1;    let _: &&usize = &&1;    let _: &&&usize = &&&1;    let _: & &&usize = &&&1;    let _: &&&&usize = &&&&1;    let _: & &&&usize = &&&&1;    let _: &&&&&usize = &&&&&1;}fn check_pat() {    let &_ = &1_usize;    let &&_ = &&1_usize;    let &&&_ = &&&1_usize;    let & &&_ = &&&1_usize;    let &&&&_ = &&&&1_usize;    let & &&&_ = &&&&1_usize;    let &&&&&_ = &&&&&1_usize;}pub fn main() {}",
        "instruction": "Illustrates the usage of different levels of reference nesting in Rust with type annotations, showcasing how to define and use references of varying depths."
    },
    {
        "output": "Defines a module 'foo' that contains a struct 'X' and re-exports it. The code also demonstrates the error of defining 'X' multiple times within the 'foo' module.",
        "input": "mod foo { pub use self::bar::X; use self::bar::X; mod bar { pub struct X; }} fn main() { let _ = foo::X; }",
        "instruction": "The code showcases module organization in Rust, re-exporting items, and the error that occurs when a name is defined multiple times within the same scope."
    },
    {
        "output": "Declares multiple modules based on the target operating system specified in the cfg attribute",
        "input": "mod hello {} mod hello {} mod hello {} mod hello {} mod hello {} mod hello {} fn main() {}",
        "instruction": "Demonstrates how to conditionally define modules in Rust based on the target operating system using cfg attribute."
    },
    {
        "output": "Prints '()' to the console",
        "input": "fn main() { fn test() { loop { let blah: Option<String>; if true { blah = Some(\"\".to_string()); } if let Some(blah) = blah.as_ref() { //~ ERROR E0381 } } } println!(\"{:?}\", test())}",
        "instruction": "The code defines a function 'test' that creates an Option<String> variable 'blah', assigns a value if true, and then tries to match on the reference of 'blah'. The main function calls 'test' and prints the result to the console."
    },
    {
        "output": "Defines a lang item for handling panics and enters an infinite loop when a panic occurs",
        "input": "#![feature(lang_items)]\nextern crate core;\nuse core::panic::PanicInfo;\n\n#[lang = \"panic_impl\"]\nfn panic_impl(info: &PanicInfo) -> ! {\n    loop {}\n}\n\nfn main() {}",
        "instruction": "This Rust code snippet defines a lang item 'panic_impl' for handling panics. When a panic occurs, the program enters an infinite loop."
    },
    {
        "output": "Defines a function wsucc that takes a generic type T and returns the result of adding the input value to itself",
        "input": "use std::ops::Add;fn wsucc<T:Add<Output=T> + Copy>(n: T) -> T { n + { return n } }",
        "instruction": "The function wsucc adds the input value to itself and returns the result, showcasing the use of generics and the Add trait in Rust."
    },
    {
        "output": "Creates instances of struct A and stores them in a vector of references to trait T objects",
        "input": "trait T {}struct A;impl T for A {}impl A {    fn new() -> Self {        Self {}    } }fn main() {    let (a, b, c) = (A::new(), A::new(), A::new());    let ts: Vec<&dyn T> = vec![&a, &b, &c];}",
        "instruction": "Defines a trait T, a struct A, and an implementation of T for A. The main function creates instances of A and stores references to them in a vector of trait objects. Demonstrates trait objects and struct instantiation."
    },
    {
        "output": "The code defines a Rust test function without a `main` function, which is required for Rust programs to run. This will cause a build failure due to the absence of the `main` function.",
        "input": "fn main() {}",
        "instruction": "In Rust, every executable program must have a `main` function as the entry point. Test functions are used for writing tests and should not replace the `main` function in an executable program."
    },
    {
        "output": "Checks multiple conditions using if-else statements and asserts the results",
        "input": "fn main() {\n    if 1 == 2 {\n        assert!(false);\n    } else if 2 == 3 {\n        assert!(false);\n    } else if 3 == 4 {\n        assert!(false);\n    } else {\n        assert!(true);\n    }\n    if 1 == 2 {\n        assert!(false);\n    } else if 2 == 2 {\n        assert!(true);\n    }\n    if 1 == 2 {\n        assert!(false);\n    } else if 2 == 2 {\n        if 1 == 1 {\n            assert!(true);\n        } else {\n            if 2 == 1 {\n                assert!(false);\n            } else {\n                assert!(false);\n            }\n        }\n    }\n    if 1 == 2 {\n        assert!(false);\n    } else {\n        if 1 == 2 {\n            assert!(false);\n        } else {\n            assert!(true);\n        }\n    }\n}",
        "instruction": "The code checks various conditions using if-else blocks and asserts the correctness of the conditions. Demonstrates the use of conditional statements and assertions in Rust."
    },
    {
        "output": "The code creates empty arrays and boxes them, then asserts that they are not None.",
        "input": "fn main() {\n    assert!(Some(Box::new(())).is_some());\n    let xs: Box<[()]> = Box::<[(); 0]>::new([]);\n    assert!(Some(xs).is_some());\n    struct Foo;\n    assert!(Some(Box::new(Foo)).is_some());\n    let ys: Box<[Foo]> = Box::<[Foo; 0]>::new([]);\n    assert!(Some(ys).is_some());\n}",
        "instruction": "The code demonstrates the creation of empty arrays and boxes in Rust, followed by assertions to check if they are not None."
    },
    {
        "output": "The code declares a variable 'x' of type unit '()' and tries to dereference a Box containing '()' value, assigning it to 'x'. This will cause a runtime panic as it is trying to dereference an empty Box.",
        "input": "fn main() { let x: () = *Box::new(()); }",
        "instruction": "The code demonstrates type annotation in Rust and attempts to dereference a Box, showcasing Rust's safety features by preventing invalid memory access."
    },
    {
        "output": "Defines empty struct, trait, and enum with empty type parameter list. Implements trait for struct. Defines functions, one with empty type parameter list. Uses the defined types and functions in main function.",
        "input": "//@ run-pass\nstruct S;\ntrait T {}\nenum E { V }\nimpl T for S {}\nimpl T for E {}\nfn foo() {}\nfn bar() {}\nfn main() {\n    let _ = S;\n    let _ = S;\n    let _ = E::V;\n    let _ = E::V;\n    foo();\n    foo();\n    bar();\n    let _: i32;\n}",
        "instruction": "Demonstrates defining and using types with empty type parameter lists, implementing trait, defining functions, and using them in Rust."
    },
    {
        "output": "Defines an enum 'Question' with variants 'Yes' and 'No', and a module 'foo' with a constant 'FOO' of type u32. The main function contains multiple compiler errors related to incorrect type operations and trait implementations.",
        "input": "enum Question {    Yes,    No,}mod foo {    const FOO: u32 = 0;}fn main() {    let x = \"a\";    y = 2;    x.z();    !Question::Yes;    foo::FOO;    0u32 as char;    let x = 0u8;    x as Vec<u8>;    let x = 5;    let x_is_nonzero = x as bool;    let x = &0u8;    let y: u32 = x as u32;    let v = core::ptr::null::<u8>();    v as *const [u8];}",
        "instruction": "The code demonstrates various type conversion errors and trait implementations that result in compiler errors. Each line containing an operation that leads to a specific error is highlighted."
    },
    {
        "output": "Defines a function check_bound that takes a generic type T and does nothing. It has a trait bound that requires the type T to implement the Copy trait. Then, in the main function, the check_bound function is called with a string argument, causing a compilation error because strings do not implement the Copy trait.",
        "input": "fn check_bound<T: Copy>(_: T) {}\n\nfn main() {\n    check_bound(\"nocopy\".to_string());\n    //~ ERROR : Copy` is not satisfied\n}",
        "instruction": "Demonstrates the use of trait bounds in Rust. The function check_bound expects its argument to implement the Copy trait, which string does not, hence the compilation error."
    },
    {
        "output": "Defines two structs, Foo and Bar, with the Drop trait implemented for both. The Drop trait provides a way to run some code when a value goes out of scope. The structs are annotated with #[derive(Copy, Clone)] but the Drop trait cannot be implemented for types that implement Copy, hence the errors.",
        "input": "struct Foo; struct Bar<T>(::std::marker::PhantomData<T>); impl Drop for Foo { fn drop(&mut self) {} } impl<T> Drop for Bar<T> { fn drop(&mut self) {} } fn main() {}",
        "instruction": "Demonstrates how Rust prevents implementing the Drop trait for types that also implement Copy, showing Rust's safety mechanisms in action."
    },
    {
        "output": "The code defines two functions, where one function tries to call the other function but fails due to a borrowing issue.",
        "input": "fn main() { \n    fn print_message(message: &str) { \n        println!(\"{}\", message); \n    } \n    let greeting = String::from(\"Hello, world!\"); \n    print_message(&greeting); \n    print_message(&greeting); \n }",
        "instruction": "The program attempts to print a message twice by borrowing the ownership of the 'greeting' string. This demonstrates Rust's borrowing rules and how they prevent multiple mutable borrows."
    },
    {
        "output": "Defines variables x and y with values 8 and 9, then calculates the sum of x and y. Defines variables q and r with values -8 and -9, then calculates the sum of q and r.",
        "input": "fn main() {\n    let x: isize = 8;\n    let y = 9;\n    x + y;\n    let q: isize = -8;\n    let r = -9;\n    q + r;\n}",
        "instruction": "Declares variables of type isize and calculates the sum of two sets of variables."
    },
    {
        "output": "The Rust code demonstrates the use of feature-gated attributes for stability control in a library",
        "input": "fn main() { let r = Record::new(); r.a_stable_pub; r.a_unstable_declared_pub; }",
        "instruction": "The code showcases accessing fields marked as stable and unstable declared in the Record struct."
    },
    {
        "output": "The code concatenates three string literals to create a static string 'helloworld' and asserts its equality with the predefined static string FOO",
        "input": "static FOO: &'static str = concat!(concat!(\"hel\", \"lo\"), \"world\");\npub fn main() {\n    assert_eq!(FOO, \"helloworld\");\n}",
        "instruction": "The code demonstrates the use of the `concat!` macro to concatenate multiple string literals and assigns the result to a static string. It then compares this static string with 'helloworld' using the `assert_eq!` macro to ensure they are equal."
    },
    {
        "output": "Defines a main function that calls a non-existent macro",
        "input": "fn main() { iamnotanextensionthatexists!(\"\"); }",
        "instruction": "This Rust code demonstrates defining a main function that tries to call a macro that does not exist."
    },
    {
        "output": "Prints the factorial of a number recursively",
        "input": "fn f(x: isize) -> isize {    println!(\"{}\", x);    if x == 1 {        return 1;    } else {        let y: isize = x * f(x - 1);        println!(\"{}\", y);        return y;    }}\n\nfn main() {    assert_eq!(f(5), 120); }",
        "instruction": "Defines a recursive function to calculate the factorial of a number in Rust and verifies the result in the main function using an assertion."
    },
    {
        "output": "Panics with a custom message",
        "input": "fn main() { panic!(\"no rules expected `@`\"); }",
        "instruction": "The code uses the panic! macro to immediately stop the program and print a custom error message when executed. The specified message is 'no rules expected `@`'. The @ symbol is used incorrectly within the panic message."
    },
    {
        "output": "Defines a public function named 'main'",
        "input": "fn main() {}",
        "instruction": "Creating the entry point of a Rust program"
    },
    {
        "output": "Creates formatted strings using the format! macro and checks equality with expected values",
        "input": "#![feature(lang_items, start)]\n#![no_std]\nextern crate std as other;\n#[macro_use] extern crate alloc;\nuse alloc::string::ToString;\n#[start]\nfn start(_argc: isize, _argv: *const *const u8) -> isize {\n    let s = format!(\"{}\", 1_isize);\n    assert_eq!(s, \"1\".to_string());\n    let s = format!(\"test\");\n    assert_eq!(s, \"test\".to_string());\n    let s = format!(\"{test}\", test=3_isize);\n    assert_eq!(s, \"3\".to_string());\n    let s = format!(\"hello {}\", \"world\");\n    assert_eq!(s, \"hello world\".to_string());\n    0\n}",
        "instruction": "The code demonstrates the use of the format! macro to create formatted strings with placeholders and named arguments. It then asserts the equality of the formatted strings with the expected values using assert_eq!."
    },
    {
        "output": "Defines a function 'f' that returns the integer 42. Then, assigns 'f' to a variable 'g' of type function pointer. 'g' is then called and assigned to variable 'i'. Finally, asserts that 'i' is equal to 42.",
        "input": "fn f() -> isize { return 42; }\n\nfn main() {\n    let g: fn() -> isize = f;\n    let i: isize = g();\n    assert_eq!(i, 42);\n}",
        "instruction": "Defines a function 'f' that returns a specific integer value, assigns the function to a function pointer, calls the function pointer, and asserts the returned value."
    },
    {
        "output": "Defines a trait `Tr` with a function `f` that takes a single unsigned 8-bit integer parameter.",
        "input": "trait Tr { fn f(u8); }",
        "instruction": "Declares a trait `Tr` with a function `f` that accepts an unsigned 8-bit integer parameter. The `u8` type represents an 8-bit unsigned integer in Rust."
    },
    {
        "output": "Defines a submodule `submodule` with an attribute `doc` that is set to `test(some_test)`.",
        "input": "mod submodule { #![doc(test(some_test))] }",
        "instruction": "Creates a submodule `submodule` with a `doc` attribute set to `test(some_test)`. Attributes in Rust provide additional information about items like functions, modules, or crates."
    },
    {
        "output": "The Rust code defines two functions 'f' with different return values (1 and 2) and a function 'g' that asserts the return values of 'f' and '::f'. It then calls function 'g' from the 'main' function.",
        "input": "fn f() -> isize { 1 } mod foo { pub fn f() -> isize { 2 } pub fn g() { assert_eq!(f(), 2); assert_eq!(::f(), 1); } } fn main() { foo::g(); }",
        "instruction": "The code demonstrates defining functions and modules in Rust, as well as using assertions to compare return values. The 'main' function calls the 'g' function from the 'foo' module."
    },
    {
        "output": "Prints 'hello' to the console",
        "input": "fn main() {\n    println!(\"hello\");\n}",
        "instruction": "The code defines a main function that uses the println! macro to output the string 'hello' to the console. This demonstrates the basic structure of a Rust program with a main function and a println! statement."
    },
    {
        "output": "Calls the drop method on an instance of the Foo struct",
        "input": "struct Foo; impl Drop for Foo { fn drop(&mut self) { } } fn main() { Drop::drop(&mut Foo); }",
        "instruction": "Defines a struct Foo and implements the Drop trait to define custom behavior when an instance of Foo goes out of scope. The main function explicitly calls the drop method on a mutable reference to an instance of Foo."
    },
    {
        "output": "Defines a struct `Foo` that can hold either `usize` or `isize` values and implements a method `bar` for each type that converts the value to `i32` with different signs based on the type.",
        "input": "struct Foo<T>(T); impl Foo<usize> { fn bar(&self) -> i32 { self.0 as i32 }} impl Foo<isize> { fn bar(&self) -> i32 { -(self.0 as i32) }} fn main() { let foo_u = Foo::<usize>(5); assert_eq!(foo_u.bar(), 5); let foo_i = Foo::<isize>(3); assert_eq!(foo_i.bar(), -3); }",
        "instruction": "Demonstrates defining a generic struct with type-specific implementations of a method, showcasing how Rust allows multiple methods with the same name but different behavior based on the type."
    },
    {
        "output": "Asserts that the method x() of the struct Point returns the value of the field x",
        "input": "mod foo {    pub struct Point {        pub x: i32,        #[allow(dead_code)]        pub y: i32,    }    impl Point {        fn x(&self) -> i32 { self.x }    } } fn main() {    assert_eq!((foo::Point { x: 1, y: 3 }).x(), 1); }",
        "instruction": "Defines a module 'foo' containing a struct 'Point' with fields x and y, implements a method x() for Point that returns the value of x, and asserts that calling x() on a Point instance with x: 1 returns 1."
    },
    {
        "output": "Creates an instance of a struct 'Fish' from an external crate and calls the 'swim' method on it.",
        "input": "fn main() {\n    let fish = impl_privacy_xc_1::Fish { x: 1 };\n    fish.swim();\n}",
        "instruction": "The code demonstrates importing a struct 'Fish' from an external crate 'impl_privacy_xc_1' and invoking its 'swim' method."
    },
    {
        "output": "Defines a trait and a struct in Rust with associated types and lifetime parameters. Demonstrates the error when lifetime parameters are not properly constrained in the associated type definition.",
        "input": "trait Fun {    type Output;    fn call<'x>(&'x self) -> Self::Output;}struct Holder { x: String }impl<'a> Fun for Holder {    type Output = &'a str;    fn call<'b>(&'b self) -> &'b str {        &self.x[..]    } }fn main() { }",
        "instruction": "The code defines a trait 'Fun' with an associated type 'Output' and a method 'call'. It then implements the trait for the struct 'Holder' with lifetime parameters. The error E0207 is demonstrated when lifetime parameters are not properly constrained in the associated type definition."
    },
    {
        "output": "Defines a Rust struct `MyType`, a generic struct `MyType1`, a trait `Bar` with an associated type `Out`, and multiple implementations for the structs with type parameter constraints.",
        "input": "struct MyType; struct MyType1<T>(T); trait Bar { type Out; } impl<T> MyType {} impl<T> MyType1<T> {} impl<T,U> MyType1<T> {} impl<T,U> MyType1<T> where T: Bar<Out=U> {} fn main() {}",
        "instruction": "Demonstrates defining structs, a trait with an associated type, and generic implementations with type parameter constraints in Rust."
    },
    {
        "output": "Defines a trait `Foo` with a generic method `get`",
        "input": "trait Foo<A> {    fn get(&self, a: &A); }",
        "instruction": "Defines a trait `Foo` with a generic method `get` that takes a reference to a value of type `A`."
    },
    {
        "output": "Creates a variable '_f' and assigns the absolute value of 10 to it",
        "input": "fn main() { let _f = 10i32.abs(); }",
        "instruction": "Demonstrates the usage of the 'abs()' method to obtain the absolute value of an integer in Rust."
    },
    {
        "output": "Defines an enum named 'Foo' with a variant 'Variant'",
        "input": "enum Foo { Variant, } fn main() {}",
        "instruction": "Shows how to define an enum with a single variant in Rust."
    },
    {
        "output": "Declares a main function that is marked for inlining optimization",
        "input": "fn main() {}",
        "instruction": "Defines a Rust program with a main function that is marked for inlining optimization using the #[inline(always)] attribute."
    },
    {
        "output": "Asserts that the method of struct Foo returns true",
        "input": "struct Foo;impl Foo {    #![cfg(FALSE)]    fn method(&self) -> bool { false }}impl Foo {    #![cfg(not(FALSE))]    // check that we don't eat attributes too eagerly.    #[cfg(FALSE)]    fn method(&self) -> bool { false }    fn method(&self) -> bool { true }}pub fn main() {    assert!(Foo.method());}",
        "instruction": "Defines a struct Foo with a method that returns true, demonstrating conditional compilation in Rust."
    },
    {
        "output": "Prints 'hello, modular world' to the console twice",
        "input": "mod inner {    pub mod inner2 {        pub fn hello() { println!(\"hello, modular world\"); }    }    pub fn hello() { inner2::hello(); }}pub fn main() { inner::hello(); inner::inner2::hello(); }",
        "instruction": "Defines a module named 'inner' containing a submodule 'inner2' with a function 'hello' that prints 'hello, modular world'. The 'main' function calls both 'hello' functions from 'inner' and 'inner2'."
    },
    {
        "output": "Defines an enum 'Bar' with a single variant 'What' and a generic type 'T'. Declares a function 'foo' that does nothing except creating a static variable 'a' of type 'Bar<T>'.",
        "input": "enum Bar<T> { What } fn foo<T>() { static a: Bar<T> = Bar::What; } fn main() {}",
        "instruction": "Demonstrates defining a generic enum and function in Rust. Shows how to use a generic type 'T' within a static variable declaration."
    },
    {
        "output": "Creates instances of structs A and B from the inner_static crate and calls the method bar on each instance to assert their values.",
        "input": "fn main() {\n    let a = inner_static::A::<()> { v: () };\n    let b = inner_static::B::<()> { v: () };\n    let c = inner_static::test::A::<()> { v: () };\n    assert_eq!(a.bar(), 2);\n    assert_eq!(b.bar(), 4);\n    assert_eq!(c.bar(), 6);\n}",
        "instruction": "Defines instances of structs from an external crate and calls a method on each instance to verify the expected output using assert_eq!."
    },
    {
        "output": "Creates a vector of integers and a string, then attempts to access specific elements of the vector and bytes of the string using different index types, resulting in compilation errors for invalid index types.",
        "input": "fn main() {\n    let v: Vec<isize> = vec![0, 1, 2, 3, 4, 5];\n    let s: String = \"abcdef\".to_string();\n    v[3_usize];\n    v[3];\n    v[3u8];\n    v[3i8];\n    v[3u32];\n    v[3i32];\n    s.as_bytes()[3_usize];\n    s.as_bytes()[3];\n    s.as_bytes()[3u8];\n    s.as_bytes()[3i8];\n    s.as_bytes()[3u32];\n    s.as_bytes()[3i32];\n}",
        "instruction": "Demonstrates attempting to index a vector and string bytes with different index types, showcasing Rust's strong typing and compiler errors for incompatible index types."
    },
    {
        "output": "Illustrates a type error in Rust due to assigning a floating-point number to a variable declared as an integer",
        "input": "fn main() {\n    let mut x = 2; \n    x = 5.0; \n}",
        "instruction": "The code defines a mutable variable 'x' with an initial value of 2, which is an integer. The subsequent assignment of 5.0, a floating-point number, to 'x' causes a type mismatch error as Rust is a statically typed language and does not allow implicit type conversion."
    },
    {
        "output": "Defines a Rust library function named 'my_lib_fn'",
        "input": "fn my_lib_fn() {}",
        "instruction": "Declares a Rust function named 'my_lib_fn'."
    },
    {
        "output": "Defines multiple Rust structs and implements trait for dynamic dispatching",
        "input": "#![feature(unsize, dispatch_from_dyn)]\nuse std::{\n    ops::DispatchFromDyn,\n    marker::{Unsize, PhantomData},\n};\n\nstruct WrapperWithExtraField<T>(T, i32);\nimpl<T, U> DispatchFromDyn<WrapperWithExtraField<U>> for WrapperWithExtraField<T>\nwhere\n    T: DispatchFromDyn<U>,\n{}\n\nstruct MultiplePointers<T: ?Sized>{\n    ptr1: *const T,\n    ptr2: *const T,\n}\nimpl<T: ?Sized, U: ?Sized> DispatchFromDyn<MultiplePointers<U>> for MultiplePointers<T>\nwhere\n    T: Unsize<U>,\n{}\n\nstruct NothingToCoerce<T: ?Sized> {\n    data: PhantomData<T>,\n}\nimpl<T: ?Sized, U: ?Sized> DispatchFromDyn<NothingToCoerce<T>> for NothingToCoerce<U> {}\n\n#[repr(C)]\nstruct HasReprC<T: ?Sized>(Box<T>);\nimpl<T: ?Sized, U: ?Sized> DispatchFromDyn<HasReprC<U>> for HasReprC<T>\nwhere\n    T: Unsize<U>,\n{}\n\n#[repr(align(64))]\nstruct OverAlignedZst;\nstruct OverAligned<T: ?Sized>(Box<T>, OverAlignedZst);\nimpl<T: ?Sized, U: ?Sized> DispatchFromDyn<OverAligned<U>> for OverAligned<T>\nwhere\n    T: Unsize<U>,\n{}\n\nfn main() {}",
        "instruction": "Defines Rust structs and implements the DispatchFromDyn trait for dynamic dispatching. Demonstrates trait bounds, generic types, and trait implementations in Rust."
    },
    {
        "output": "Encodes a struct into a JSON string or opaque binary data based on a wire protocol",
        "input": "//@ run-pass\n#![allow(unused_must_use)]\n#![allow(dead_code)]\n#![allow(unused_imports)]\nuse std::fmt;\nuse std::io::prelude::*;\nuse std::io::Cursor;\nuse std::slice;\nuse std::marker::PhantomData;\n\ntrait Encoder {\n    type Error;\n}\n\ntrait Encodable<S: Encoder> {\n    fn encode(&self, s: &mut S) -> Result<(), S::Error>;\n}\n\nstruct JsonEncoder<'a>(PhantomData<&'a mut ()>);\n\nimpl Encoder for JsonEncoder<'_> {\n    type Error = ();\n}\n\nstruct AsJson<'a, T> {\n    inner: &'a T,\n}\n\nimpl<'a, T: for<'r> Encodable<JsonEncoder<'r>>> fmt::Display for AsJson<'a, T> {\n    /// Encodes a json value into a string\n    fn fmt(&self, _f: &mut fmt::Formatter<'_>) -> fmt::Result {\n        Ok(())\n    }\n}\n\nfn as_json<T>(t: &T) -> AsJson<'_, T> {\n    AsJson { inner: t }\n}\n\nstruct OpaqueEncoder(Vec<u8>);\n\nimpl Encoder for OpaqueEncoder {\n    type Error = ();\n}\n\nstruct Foo {\n    baz: bool,\n}\n\nimpl<S: Encoder> Encodable<S> for Foo {\n    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n        Ok(())\n    }\n}\n\nstruct Bar {\n    froboz: usize,\n}\n\nimpl<S: Encoder> Encodable<S> for Bar {\n    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n        Ok(())\n    }\n}\n\nenum WireProtocol {\n    JSON,\n    Opaque,\n    // ...\n}\n\nfn encode_json<T: for<'a> Encodable<JsonEncoder<'a>>>(val: &T, wr: &mut Cursor<Vec<u8>>) {\n    write!(wr, \"{}\", as_json(val));\n}\n\nfn encode_opaque<T: Encodable<OpaqueEncoder>>(val: &T, wr: Vec<u8>) {\n    let mut encoder = OpaqueEncoder(wr);\n    val.encode(&mut encoder);\n}\n\npub fn main() {\n    let target = Foo { baz: false };\n    let proto = WireProtocol::JSON;\n    match proto {\n        WireProtocol::JSON => encode_json(&target, &mut Cursor::new(Vec::new())),\n        WireProtocol::Opaque => encode_opaque(&target, Vec::new()),\n    }\n}",
        "instruction": "The code defines traits and structs to encode data into JSON string or binary format based on a wire protocol. It demonstrates trait implementation, generics, and encoding logic selection based on an enum variant."
    },
    {
        "output": "A Rust program that serves as a regression test for issue #13560. It imports two external crates and defines the main function without any implementation.",
        "input": "extern crate issue_13560_2 as t2;\nextern crate issue_13560_3 as t3;\nfn main() {}",
        "instruction": "The code imports two external crates, issue_13560_2 and issue_13560_3, and defines the main function without any specific implementation. This test is related to a specific issue #13560 for regression testing."
    },
    {
        "output": "Encodes an integer into a JSON string",
        "input": "//@ run-pass\n#![allow(unused_imports)]\n#![allow(unused_must_use)]\nuse std::fmt;\nuse std::marker::PhantomData;\n\ntrait Encoder {\n    type Error;\n}\n\ntrait Encodable<S: Encoder> {\n    fn encode(&self, s: &mut S) -> Result<(), S::Error>;\n}\n\nimpl<S: Encoder> Encodable<S> for i32 {\n    fn encode(&self, _s: &mut S) -> Result<(), S::Error> {\n        Ok(())\n    }\n}\n\nstruct JsonEncoder<'a>(PhantomData<&'a mut ()>);\n\nimpl Encoder for JsonEncoder<'_> {\n    type Error = ();\n}\n\nfn encode_json<T: for<'r> Encodable<JsonEncoder<'r>>>(\n    object: &T,\n) -> Result<String, ()> {\n    let s = String::new();\n    {\n        let mut encoder = JsonEncoder(PhantomData);\n        object.encode(&mut encoder)?;\n    }\n    Ok(s)\n}\n\nstruct Foo<T: for<'a> Encodable<JsonEncoder<'a>>> {\n    v: T,\n}\n\nimpl<T: for<'a> Encodable<JsonEncoder<'a>>> Drop for Foo<T> {\n    fn drop(&mut self) {\n        encode_json(&self.v);\n    }\n}\n\nfn main() {\n    let _ = Foo { v: 10 };\n}",
        "instruction": "Defines traits and structures to encode an integer into a JSON string using Rust generics and lifetimes. Demonstrates trait implementation, generic types, and ownership concepts in Rust."
    },
    {
        "output": "Creates a Rust application with a structure that increments a counter by 1 on update",
        "input": "extern crate issue_16822 as lib;use std::cell::RefCell;struct App {    i: isize}impl lib::Update for App {    fn update(&mut self) {        self.i += 1;    }}fn main(){    let app = App { i: 5 };    let window = lib::Window { data: RefCell::new(app) };    window.update();}",
        "instruction": "Defines a structure 'App' with a field 'i', implements the 'Update' trait for 'App' to increment 'i' by 1, creates an instance of 'App' with 'i' initialized to 5, creates a 'Window' with a mutable reference to 'app', and invokes the 'update' method on 'window' to increment the counter."
    },
    {
        "output": "Calls the function named 'baz' from the 'fmt' module in the 'issue_18502' crate",
        "input": "extern crate issue_18502 as fmt;fn main() { ::fmt::baz(); }",
        "instruction": "The code imports the 'fmt' module from the 'issue_18502' crate and calls the function 'baz' using the path '::fmt::baz()'."
    },
    {
        "output": "Invokes the function 'go' from the external crate 'issue_24106' with a generic type parameter",
        "input": "extern crate issue_24106;fn main() { issue_24106::go::<()>(); }",
        "instruction": "Imports an external crate and calls a function 'go' with a generic type parameter."
    },
    {
        "output": "Creates a new FatPtr struct with a length of 20, converts the pointer to a slice of u8, and then prints the slice in a debug format",
        "input": "extern crate issue_76387;\n\nuse issue_76387::FatPtr;\n\nfn print(data: &[u8]) {\n    println!(\"{:#?}\", data);\n}\n\nfn main() {\n    let ptr = FatPtr::new(20);\n    let data = unsafe { std::slice::from_raw_parts(ptr.as_ptr(), ptr.len()) };\n    print(data);\n}",
        "instruction": "The code demonstrates the creation of a FatPtr struct, conversion of its pointer to a slice, and printing the slice in debug format. It showcases the use of unsafe code to work directly with raw pointers in Rust."
    },
    {
        "output": "Defines a function `test_ref` that takes a reference to an unsigned 32-bit integer as input and returns a future that holds an unsigned 32-bit integer value",
        "input": "fn test_ref(x: &u32) -> impl std::future::Future<Output = u32> + '_ { *x } fn main() { let _ = test_ref(&0u32); }",
        "instruction": "The code demonstrates defining a function `test_ref` that takes a reference to a u32 value and returns a future holding a u32 value. In the `main` function, it calls `test_ref` with a reference to an unsigned 32-bit integer 0."
    },
    {
        "output": "Defines two modules, 'foo' and 'bar', each containing a function named 'baz'. Declares a 'main' function outside the modules.",
        "input": "mod foo { pub fn baz() {} } mod bar { pub fn baz() {} } pub fn main() {}",
        "instruction": "Demonstrates Rust module system with two modules 'foo' and 'bar', each having a function 'baz'. The 'main' function is declared outside the modules."
    },
    {
        "output": "Calls the function 'f' with a type 'isize' as a parameter",
        "input": "extern crate kinds_in_metadata;use kinds_in_metadata::f;pub fn main() { f::<isize>(); }",
        "instruction": "Imports an external crate 'kinds_in_metadata' and calls the function 'f' with the type 'isize' as a parameter in the main function."
    },
    {
        "output": "Defines multiple inherent impl blocks for primitive types and a struct",
        "input": "struct MyType; impl u8 { pub const B: u8 = 0; } impl str { fn foo() {} fn bar(self) {} } impl char { pub const B: u8 = 0; pub const C: u8 = 0; fn foo() {} fn bar(self) {} } struct MyType; impl &MyType { pub fn for_ref(self) {} } fn main() {}",
        "instruction": "This code snippet demonstrates defining multiple inherent impl blocks for primitive types like u8, str, and char, as well as for a custom struct MyType. Inherent impl blocks allow adding methods to existing types outside their original definition."
    },
    {
        "output": "Defines two functions lp and apply that take a String and a closure as arguments, apply the closure to the String, and return the result. The lp function loops forever, applying the closure and returning the result. The apply function calls the closure inside another function g and returns the result.",
        "input": "fn lp<T, F>(s: String, mut f: F) -> T where F: FnMut(String) -> T { while false { let r = f(s); return (r); } panic!(); } fn apply<T, F>(s: String, mut f: F) -> T where F: FnMut(String) -> T { fn g<T, F>(s: String, mut f: F) -> T where F: FnMut(String) -> T { f(s) } g(s, |v| { let r = f(v); r }) } pub fn main() {}",
        "instruction": "Defines two functions lp and apply that demonstrate passing closures as arguments and returning values after applying the closures. The lp function is an infinite loop that applies the closure to the input String, while the apply function calls the closure inside another function before returning the result."
    },
    {
        "output": "Defines a struct A with a field 'a' which is a Box containing an isize value. Defines a function foo that returns a Box containing a closure that always returns 22. In the main function, asserts that calling foo's closure returns 22.",
        "input": "struct A { a: Box<isize> } fn foo() -> Box<dyn FnMut() -> isize + 'static> { let k: Box<_> = Box::new(22); let _u = A {a: k.clone()}; let result = || 22; Box::new(result) } pub fn main() { assert_eq!(foo()(), 22); }",
        "instruction": "Defines a struct, a function returning a closure, and tests the closure's return value in the main function using the assert_eq macro."
    },
    {
        "output": "Prints the value 22 to the console",
        "input": "fn main() {\n    fn invoke<F>(f: F) where F: FnOnce() { f(); }\n    let k: Box<_> = 22.into();\n    let _u = A {a: k.clone()};\n    invoke(|| println!(\"{}\", k.clone()) )\n}",
        "instruction": "Defines a struct A with a field 'a' as a Box of isize. The main function creates a Box containing the value 22, assigns it to a field in an instance of A, and then invokes a closure that prints the value inside the Box."
    },
    {
        "output": "Prints the result of a logical OR operation along with the value of y after a mutable reference increment function call. Additionally, it performs assertions based on the logical conditions.",
        "input": "fn incr(x: &mut isize) -> bool { *x += 1; assert!(false); return false; }fn main() { let x = 1 == 2 || 3 == 3; assert!(x); let mut y: isize = 10; println!(\"{}\", x || incr(&mut y)); assert_eq!(y, 10); if true && x { assert!(true); } else { assert!(false); }}",
        "instruction": "Defines a mutable reference increment function, performs logical operations, prints the result, asserts conditions, and demonstrates logical AND/OR operations in Rust."
    },
    {
        "output": "Defines a struct T with a field i of type i32, a module Foo with a public function f, and a generic function g taking a type parameter Foo and calling the function f from the module Foo.",
        "input": "struct T { i: i32 }fn f<T>() { let t = T { i: 0 }; }mod Foo { pub fn f() {} }fn g<Foo>() { Foo::f(); }fn main() {}",
        "instruction": "Demonstrates defining a struct, a module with a function, a generic function, and calling a function from the module within the generic function."
    },
    {
        "output": "Demonstrates shadowing of type parameters and local variables in Rust",
        "input": "//@ run-pass\n#![allow(unused)]\nstruct Foo<X> { x: Box<X> }\nimpl<Bar> Foo<Bar> {\n    fn foo(&self) {\n        type Bar = i32;\n        let _: Bar = 42;\n    }\n}\n\nfn main() {\n    let f = 1;\n    {\n        fn f() {}\n        f();\n    }\n}",
        "instruction": "The code showcases how items in subscopes can shadow type parameters and local variables, which means redefining or hiding identifiers at inner scopes, such as redefining 'Bar' as a type inside the 'foo' function and having a separate 'f' function within the inner block."
    },
    {
        "output": "Prints 'knock knock 42 305419896' to the console after assigning a new value to 'frobulator'",
        "input": "//@ run-pass\n#![allow(static_mut_refs)]\n#![allow(non_upper_case_globals)]\n#[cfg(not(target_vendor = \"apple\"))]\n#[link_section = \".moretext\"]\nfn i_live_in_more_text() -> &'static str {\n    \"knock knock\"\n}\n\n#[cfg(not(target_vendor = \"apple\"))]\n#[link_section = \".imm\"]\nstatic magic: usize = 42;\n\n#[cfg(not(target_vendor = \"apple\"))]\n#[link_section = \".mut\"]\nstatic mut frobulator: usize = 0xdeadbeef;\n\n#[cfg(target_vendor = \"apple\")]\n#[link_section = \"__TEXT,__moretext\"]\nfn i_live_in_more_text() -> &'static str {\n    \"knock knock\"\n}\n\n#[cfg(target_vendor = \"apple\")]\n#[link_section = \"__RODATA,__imm\"]\nstatic magic: usize = 42;\n\n#[cfg(target_vendor = \"apple\")]\n#[link_section = \"__DATA,__mut\"]\nstatic mut frobulator: usize = 0xdeadbeef;\n\npub fn main() {\n    unsafe {\n        frobulator = 0x12345678;\n        println!(\"{} {} {}\", i_live_in_more_text(), magic, frobulator);\n    }\n}",
        "instruction": "The code defines static variables with different link sections based on the target vendor. It then assigns a new value to 'frobulator' and prints the values of 'i_live_in_more_text()', 'magic', and 'frobulator' to the console."
    },
    {
        "output": "Creates a linked list using the Rust enum feature",
        "input": "fn main() { enum list { cons(isize, Box<list>), nil, } list::cons(10, Box::new(list::cons(11, Box::new(list::cons(12, Box::new(list::nil)))))); }",
        "instruction": "Defines an enum 'list' with variants 'cons' holding an integer value and a boxed list and 'nil'. Constructs a linked list by chaining cons variants."
    },
    {
        "output": "Prints nothing to the console",
        "input": "fn main() { if false { println!(\"{}\", \"foobar\"); }}",
        "instruction": "The code contains an if statement with the condition set to false, so the println! macro inside the block will not be executed. Therefore, nothing will be printed to the console."
    },
    {
        "output": "The Rust code defines two enums 'foo' and 'bar' with different variants and implements the 'Debug' trait for them. It then asserts the string representations of enum variants using the 'format' macro and 'assert_eq' macro.",
        "input": "fn main() { assert_eq!(\"a(22)\".to_string(), format!(\"{:?}\", foo::a(22))); assert_eq!(\"c\".to_string(), format!(\"{:?}\", foo::c)); assert_eq!(\"d\".to_string(), format!(\"{:?}\", bar::d)); }",
        "instruction": "The code demonstrates how to format and compare the string representations of enum variants in Rust using the 'Debug' trait and assertion macros."
    },
    {
        "output": "Prints the debug representation of various values to the console",
        "input": "fn main() {    println!(\"{:?}\", 1);    println!(\"{:?}\", 2.0f64);    println!(\"{:?}\", Numbers::Three);    println!(\"{:?}\", vec![4]);}",
        "instruction": "The code demonstrates printing the debug representations of an integer, a float, an enum variant, and a vector containing an integer."
    },
    {
        "output": "Creates a struct Foo with a Cell field, implements Debug trait for Foo, and asserts and updates the value of the Cell field in a thread.",
        "input": "use std::cell::Cell;use std::fmt;use std::thread;struct Foo(Cell<isize>);impl fmt::Debug for Foo {    fn fmt(&self, _fmt: &mut fmt::Formatter) -> fmt::Result {        let Foo(ref f) = *self;        assert_eq!(f.get(), 0);        f.set(1);        Ok(())    }}pub fn main() {    thread::spawn(move || {        let mut f = Foo(Cell::new(0));        println!(\"{:?}\", f);        let Foo(ref mut f) = f;        assert_eq!(f.get(), 1);    })    .join()    .ok()    .unwrap();}",
        "instruction": "Defines a struct Foo with a Cell field, implements Debug trait to customize printing behavior, spawns a thread that modifies the Cell value and asserts the changes made in a concurrent context."
    },
    {
        "output": "Defines a Rust function named `main`.",
        "input": "fn main() {}",
        "instruction": "In Rust, the `main` function is the entry point of a program. This snippet defines an empty `main` function."
    },
    {
        "output": "Defines a trait 'Product' with a method 'product', a struct 'Foo' with fields 'x' and 'y', implements 'sum' method for 'Foo', and implements 'Product' trait for 'Foo'. Defines a function 'Foo' as a constructor for 'Foo' struct. In the 'main' function, creates an instance of 'Foo', prints the sum of 'x' and 'y' and the product of 'x' and 'y'.",
        "input": "trait Product {    fn product(&self) -> isize;}struct Foo {    x: isize,    y: isize,}impl Foo {    pub fn sum(&self) -> isize {        self.x + self.y    }}impl Product for Foo {    fn product(&self) -> isize {        self.x * self.y    }}fn Foo(x: isize, y: isize) -> Foo {    Foo { x: x, y: y }}pub fn main() {    let foo = Foo(3, 20);    println!(\"{} {}\", foo.sum(), foo.product());}",
        "instruction": "Defines a trait, a struct, methods for the struct, and a function as a constructor. Demonstrates implementing a trait for a struct and calling methods on the struct instance."
    },
    {
        "output": "Prints the value of y to the console",
        "input": "fn main() { let x = 1; let y = x + 1; println!(\"{}\", y); }",
        "instruction": "Defines a main function that calculates the value of y as x+1 and prints it using println! macro. Demonstrates variable declaration, addition, and printing in Rust."
    },
    {
        "output": "Defines trait objects with trait bounds that include the ?Sized marker trait",
        "input": "trait Tr: ?Sized {}\ntype A1 = dyn Tr;\ntype A2 = dyn for<'a> Tr;\nfn main() {}",
        "instruction": "The code defines a trait Tr with the ?Sized marker trait. It then creates trait objects A1 and A2 that have trait bounds including the ?Sized marker. This demonstrates trait object creation with trait bounds."
    },
    {
        "output": "Defines two functions 'bar' and 'foo' with different signatures",
        "input": "fn bar() {}\nfn foo(x: i32) -> u32 { 0 }\nfn main() { let b: fn() -> u32 = bar; let f: fn(i32) -> u32 = foo; }",
        "instruction": "The code defines two functions, 'bar' with no parameters and 'foo' with an i32 parameter that returns a u32. Demonstrates defining functions with different signatures in Rust."
    },
    {
        "output": "Attempts to apply a unary operator '-' to a string which is not allowed in Rust",
        "input": "fn main() { let _ = -(\"foo\".to_string()); }",
        "instruction": "The code tries to use the unary operator '-' on a string, but as strings cannot be negated, it results in a compilation error. It is corrected by assigning the result to an unused variable to avoid the error."
    },
    {
        "output": "Defines multiple Rust types and implements the `Debug` trait for some of them",
        "input": "use std::fmt;#[derive(Debug)]pub enum B {}pub enum C {}impl fmt::Debug for C { fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result { Ok(()) }}#[derive(Debug)]pub struct Bar;pub struct Baz;impl fmt::Debug for Baz { fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result { Ok(()) }}#[derive(Debug)]pub struct GenericType<T>(T);",
        "instruction": "The code defines enums, structs, and a generic type in Rust. It demonstrates implementing the `Debug` trait for specific types, which allows printing them for debugging purposes."
    },
    {
        "output": "The Rust code attempts to use a type parameter with the `FakeVariant` struct from the `Mod` module, but it is incorrectly applied to the module itself instead of the struct.",
        "input": "mod Mod { pub struct FakeVariant<T>(pub T); } fn main() { Mod::FakeVariant::<i32>(0); }",
        "instruction": "The `FakeVariant` struct in the `Mod` module is defined with a type parameter `T`, and the code tries to create an instance of this struct with type `i32`. Correct usage involves directly referencing the struct `FakeVariant` within the `Mod` module."
    },
    {
        "output": "Defines structs, instances, and a method to unwrap values of different types",
        "input": "#[derive(Copy, Clone)]\nstruct S<T> {\n    i: u8,\n    t: T\n}\n\nimpl<T> S<T> {\n    fn unwrap(self) -> T {\n        self.t\n    }\n}\n\n#[derive(Copy, Clone, PartialEq, Debug)]\nstruct A((u32, u32));\n\n#[derive(Copy, Clone, PartialEq, Debug)]\nstruct B(u64);\n\npub fn main() {\n    static Ca: S<A> = S { i: 0, t: A((13, 104)) };\n    static Cb: S<B> = S { i: 0, t: B(31337) };\n    assert_eq!(Ca.unwrap(), A((13, 104)));\n    assert_eq!(Cb.unwrap(), B(31337));\n}",
        "instruction": "Demonstrates generic struct `S`, method `unwrap`, and usage with structs A and B to unwrap values of different types."
    },
    {
        "output": "Prints the formatted message 'The answer is {FOO value} !' to the console",
        "input": "extern crate msvc_data_only_lib;\nfn main() {\n    println!(\"The answer is {} !\", msvc_data_only_lib::FOO);\n}",
        "instruction": "Imports an external crate 'msvc_data_only_lib' and accesses the constant 'FOO' from it to display a customized message using println macro."
    },
    {
        "output": "Defines two functions, 'foo' and 'bar', and a 'main' function that calls 'bar'. 'foo' takes two integers, adds them, and casts the result to a 64-bit integer. 'bar' creates a box with value 0, assigns a function pointer to 'foo' to 'y', and calls 'y' with arguments 1 and 2 using 'test::black_box'.",
        "input": "fn main() {\n    extern crate test;\n    fn foo(x: i32, y: i32) -> i64 {\n        (x + y) as i64\n    }\n    #[inline(never)]\n    fn bar() {\n        let _f = Box::new(0);\n        let y: fn(i32, i32) -> i64 = test::black_box(foo);\n        test::black_box(y(1, 2));\n    }\n    bar();\n}",
        "instruction": "Demonstrates defining functions, function pointers, and using test::black_box to prevent compiler optimizations. Calls 'bar' from 'main' to test function behavior."
    },
    {
        "output": "Prints '\ub9c8\uc774\ub108\uc2a4 \uc0ac\uc778\uc774 \uc5c6\uc73c\uba74' to the console",
        "input": "fn main() { println!(\"\ub9c8\uc774\ub108\uc2a4 \uc0ac\uc778\uc774 \uc5c6\uc73c\uba74\"); }",
        "instruction": "A simple Rust program that demonstrates printing a multibyte character string to the console."
    },
    {
        "output": "Defines a public function named 'main' with no body",
        "input": "fn main() { }",
        "instruction": "A minimal Rust program defining a public function named 'main' with no implementation."
    },
    {
        "output": "Defines a function 'f' that takes a mutable reference to a boxed isize, sets the value to 5, and asserts equality",
        "input": "fn f(mut y: Box<isize>) { *y = 5; assert_eq!(*y, 5); }\nfn g() { let frob = |mut q: Box<isize>| { *q = 2; assert_eq!(*q, 2); }; let w = Box::new(37); frob(w); }\npub fn main() { let z = Box::new(17); f(z); g(); }",
        "instruction": "The code demonstrates defining functions that manipulate boxed integers and use closures in Rust. The 'f' function sets the boxed integer to 5 and then asserts the value, while the 'g' function creates a closure that changes the boxed integer to 2 and asserts the new value. The 'main' function creates boxed integers and calls 'f' and 'g' functions."
    },
    {
        "output": "Defines multiple Rust enums representing different structures like colours, trees, lists, and small lists.",
        "input": "enum colour { red, green, blue, } enum tree { children(Box<list>), leaf(colour), } enum list { cons(Box<tree>, Box<list>), nil, } enum small_list { kons(isize, Box<small_list>), neel, } pub fn main() { }",
        "instruction": "The code showcases the definition of various enums in Rust, with nested structures like trees containing lists and small lists. Each enum represents different concepts or data structures."
    },
    {
        "output": "Creates a large number of closures using Rust macros and functions",
        "input": "macro_rules! go_bacterial {    ($mac:ident) => ($mac!());    ($mac:ident 1 $($t:tt)*) => (        go_bacterial!($mac $($t)*);        go_bacterial!($mac $($t)*);    )}macro_rules! mk_closure {    () => ((move || {})())}macro_rules! mk_fn {    () => {        {            fn function() {                go_bacterial!(mk_closure 1 1 1 1);            }            let _ = function();        }    }}fn main() {    go_bacterial!(mk_fn 1 1 1 1  1 1 1 1);}",
        "instruction": "The code showcases the use of Rust macros to generate a large number of closures through recursive expansion, demonstrating macro and closure usage in Rust."
    },
    {
        "output": "Defines a public function named 'main'",
        "input": "fn main() {}",
        "instruction": "This Rust code snippet defines a public function named 'main' with an empty body. In Rust, the 'main' function is the entry point of the program."
    },
    {
        "output": "Defines a function `f` that does nothing and calls it in the `main` function.",
        "input": "fn f() {}\n\nfn main() {\n    f();\n}",
        "instruction": "The code defines a function `f` that takes no arguments and has an empty body. This function `f` is then called within the `main` function. The error message indicates that the function `f` is not found in the scope."
    },
    {
        "output": "Defines a struct 'b' with a single field 'i' of type 'isize', implements a method 'do_stuff' on 'b' that returns 37, defines a function 'b' that takes an 'isize' argument and returns an instance of 'b', creates an instance 'z' of 'b' with 'i' value 42, asserts that 'z.i' is equal to 42 and 'z.do_stuff()' returns 37",
        "input": "fn main() {\n    struct b {\n        i: isize,\n    }\n    impl b {\n        fn do_stuff(&self) -> isize { return 37; }\n    }\n    fn b(i: isize) -> b {\n        b {\n            i: i\n        }\n    }\n    let z = b(42);\n    assert_eq!(z.i, 42);\n    assert_eq!(z.do_stuff(), 37);\n}",
        "instruction": "Defines a struct, implements a method on the struct, creates an instance, and asserts specific values on the instance in a basic Rust program."
    },
    {
        "output": "Defines a function named 'hd' that takes a vector 'v' of type 'U' and returns an element of type 'U'",
        "input": "fn hd<U>(v: Vec<U>) -> U {    fn hd1(w: [U]) -> U { return w[0]; }    return hd1(v); } fn main() {}",
        "instruction": "The code demonstrates defining a generic function 'hd' that takes a vector and returns the first element of the vector. It also includes an inner function 'hd1' that takes an array and returns its first element. The 'main' function is empty and serves as an entry point."
    },
    {
        "output": "Prints debug information about custom data structures to the console",
        "input": "use std::fmt;struct Thingy {    x: isize,    y: isize}impl fmt::Debug for Thingy {    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {        write!(f, \"{{ x: {:?}, y: {:?} }}\", self.x, self.y)    }}struct PolymorphicThingy<T> {    x: T}impl<T:fmt::Debug> fmt::Debug for PolymorphicThingy<T> {    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {        write!(f, \"{:?}\", self.x)    }}fn main() {    println!(\"{:?}\", Thingy { x: 1, y: 2 });    println!(\"{:?}\", PolymorphicThingy { x: Thingy { x: 1, y: 2 } });}",
        "instruction": "Defines custom data structures and implements the Debug trait for them to enable printing debug information using {:?} format specifier in Rust."
    },
    {
        "output": "Prints 'Hello world!' to the console",
        "input": "fn main() {\n    println!(\"Hello world!\");\n}",
        "instruction": "Defines a main function that prints 'Hello world!' to the console using println! macro."
    },
    {
        "output": "Prints the value of the constant 'FOO' to the console",
        "input": "fn main() { let FOO: isize = 3; println!(\"{}\", FOO); }",
        "instruction": "Defines a constant 'FOO' with the value 3 and then prints its value using 'println!' macro."
    },
    {
        "output": "Defines a main function that performs multiple string comparisons using Unicode escape sequences and asserts their equality",
        "input": "fn main() { let s = \"\u2603\"; assert_eq!(s, \"\u2603\"); let s = \"\u2a10\u2a01\u2aa0\"; assert_eq!(s, \"\u2a10\u2a01\u2aa0\"); let s = \"\\{20}\"; let mut correct_s = String::from(\"\\\\\"); correct_s.push_str(\"{20}\"); assert_eq!(s, correct_s); }",
        "instruction": "The code initializes various strings with Unicode escape sequences and compares them, demonstrating Unicode support in Rust and how to manipulate strings."
    },
    {
        "output": "Defines two functions, f and g, that take closures as arguments and call them with specified input. Then, asserts that the output of f with closure |a| a and input 10 is equal to 10, and calls g with an empty closure. Finally, repeats the assertion and call with a different closure.",
        "input": "fn f<F>(i: isize, f: F) -> isize where F: FnOnce(isize) -> isize { f(i) }fn g<G>(_g: G) where G: FnOnce() { }fn main() { assert_eq!(f(10, |a| a), 10); g(||()); assert_eq!(f(10, |a| a), 10); g(||{}); }",
        "instruction": "Defines functions that take closures as arguments, demonstrating the usage of closures and the FnOnce trait. Asserts equality of function outputs and calls functions with closures."
    },
    {
        "output": "Defines a custom generic struct 'myvec' that wraps a Vec and implements dereferencing and element retrieval functions. Creates an instance of 'myvec' containing integers, clones it, dereferences the clone, and performs assertions on the elements.",
        "input": "//@ run-pass\n#![allow(non_camel_case_types)]\n#[derive(Clone)]\nstruct myvec<X>(Vec<X>);\n\nfn myvec_deref<X:Clone>(mv: myvec<X>) -> Vec<X> {\n    let myvec(v) = mv;\n    return v.clone();\n}\n\nfn myvec_elt<X>(mv: myvec<X>) -> X {\n    let myvec(v) = mv;\n    return v.into_iter().next().unwrap();\n}\n\npub fn main() {\n    let mv = myvec(vec![1, 2, 3]);\n    let mv_clone = mv.clone();\n    let mv_clone = myvec_deref(mv_clone);\n    assert_eq!(mv_clone[1], 2);\n    assert_eq!(myvec_elt(mv.clone()), 1);\n    let myvec(v) = mv;\n    assert_eq!(v[2], 3);\n}",
        "instruction": "Defines a custom struct 'myvec', implements functions to dereference and retrieve elements. Demonstrates cloning, dereferencing, and element retrieval operations in Rust."
    },
    {
        "output": "Defines custom structs and a function to compute a value",
        "input": "#[derive(Copy, Clone)]\nstruct mytype(Mytype);\n\n#[derive(Copy, Clone)]\nstruct Mytype {\n    compute: fn(mytype) -> isize,\n    val: isize,\n}\n\nfn compute(i: mytype) -> isize {\n    let mytype(m) = i;\n    return m.val + 20;\n}\n\npub fn main() {\n    let myval = mytype(Mytype{compute: compute, val: 30});\n    println!(\"{}\", compute(myval));\n    let mytype(m) = myval;\n    assert_eq!((m.compute)(myval), 50);\n}",
        "instruction": "Defines two structs 'mytype' and 'Mytype', a compute function to add 20 to 'val' field of 'Mytype'. Demonstrates struct initialization and function usage in Rust."
    },
    {
        "output": "Creates a vector, wraps it in an Arc (atomic reference counting) smart pointer, spawns a new thread that accesses the vector's element at index 3, asserts its value, and then the main thread accesses the element at index 2 and prints the vector.",
        "input": "use std::sync::Arc;use std::thread;fn main() {    let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10];    let arc_v = Arc::new(v);    thread::spawn(move|| {        assert_eq!((*arc_v)[3], 4);    });    assert_eq!((*arc_v)[2], 3);    println!(\"{:?}\", *arc_v);}",
        "instruction": "Demonstrates the usage of Arc to share ownership of data across threads, showcasing how Arc allows multiple threads to access the same data concurrently while ensuring memory safety."
    },
    {
        "output": "Creates an Option enum with a value 'foo' and immediately unwraps it",
        "input": "fn main() {\n    let a = std::option::Option::Some(\"foo\");\n    a.unwrap();\n}",
        "instruction": "The code demonstrates creating an Option enum with a value 'foo' and then unwrapping it which will panic if the Option is None."
    },
    {
        "output": "The Rust code defines two functions, 'foo' and 'bar', but only 'foo' is called in the 'main' function. 'foo' contains a for loop iterating over a reference to a tuple, executing the loop body once. 'bar' returns an 'Option' type with the 'None' variant but uses the '?' operator incorrectly.",
        "input": "fn foo() {\n    for _ in &[()] {}\n}\n\nfn bar() -> Option<()> {\n    None?\n}\n\nfn main() {\n    foo();\n}",
        "instruction": "The 'foo' function demonstrates iterating over a reference to a tuple in a for loop. The 'bar' function incorrectly uses the '?' operator with 'None' without wrapping it in a 'Some' variant, causing a compilation error."
    },
    {
        "output": "Defines the main function",
        "input": "fn main() {}",
        "instruction": "A basic Rust program that defines the main function."
    },
    {
        "output": "Creates a vector and an Arc (atomic reference counted pointer) to share the vector between threads. Spawns a new thread that accesses the 4th element of the vector. The main thread accesses the 3rd element of the vector and prints the contents of the vector at the end.",
        "input": "use std::sync::Arc; use std::thread; fn main() { let v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10]; let arc_v = Arc::new(v); thread::spawn(move || { assert_eq!((*arc_v)[3], 4); }); assert_eq!((*arc_v)[2], 3); println!(\"{:?}\", *arc_v); }",
        "instruction": "Demonstrates multi-threading in Rust using Arc to share ownership between threads. Shows concurrent read access to the shared data and how ownership transfer works in Rust."
    },
    {
        "output": "Creates a struct `Foo` containing a field `_x` of type `Port<()>`. Defines a function `foo` that takes a `Port<()>` and returns an instance of `Foo`. In the `main` function, it creates an instance of `Foo` using `foo` and tries to spawn a thread that captures `x`, causing a compilation error due to `Rc<()>` not being thread-safe.",
        "input": "use std::thread;use std::rc::Rc;#[derive(Debug)]struct Port<T>(Rc<T>);fn main() {    #[derive(Debug)]    struct Foo {      _x: Port<()>,    }    impl Drop for Foo {        fn drop(&mut self) {}    }    fn foo(x: Port<()>) -> Foo {        Foo {            _x: x        }    }    let x = foo(Port(Rc::new(())));    thread::spawn(move|| {        let y = x;        println!(\"{:?}\", y);    });}",
        "instruction": "Defines a struct, a function, and demonstrates thread-unsafe usage of `Rc` in Rust. Shows an error due to attempting to send a non-thread-safe type between threads."
    },
    {
        "output": "Defines a struct `Foo` with a field of type `String` and implements the `Drop` trait for it. The `inline` function creates an instance of `Foo` and replaces the content of its field. The `outline` function creates another instance of `Foo`, assigns a string to its field, and then replaces the content of the field.",
        "input": "struct Foo(String);\n\nimpl Drop for Foo {\n    fn drop(&mut self) {}\n}\n\nfn inline() {\n    let _s = ();\n    let mut f = Foo(String::from(\"foo\"));\n    f.0 = String::from(\"bar\");\n}\n\nfn outline() {\n    let _s = String::from(\"foo\");\n    let mut f = Foo(_s);\n    f.0 = String::from(\"bar\");\n}\n\nfn main() {\n    inline();\n    outline();\n}",
        "instruction": "Defines a struct, implements the Drop trait for it, and showcases field replacement within instances of the struct."
    },
    {
        "output": "The Rust code is a simple main function with a return statement.",
        "input": "fn main() { return; }",
        "instruction": "A basic Rust program with a main function that only contains a return statement. The return statement exits the main function."
    },
    {
        "output": "Defines a Rust program that demonstrates the usage of the `Send` trait and negative impl for `Send`. It creates a struct `NoSend` and an enum `Foo` containing an instance of `NoSend`. The `bar` function is defined to take a parameter that must implement `Send`. In the `main` function, it attempts to call `bar` with an instance of `Foo` containing `NoSend`, resulting in a compile-time error due to `NoSend` not being `Send`.",
        "input": "#![feature(negative_impls)]\nuse std::marker::Send;\nstruct NoSend;\nimpl !Send for NoSend {}\nenum Foo {\n    A(NoSend)\n}\nfn bar<T: Send>(_: T) {}\nfn main() {\n    let x = Foo::A(NoSend);\n    bar(x);\n}",
        "instruction": "Demonstrates how Rust handles the `Send` trait and negative implementations. Shows that `NoSend` cannot be sent between threads safely, leading to a compile-time error."
    },
    {
        "output": "Creates an Rc (Reference Counted) smart pointer holding the integer 5 and passes it to the function bar, which accepts any type T that implements Send trait. The code triggers an error because Rc is not marked as Send, indicating it cannot be sent between threads safely.",
        "input": "use std::rc::Rc;fn bar<T: Send>(_: T) {}fn main() {    let x = Rc::new(5);    bar(x);    //~^ ERROR `Rc<{integer}>` cannot be sent between threads safely}",
        "instruction": "Demonstrates the Send trait in Rust, showing that Rc smart pointers are not thread-safe by default and trigger a compile-time error when attempted to be sent between threads."
    },
    {
        "output": "Defines a struct `NoSync`, an enum `Foo` with variant `A` containing a `NoSync` instance, and a function `bar` that takes a generic parameter constrained to implement the `Sync` trait. In the `main` function, it creates an instance of `Foo::A` with a `NoSync` object and calls `bar` with it, causing a compile-time error due to `NoSync` not implementing `Sync` trait.",
        "input": "#![feature(negative_impls)]\nuse std::marker::Sync;\nstruct NoSync;\nimpl !Sync for NoSync {}\nenum Foo { A(NoSync) }\nfn bar<T: Sync>(_: T) {}\nfn main() {\n    let x = Foo::A(NoSync);\n    bar(x);\n}",
        "instruction": "Demonstrates negative trait implementations in Rust by explicitly marking `NoSync` as not implementing the `Sync` trait. Shows how Rust prevents sharing `NoSync` between threads safely."
    },
    {
        "output": "Defines a struct `Foo` with a field `a` of type `isize` and implements the `!Sync` trait for `Foo`. It then defines a function `bar` that takes a generic type `T` which must implement the `Sync` trait. In the `main` function, it creates an instance `x` of `Foo` and calls the `bar` function with `x`, triggering an error due to `Foo` not being thread-safe.",
        "input": "#![feature(negative_impls)]\nuse std::marker::Sync;\n\nstruct Foo {\n    a: isize\n}\n\nimpl !Sync for Foo {}\n\nfn bar<T: Sync>(_: T) {}\n\nfn main() {\n    let x = Foo { a: 5 };\n    bar(x);\n}",
        "instruction": "Demonstrates the use of negative trait bounds by implementing the `!Sync` trait for a struct. Shows how Rust prevents sharing instances of `Foo` between threads due to lack of thread safety."
    },
    {
        "output": "Calls the function foo from the external crate noexporttypelib and assigns the returned value to variable x, causing a type mismatch error",
        "input": "extern crate noexporttypelib;fn main() { let x: isize = noexporttypelib::foo(); }",
        "instruction": "This code demonstrates calling a function from an external crate and handling a type mismatch error when assigning the return value to a variable of a different type."
    },
    {
        "output": "Defines a function `bar` that attempts to create an array of zeros with a size specified by a non-constant variable `n`, causing a compilation error due to using a non-constant value in a constant.",
        "input": "fn main() {\n    fn bar(n: usize) {\n        let _x = [0; n];\n        //~^ ERROR attempt to use a non-constant value in a constant [E0435]\n    }\n}",
        "instruction": "The code demonstrates an error caused by using a non-constant value to define the size of an array in Rust, which is not allowed for array initialization."
    },
    {
        "output": "Attempts to clone a value from a raw pointer to c_void, resulting in a compilation error due to the lack of a 'clone' method for c_void type",
        "input": "fn main() {    let x: *const Vec<isize> = &vec![1, 2, 3];    let y: *const c_void = x as *const c_void;    unsafe {        let _z = (*y).clone();        //~^ ERROR no method named `clone` found    }}",
        "instruction": "The code tries to clone the value pointed to by a raw pointer of type c_void, but the compilation fails because c_void does not have a 'clone' method. This demonstrates the limitations when working with raw pointers and unsafe code in Rust."
    },
    {
        "output": "The Rust code demonstrates various scenarios of panic messages that do not follow the required format, causing compiler warnings.",
        "input": "fn main() {\n    panic!(\"here's a brace: {\");\n    unreachable!(\"here's a brace: {\");\n    std::panic!(\"another one: }\");\n    core::panic!(\"Hello {}\");\n    assert!(false, \"{:03x} {test} bla\");\n    assert!(false, S);\n    assert!(false, 123);\n    assert!(false, Some(123));\n    debug_assert!(false, \"{{}} bla\");\n    panic!(C);\n    panic!(S);\n    unreachable!(S);\n    std::panic!(123);\n    core::panic!(&*\"abc\");\n    panic!(Some(123));\n    panic!(concat!(\"{\", \"}\"));\n    panic!(concat!(\"{\", \"{\"));\n    fancy_panic::fancy_panic!(\"test {} 123\");\n    fancy_panic::fancy_panic!();\n    fancy_panic::fancy_panic!(S);\n    macro_rules! a {\n        () => { 123 };\n    }\n    panic!(a!());\n    unreachable!(a!());\n    panic!(format!(\"{}\", 1));\n    unreachable!(format!(\"{}\", 1));\n    assert!(false, format!(\"{}\", 1));\n    debug_assert!(false, format!(\"{}\", 1));\n    panic![123];\n    panic!{123};\n    macro_rules! panic {\n        ($e:expr) => ();\n    }\n    panic!(\"{}\");\n    panic!(S);\n    a(1);\n    b(1);\n    c(1);\n    d(1);\n}\n\nfn a<T: Send + 'static>(v: T) {\n    panic!(v);\n    assert!(false, v);\n}\n\nfn b<T: std::fmt::Debug + Send + 'static>(v: T) {\n    panic!(v);\n    assert!(false, v);\n}\n\nfn c<T: std::fmt::Display + Send + 'static>(v: T) {\n    panic!(v);\n    assert!(false, v);\n}\n\nfn d<T: std::fmt::Display + std::fmt::Debug + Send + 'static>(v: T) {\n    panic!(v);\n    assert!(false, v);\n}",
        "instruction": "The code contains multiple instances of panic messages that violate the required format, leading to compiler warnings. The code aims to show how incorrect panic messages can trigger warnings during compilation. The snippets demonstrate cases where panic messages are not string literals or contain unused formatting placeholders, braces, or incorrect formatting functions."
    },
    {
        "output": "Defines two structs Bar and Foo with associated functions bar and foo to create instances of these structs respectively. Demonstrates that a class with a non-copyable field cannot be copied and throws an error when attempting to clone it.",
        "input": "#[derive(Debug)]\nstruct Bar {\n    x: isize,\n}\n\nimpl Drop for Bar {\n    fn drop(&mut self) {}\n}\n\nfn bar(x: isize) -> Bar {\n    Bar { x: x }\n}\n\n#[derive(Debug)]\nstruct Foo {\n    i: isize,\n    j: Bar,\n}\n\nfn foo(i: isize) -> Foo {\n    Foo { i: i, j: bar(5) }\n}\n\nfn main() {\n    let x = foo(10);\n    let _y = x.clone(); //~ ERROR no method named `clone` found\n    println!(\"{:?}\", x);\n}",
        "instruction": "Defines two structs and associated functions to create instances. Shows that a non-copyable field in a struct prevents the struct itself from being copied. Demonstrates the error thrown when attempting to clone a struct with a non-copyable field."
    },
    {
        "output": "Prints '1' to the console",
        "input": "#[derive(Debug)]\nstruct Foo {\n    x: isize\n}\n\nimpl From<Foo> for isize {\n    fn from(val: Foo) -> isize {\n        val.x\n    }\n}\n\nfn main() {\n    println!(\"{}\", isize::from(Foo { x: 1 }));\n}",
        "instruction": "Defines a struct `Foo` with a field `x`, implements `From` trait to convert `Foo` to `isize`, and prints the converted value of `Foo { x: 1 }`."
    },
    {
        "output": "Error indicating that the trait bound `S: Clone` is not satisfied when trying to clone a closure that captures a non-cloneable value",
        "input": "struct S(i32);\nfn main() {\n    let a = S(5);\n    let hello = move || {\n        println!(\"Hello {}\", a.0);\n    };\n    let hello = hello.clone();\n}",
        "instruction": "The code defines a struct `S` and a closure `hello` capturing a non-cloneable value `a`. The error occurs when trying to clone the closure, highlighting that closures do not implement `Clone` if their captured environment is not `Clone`."
    },
    {
        "output": "Creates a closure that increments a variable 'a' when called",
        "input": "fn main() {    let mut a = 5;    let hello = || {        a += 1;    };    let b = hello;    let c = hello; }",
        "instruction": "Defines a closure 'hello' that captures and mutates the variable 'a'. Demonstrates closure behavior in Rust."
    },
    {
        "output": "Defines two functions, foo and bar, with different numbers of parameters and panics when called. Demonstrates error messages showing the mismatched number of arguments.",
        "input": "fn foo(a: isize, b: isize, c: isize, d: isize) { panic!(); } fn bar(a: i32, b: i32, c: i32, d: i32, e: i32, f: i32) { println!(\"{}\", a); println!(\"{}\", b); println!(\"{}\", c); println!(\"{}\", d); println!(\"{}\", e); println!(\"{}\", f); } fn main() { foo(1, 2, 3, 4); bar(1, 2, 3, 4, 5, 6); }",
        "instruction": "Code defines two functions with different numbers of parameters and showcases error messages indicating the argument count mismatch when calling these functions."
    },
    {
        "output": "Checks various ways of representing NUL characters in Rust strings and tests their equality and length",
        "input": "fn main() { let all_nuls1 = \"\\0\\x00\\u{0}\\u{0}\"; let all_nuls2 = \"\\u{0}\\u{0}\\x00\\0\"; let all_nuls3 = \"\\u{0}\\u{0}\\x00\\0\"; let all_nuls4 = \"\\x00\\u{0}\\0\\u{0}\"; assert_eq!(all_nuls1.len(), 4); assert_eq!(all_nuls2.len(), 4); assert_eq!(all_nuls1, all_nuls2); assert_eq!(all_nuls2, all_nuls3); assert_eq!(all_nuls3, all_nuls4); for c1 in all_nuls1.chars() { for c2 in all_nuls1.chars() { assert_eq!(c1, c2); } } assert_eq!('\\u{0}', '\\x00'); assert_eq!('\\u{0}', '\\u{0}'); assert!(\"Hello World\" != \"Hello \\0World\"); assert!(\"Hello World\" != \"Hello World\\0\"); }",
        "instruction": "Illustrates different representations of NUL characters in Rust strings, checks their equality, length, and compares them to character literals to understand their differences."
    },
    {
        "output": "The Rust code defines an enum E with two variants: Thing and Nothing. It implements two methods is_none and get_ref. The code also contains macros check_option, check_fancy, and check_type for checking different types of values.",
        "input": "enum E<T> { Thing(isize, T), #[allow(dead_code)] Nothing((), ((), ()), [i8; 0]) }\n\nimpl<T> E<T> { \n    fn is_none(&self) -> bool { \n        match *self { \n            E::Thing(..) => false, \n            E::Nothing(..) => true \n        } \n    } \n    fn get_ref(&self) -> (isize, &T) { \n        match *self { \n            E::Nothing(..) => panic!(\"E::get_ref(Nothing::<{}>)\", stringify!(T)), \n            E::Thing(x, ref y) => (x, y) \n        } \n    } \n}\n\nmacro_rules! check_option { \n    ($e:expr, $T:ty) => { \n        check_option!($e, $T, |ptr| assert_eq!(*ptr, $e)); \n    }; \n    ($e:expr, $T:ty, |$v:ident| $chk:expr) => { \n        assert!(None::<$T>.is_none()); \n        let e = $e; \n        let s_ = Some::<$T>(e); \n        let $v = s_.as_ref().unwrap(); \n        $chk \n    } \n}\n\nmacro_rules! check_fancy { \n    ($e:expr, $T:ty) => { \n        check_fancy!($e, $T, |ptr| assert_eq!(*ptr, $e)); \n    }; \n    ($e:expr, $T:ty, |$v:ident| $chk:expr) => { \n        assert!(E::Nothing::<$T>((), ((), ()), [23; 0]).is_none()); \n        let e = $e; \n        let t_ = E::Thing::<$T>(23, e); \n        match t_.get_ref() { \n            (23, $v) => { $chk } \n            _ => panic!(\"Thing::<{}>(23, {}).get_ref() != (23, _)\", stringify!($T), stringify!($e)) \n        } \n    } \n}\n\nmacro_rules! check_type { \n    ($($a:tt)*) => { \n        check_option!($($a)*); \n        check_fancy!($($a)*); \n    } \n}\n\npub fn main() { \n    check_type!(&17, &isize); \n    check_type!(Box::new(18), Box<isize>); \n    check_type!(\"foo\".to_string(), String); \n    check_type!(vec![20, 22], Vec<isize>); \n    check_type!(main, fn(), |pthing| { \n        assert_eq!(main as fn(), *pthing as fn()) \n    }); \n}",
        "instruction": "The code demonstrates Rust's enum, impl block, methods, macros, and function usage. It defines an enum, implements methods for it, and uses macros for type checking. The main function tests different types using the defined macros."
    },
    {
        "output": "The Rust code defines an enum, a struct, and macros to check the size of different types. It then checks the size of Option and a custom enum type E against the size of a generic struct S containing the same type.",
        "input": "fn main() { assert_eq!(std::mem::size_of::<Option<&'static isize>>(), std::mem::size_of::<&'static isize>()); assert_eq!(std::mem::size_of::<E<&'static isize>>(), std::mem::size_of::<S<&'static isize>>()); assert_eq!(std::mem::size_of::<Option<Box<isize>>(), std::mem::size_of::<Box<isize>>()); assert_eq!(std::mem::size_of::<E<Box<isize>>(), std::mem::size_of::<S<Box<isize>>()); assert_eq!(std::mem::size_of::<Option<extern \"C\" fn()>>(), std::mem::size_of::<extern \"C\" fn()>()); assert_eq!(std::mem::size_of::<E<extern \"C\" fn()>>(), std::mem::size_of::<S<extern \"C\" fn()>>()); }",
        "instruction": "The code demonstrates checking the size of different types using macros in Rust. It compares the size of Option, a custom enum E, and a generic struct S with various types like references, boxes, and function pointers."
    },
    {
        "output": "Demonstrates trait methods being called on different types of trait objects (borrowed, borrowed mutable, and owned) with error comments for illegal cases",
        "input": "trait Foo { fn borrowed(&self); fn borrowed_mut(&mut self); fn owned(self: Box<Self>);}fn borrowed_receiver(x: &dyn Foo) { x.borrowed(); x.borrowed_mut();}fn borrowed_mut_receiver(x: &mut dyn Foo) { x.borrowed(); x.borrowed_mut(); x.owned();}fn owned_receiver(x: Box<dyn Foo>) { x.borrowed(); x.borrowed_mut(); x.owned();}fn main() {}",
        "instruction": "Defines a trait `Foo` with borrowed, borrowed mutable, and owned methods. Implements functions that receive borrowed, borrowed mutable, and owned trait objects, invoking trait methods. Shows error comments for illegal method calls."
    },
    {
        "output": "Defines a trait `Foo` with methods `foo` and `bar`. Implements `Foo` for `usize`, where `foo` returns the value and `bar` increments the value. Defines functions `do_it_mut` and `do_it_imm` to perform operations on objects implementing `Foo`. Invokes functions with a mutable reference to a `usize` object.",
        "input": "trait Foo {    fn foo(&self) -> usize;    fn bar(&mut self) -> usize;}impl Foo for usize {    fn foo(&self) -> usize {        *self    }    fn bar(&mut self) -> usize {        *self += 1;        *self    }}fn do_it_mut(obj: &mut dyn Foo) {    let x = obj.bar();    let y = obj.foo();    assert_eq!(x, y);    do_it_imm(obj, y);}fn do_it_imm(obj: &dyn Foo, v: usize) {    let y = obj.foo();    assert_eq!(v, y);}fn main() {    let mut x: usize = 22;    let obj = &mut x as &mut dyn Foo;    do_it_mut(obj);    do_it_imm(obj, 23);    do_it_mut(obj);}",
        "instruction": "Defines a trait, implements it for a specific type, and demonstrates trait objects in Rust by invoking methods through trait references."
    },
    {
        "output": "Demonstrates an error when trying to assign a `Box<_>` to a variable with the wrong type",
        "input": "fn main() { let f: Box<i32>; let g: i32; g = f; f = Box::new(g); }",
        "instruction": "Illustrates the error due to trying to assign an `i32` to a variable of type `Box<i32>`."
    },
    {
        "output": "Creates an enum `Clam` with a single variant `A` that holds a value of type `T`. In the `main` function, attempts to assign an uninitialized variable `c` with a value of type `Clam` and then matches on it, resulting in a compilation error due to trying to assign `Clam` before its value is initialized.",
        "input": "enum Clam<T> { A(T) }fn main() { let c: Clam<isize>; c = Clam::A(0); match c { Clam::A(_) => {} }}",
        "instruction": "The code defines an enum `Clam` with a single variant `A` that holds a value of type `T`. It then tries to assign a value to an uninitialized variable `c` of type `Clam` and matches on it, resulting in a compilation error due to using `c` before initializing it."
    },
    {
        "output": "This Rust code attempts to create a recursive data structure using a box, resulting in a compiler error due to potential stack overflow.",
        "input": "fn main() {\n    let f = Box::new(f);\n}",
        "instruction": "The code tries to assign an uninitialized `Box` to itself, which leads to a recursive structure causing a stack overflow. The error message indicates the issue of assigning `Box<_>` to an uninitialized value."
    },
    {
        "output": "Executes a function twice, causing a 'use of moved value' error due to moving the value 'x' into the closure.",
        "input": "fn foo<F:FnOnce()>(blk: F) {    blk();    blk();}fn main() {    use std::sync::Arc;    let x = Arc::new(true);    foo(move|| {        assert!(*x);        drop(x);    });}",
        "instruction": "The code defines a function 'foo' that takes a closure 'blk' and executes it twice. In the 'main' function, an Arc pointer 'x' is created and moved into the closure, causing a 'use of moved value' error when trying to use 'x' after it has been dropped."
    },
    {
        "output": "The code attempts to allocate a very large amount of memory that exceeds the address space, causing a panic. It then catches the panic and asserts that it did occur.",
        "input": "use std::hint::black_box;use std::mem::forget;use std::panic::catch_unwind;fn main() {let panic = catch_unwind(|| {for _ in 0..16 {let alloc_size = 0x1000_0000_1000_0000u64 as usize;forget(black_box(vec![0u8; alloc_size]));}});assert!(panic.is_err());}",
        "instruction": "The code demonstrates catching a panic that occurs due to an attempt to allocate memory beyond the available address space. It showcases the usage of `catch_unwind`, `black_box` for preventing optimizations, and `assert` for verifying the panic."
    },
    {
        "output": "Tests compound assignment operators with reference as right-hand side for various types. Demonstrates AddAssign, SubAssign, MulAssign, DivAssign, RemAssign, BitOrAssign, BitAndAssign, BitXorAssign, ShlAssign, and ShrAssign.",
        "input": "fn main() { let mut x = 3i8; x += &2i8; assert_eq!(x, 5i8); let mut x = 7i16; x -= &4; assert_eq!(x, 3i16); let mut x = 3f32; x *= &3f32; assert_eq!(x, 9f32); let mut x = 6f64; x /= &2f64; assert_eq!(x, 3f64); let mut x = 7i64; x %= &4i64; assert_eq!(x, 3i64); let mut x = 0b1010u8; x |= &0b1100u8; assert_eq!(x, 0b1110u8); let mut x = 0b1010u16; x &= &0b1100u16; assert_eq!(x, 0b1000u16); let mut x = 0b1010u32; x ^= &0b1100u32; assert_eq!(x, 0b0110u32); let mut x = 0b1010u64; x <<= &2u32; assert_eq!(x, 0b101000u64); let mut x = 0b1010u64; x >>= &2i16; assert_eq!(x, 0b10u64); }",
        "instruction": "The code snippet tests various compound assignment operators in Rust by using references as the right-hand side operand. It covers AddAssign, SubAssign, MulAssign, DivAssign, RemAssign, BitOrAssign, BitAndAssign, BitXorAssign, ShlAssign, and ShrAssign implementations."
    },
    {
        "output": "The code performs arithmetic operations on a mutable variable 'x' and prints the intermediate results along with asserting the final values.",
        "input": "fn main() { let mut x: isize = 1; x *= 2; println!(\"{}\", x); assert_eq!(x, 2); x += 3; println!(\"{}\", x); assert_eq!(x, 5); x *= x; println!(\"{}\", x); assert_eq!(x, 25); x /= 5; println!(\"{}\", x); assert_eq!(x, 5); }",
        "instruction": "The code demonstrates the usage of mutable variables, basic arithmetic operations, printing values, and assertions in Rust."
    },
    {
        "output": "Defines custom data structures and attempts to implement the `Copy` trait for them, resulting in compilation errors",
        "input": "struct CantCopyThis;struct IWantToCopyThis { but_i_cant: CantCopyThis,}enum CantCopyThisEither { A, B,}enum IWantToCopyThisToo { ButICant(CantCopyThisEither),}",
        "instruction": "The code defines two custom structs and two enums, then tries to implement the `Copy` trait for them, which is not allowed for these types in Rust."
    },
    {
        "output": "Defines two functions 'f' and 'g', where 'f' is marked as not inlinable and 'g' calls 'f'. The code tests different configurations of the -Cremark flag to enable specific compiler remarks.",
        "input": "fn f() {}fn g() { f(); }",
        "instruction": "The code demonstrates the use of compiler remarks in Rust by defining functions and testing different -Cremark flag configurations."
    },
    {
        "output": "The code defines a struct 'Foo' with two fields 'f1' and '_f2'. It has a function 'foo' that takes a mutable reference to 'Foo', makes a copy of it, sets 'f1' to 0 in the original struct, and returns the copy. The 'main' function creates an instance of 'Foo', calls 'foo' on it, and asserts that the 'f1' field remains the same after the function call.",
        "input": "//@ run-pass#[derive(Copy, Clone)]pub struct Foo { f1: isize, _f2: isize, }#[inline(never)]pub fn foo(f: &mut Foo) -> Foo { let ret = *f; f.f1 = 0; ret }pub fn main() { let mut f = Foo { f1: 8, _f2: 9, }; f = foo(&mut f); assert_eq!(f.f1, 8);}",
        "instruction": "Defines a struct, a function to manipulate it, and demonstrates mutation and copying in Rust."
    },
    {
        "output": "Defines multiple functions that return different types of data including integers, structs, and boxed values. It then initializes and reassigns variables of these types using the functions.",
        "input": "struct A { a: isize, b: isize }struct Abox { a: Box<isize>, b: Box<isize> }fn ret_int_i() -> isize { 10 }fn ret_ext_i() -> Box<isize> { Box::new(10) }fn ret_int_rec() -> A { A {a: 10, b: 10} }fn ret_ext_rec() -> Box<A> { Box::new(A {a: 10, b: 10}) }fn ret_ext_mem() -> Abox { Abox {a: Box::new(10), b: Box::new(10) } }fn ret_ext_ext_mem() -> Box<Abox> { Box::new(Abox{a: Box::new(10), b: Box::new(10) }) }pub fn main() { let mut int_i: isize; let mut ext_i: Box<isize>; let mut int_rec: A; let mut ext_rec: Box<A>; let mut ext_mem: Abox; let mut ext_ext_mem: Box<Abox>; int_i = ret_int_i(); int_i = ret_int_i(); int_i = ret_int_i(); ext_i = ret_ext_i(); ext_i = ret_ext_i(); ext_i = ret_ext_i(); int_rec = ret_int_rec(); int_rec = ret_int_rec(); int_rec = ret_int_rec(); ext_rec = ret_ext_rec(); ext_rec = ret_ext_rec(); ext_rec = ret_ext_rec(); ext_mem = ret_ext_mem(); ext_mem = ret_ext_mem(); ext_mem = ret_ext_mem(); ext_ext_mem = ret_ext_ext_mem(); ext_ext_mem = ret_ext_ext_mem(); ext_ext_mem = ret_ext_ext_mem(); }",
        "instruction": "Demonstrates defining functions that return different data types, including integers, structs, and boxed values, then initializing and reassigning variables of these types using these functions."
    },
    {
        "output": "Prints powers of 2 starting from 2 to the console",
        "input": "fn main() {\n    let mut b: usize = 1_usize;\n    while b < std::mem::size_of::<usize>() {\n        0_usize << b;\n        b <<= 1_usize;\n        println!(\"{}\", b);\n    }\n}",
        "instruction": "The code initializes a variable 'b' with the value 1. Then, it enters a 'while' loop that continues as long as 'b' is less than the size of 'usize'. Inside the loop, 'b' is left-shifted by 1 bit and the new value is printed to the console, effectively printing powers of 2 starting from 2."
    },
    {
        "output": "Defines a panic handler function that takes a reference to PanicInfo and returns never (indicating it never returns). The function takes a u8 input and returns it immediately. It then enters an infinite loop.",
        "input": "#![crate_type = \"rlib\"]\n#![no_std]\n\nuse core::panic::PanicInfo;\n\n#[panic_handler]\npub fn panic_fmt(info: &PanicInfo) -> ! {\n    |x: u8| x;\n    loop {}\n}",
        "instruction": "This code defines a panic handler function in a no_std environment, which is called when a panic occurs in the program. The panic handler takes a reference to PanicInfo, discards the input by immediately returning it, and then enters an infinite loop to halt the program execution."
    },
    {
        "output": "Accesses a private field 'x' of struct 'S' using a custom macro",
        "input": "mod m {    pub struct S {        x: i32    }    pub fn make() -> S {        S { x: 0 }    }}fn main() {    let s = m::make();    paren!(s.x); }macro_rules! paren {    ($e:expr) => (($e))}",
        "instruction": "Defines a struct 'S' with a private field 'x', creates an instance of 'S', then attempts to access the private field using a custom macro 'paren'."
    },
    {
        "output": "Defines two functions 'foo' and 'foo2' that take a reference and a value of a generic type, respectively, and attempt to compare them for equality. Calls 'foo' and 'foo2' with references and values of integer type.",
        "input": "fn foo<T: PartialEq>(a: &T, b: T) {    a == b; }fn foo2<T: PartialEq>(a: &T, b: T) where {    a == b; }fn main() {    foo(&1, 1);    foo2(&1, 1); }",
        "instruction": "The code demonstrates defining generic functions that attempt to compare a reference and a value for equality. The main function calls these functions with integer references and values, showcasing generic constraints in Rust."
    },
    {
        "output": "Defines two functions, `with_parens` and `no_parens`, that convert a generic input to a String representation. The `with_parens` function unnecessarily wraps the return value in parentheses, triggering a warning.",
        "input": "fn with_parens<T: ToString>(arg: T) -> String {    return (<T as ToString>::to_string(&arg)); }fn no_parens<T: ToString>(arg: T) -> String {    return <T as ToString>::to_string(&arg); }fn main() {}",
        "instruction": "Demonstrates defining generic functions in Rust and the warning related to unnecessary parentheses in the return statement."
    },
    {
        "output": "Calls the function 'bar' from the module 'foo' with an argument of 0",
        "input": "mod foo { pub fn bar(_offset: usize) {} } pub fn main() { foo::bar(0); }",
        "instruction": "Defining a module 'foo' with a function 'bar' that takes a usize parameter and calling this function with an argument of 0 in the main function."
    },
    {
        "output": "Checks various file system operations for handling paths with NUL characters and ensures they return an InvalidInput error if encountered.",
        "input": "use std::fs; use std::io; fn assert_invalid_input<T>(on: &str, result: io::Result<T>) { fn inner(on: &str, result: io::Result<()>) { match result { Ok(()) => panic!(\"{} didn't return an error on a path with NUL\", on), Err(e) => assert!(e.kind() == io::ErrorKind::InvalidInput, \"{} returned a strange {:?} on a path with NUL\", on, e.kind()), } } inner(on, result.map(drop)) } fn main() { assert_invalid_input(\"File::open\", fs::File::open(\"\\0\")); assert_invalid_input(\"File::create\", fs::File::create(\"\\0\")); assert_invalid_input(\"remove_file\", fs::remove_file(\"\\0\")); assert_invalid_input(\"metadata\", fs::metadata(\"\\0\")); assert_invalid_input(\"symlink_metadata\", fs::symlink_metadata(\"\\0\")); let dummy_file = std::env::current_exe().unwrap(); assert_invalid_input(\"rename1\", fs::rename(\"\\0\", \"a\")); assert_invalid_input(\"rename2\", fs::rename(&dummy_file, \"\\0\")); assert_invalid_input(\"copy1\", fs::copy(\"\\0\", \"a\")); assert_invalid_input(\"copy2\", fs::copy(&dummy_file, \"\\0\")); assert_invalid_input(\"hard_link1\", fs::hard_link(\"\\0\", \"a\")); assert_invalid_input(\"hard_link2\", fs::hard_link(&dummy_file, \"\\0\")); assert_invalid_input(\"soft_link1\", fs::soft_link(\"\\0\", \"a\")); assert_invalid_input(\"soft_link2\", fs::soft_link(&dummy_file, \"\\0\")); assert_invalid_input(\"read_link\", fs::read_link(\"\\0\")); assert_invalid_input(\"canonicalize\", fs::canonicalize(\"\\0\")); assert_invalid_input(\"create_dir\", fs::create_dir(\"\\0\")); assert_invalid_input(\"create_dir_all\", fs::create_dir_all(\"\\0\")); assert_invalid_input(\"remove_dir\", fs::remove_dir(\"\\0\")); assert_invalid_input(\"remove_dir_all\", fs::remove_dir_all(\"\\0\")); assert_invalid_input(\"read_dir\", fs::read_dir(\"\\0\")); assert_invalid_input(\"set_permissions\", fs::set_permissions(\"\\0\", fs::metadata(\".\").unwrap().permissions())); }",
        "instruction": "The code tests various file system operations with paths containing NUL characters to ensure that each operation returns an InvalidInput error if a NUL character is encountered in the path."
    },
    {
        "output": "Defines an auto trait 'Zen' and implements it for references of types that implement 'Sync'. Shows an error when trying to pass a 'Guard' containing 'T' that is not 'Sync' to a function that requires 'T' to be 'Zen'.",
        "input": "#![feature(auto_traits)]\nuse std::marker::{PhantomData};\n\nunsafe auto trait Zen {}\nunsafe impl<'a, T: 'a> Zen for &'a T where T: Sync {}\n\nstruct Guard<'a, T: 'a> {\n    _marker: PhantomData<&'a T>,\n}\n\nstruct Nested<T>(T);\n\nfn is_zen<T: Zen>(_: T) {}\n\nfn not_sync<T>(x: Guard<T>) {\n    is_zen(x)\n}\n\nfn nested_not_sync<T>(x: Nested<Guard<T>>) {\n    is_zen(x)\n}\n\nfn main() {}",
        "instruction": "Demonstrates using auto traits in Rust and enforcing trait bounds on references. Shows how Rust checks thread safety when using traits for type parameters."
    },
    {
        "output": "Defines a function 'unrelated' that handles a match statement on the value of 'x', parsing a string if 'x' is 1 and attempting to create a reference to an integer if 'x' is 2.",
        "input": "fn unrelated() -> Result<(), std::string::ParseError> { let x = 0; match x { 1 => { let property_value_as_string = \"a\".parse()?; } 2 => { let value: &bool = unsafe { &42 }; } }; Ok(()) } fn main() {}",
        "instruction": "The code demonstrates pattern matching in Rust using the 'match' keyword to handle different values of 'x'. It also shows error handling with the 'Result' type and usage of unsafe code to create a reference to an integer."
    },
    {
        "output": "Defines a function `let_in` that takes two parameters: a value of type T and a closure F, where F should accept a single argument of type T. The function body of `let_in` is empty.",
        "input": "fn let_in<T, F>(x: T, f: F) where F: FnOnce(T) {}fn main() {    let_in(3u32, |i| { assert!(i == 3i32); });    //~^ ERROR mismatched types    //~| expected `u32`, found `i32`    let_in(3i32, |i| { assert!(i == 3u32); });    //~^ ERROR mismatched types    //~| expected `i32`, found `u32}",
        "instruction": "Demonstrates defining a generic function `let_in` that takes a value of any type and a closure that operates on that value. Shows type mismatch errors when calling `let_in` with different types for the value parameter and closure argument."
    },
    {
        "output": "Creates a box containing the integer 0, drops the box, creates a new box containing the main function, adds 0 to the dereferenced value of the first box, and asserts that the result is equal to 0.",
        "input": "fn main() {  let x = Box::new(0);  assert_eq!(0, *x + { drop(x); let _ = Box::new(main); 0 });}",
        "instruction": "The code demonstrates ownership transfer and dropping of values in Rust, along with performing arithmetic operations and asserting equality."
    },
    {
        "output": "This Rust code prints 'Hello, World!' to the console",
        "input": "fn main() { println!(\"Hello, World!\"); }",
        "instruction": "A basic Rust program that uses the `println!` macro to output the text 'Hello, World!' to the console."
    },
    {
        "output": "The program contains two functions: 'child' and 'parent'. The 'child' function prints messages to stdout and stderr. The 'parent' function executes a command with the same arguments as the current process, captures its output, and asserts the equality of the captured stdout and stderr. The 'main' function decides whether to call 'child' or 'parent' based on the number of command-line arguments.",
        "input": "use std::{env, process};fn child() {    print!('[stdout 0]');    print!('[stdout {}]', 1);    println!('[stdout {}]', 2);    println!();    eprint!('[stderr 0]');    eprint!('[stderr {}]', 1);    eprintln!('[stderr {}]', 2);    eprintln!();}fn parent() {    let this = env::args().next().unwrap();    let output = process::Command::new(this).arg('-').output().unwrap();    assert!(output.status.success());    let stdout = String::from_utf8(output.stdout).unwrap();    let stderr = String::from_utf8(output.stderr).unwrap();    assert_eq!(stdout, '[stdout 0][stdout 1][stdout 2]\\n\\n');    assert_eq!(stderr, '[stderr 0][stderr 1][stderr 2]\\n\\n');}fn main() {    if env::args().count() == 2 { child() } else { parent() }}",
        "instruction": "Demonstrates executing a child process in Rust, capturing its output, and asserting the equality of captured stdout and stderr."
    },
    {
        "output": "Defines multiple traits and implementations in Rust to demonstrate upcasting and conversion to static types.",
        "input": "pub trait Upcast<T> {    fn upcast(self) -> T;}impl<S1, S2, T1, T2> Upcast<(T1, T2)> for (S1,S2)    where S1: Upcast<T1>,          S2: Upcast<T2>,{    fn upcast(self) -> (T1, T2) { (self.0.upcast(), self.1.upcast()) }}impl Upcast<()> for (){    fn upcast(self) -> () { () } }pub trait ToStatic {    type Static: 'static;    fn to_static(self) -> Self::Static where Self: Sized;}impl<T, U> ToStatic for (T, U)    where T: ToStatic,          U: ToStatic{    type Static = (T::Static, U::Static);    fn to_static(self) -> Self::Static { (self.0.to_static(), self.1.to_static()) }}impl ToStatic for (){    type Static = ();    fn to_static(self) -> () { () } }trait Factory {    type Output;    fn build(&self) -> Self::Output;}impl<S,T> Factory for (S, T)    where S: Factory,          T: Factory,          S::Output: ToStatic,          <S::Output as ToStatic>::Static: Upcast<S::Output>,{    type Output = (S::Output, T::Output);    fn build(&self) -> Self::Output { (self.0.build().to_static().upcast(), self.1.build()) }}impl Factory for () {    type Output = ();    fn build(&self) -> Self::Output { () } }fn main() {    let it = ((((((((((),()),()),()),()),()),()),()),()),());    it.build(); }",
        "instruction": "Defines traits for upcasting and conversion to static types, with implementations showing how to convert tuples and build instances using these traits."
    },
    {
        "output": "Demonstrates coercions between different types of pointers in Rust, including mutable references to immutable references, references to raw pointers, and mutable references to raw pointers.",
        "input": "fn main() { let x: &mut isize = &mut 42; let x: &isize = x; let x: &isize = &mut 42; let x: &isize = &42; let x: *const isize = x; let x: *const isize = &42; let x: &mut isize = &mut 42; let x: *const isize = x; let x: *const isize = &mut 42; let x: *mut isize = &mut 42; let x: *const isize = x; }",
        "instruction": "The code showcases how Rust handles coercions between mutable references, immutable references, raw pointers (*const and *mut) demonstrating Rust's strict rules for pointer conversions."
    },
    {
        "output": "Demonstrates type mismatch error when coercing between different types of pointers in Rust",
        "input": "fn main() {\n    let x: *const isize = &42;\n    let x: *mut isize = x;\n    let x: *mut isize = &42;\n    let x: *const isize = &42;\n    let x: *mut isize = x;\n}",
        "instruction": "The code showcases type errors when converting between raw pointers and references with different mutability in Rust, illustrating the importance of maintaining correct pointer types."
    },
    {
        "output": "Defines a trait named 'Layer' with a generic type parameter 'Input'.",
        "input": "pub trait Layer<Input> {}",
        "instruction": "This Rust code snippet declares a trait named 'Layer' with a generic type parameter 'Input'. Traits in Rust are used to define functionality that types can implement."
    },
    {
        "output": "Compares raw string literals with regular string literals using assert_eq! macro",
        "input": "fn main() { assert_eq!(r\"abc\", \"abc\"); assert_eq!(r#\"abc\"#, \"abc\"); assert_eq!(r\"###\", \"###\"); assert_eq!(r\"\\\", \"\\\\\"); assert_eq!(r#\"\\\"\"#, \"\\\\\\\"\"); assert_eq!(r#\"#\"\\n\"\"#, \"#\\\"\\\\n\\\"\"); assert_eq!(r##\"a\"#\"b\"##, \"a\\\"#\\\"b\");}",
        "instruction": "The code showcases the usage of raw string literals in Rust by comparing them with regular string literals using assert_eq! macro. Raw string literals are useful when dealing with strings that contain many escape characters."
    },
    {
        "output": "Performs memory allocation and reallocation tests on a triangle shape of memory",
        "input": "fn main() {    unsafe {        assert!(test_triangle());    }    }    unsafe fn test_triangle() -> bool {    static COUNT: usize = 16;    let mut ascend = vec![ptr::null_mut(); COUNT];    let ascend = &mut *ascend;    static ALIGN: usize = 1;    unsafe fn sanity_check(ascend: &[*mut u8]) {        for i in 0..COUNT / 2 {            let (p0, p1, size) = (ascend[2 * i], ascend[2 * i + 1], idx_to_size(i));            for j in 0..size {                assert_eq!(*p0.add(j), i as u8);                assert_eq!(*p1.add(j), i as u8);            }        }    }    unsafe fn allocate(layout: Layout) -> *mut u8 {        let ptr = Global.allocate(layout).unwrap_or_else(|_| handle_alloc_error(layout));        ptr.as_mut_ptr()    }    unsafe fn deallocate(ptr: *mut u8, layout: Layout) {        Global.deallocate(NonNull::new_unchecked(ptr), layout);    }    unsafe fn reallocate(ptr: *mut u8, old: Layout, new: Layout) -> *mut u8 {        let memory = if new.size() > old.size() {            Global.grow(NonNull::new_unchecked(ptr), old, new)        } else {            Global.shrink(NonNull::new_unchecked(ptr), old, new)        };        ptr.as_mut_ptr()    }    fn idx_to_size(i: usize) -> usize {        (i + 1) * 10    }    for i in 0..COUNT / 2 {        let size = idx_to_size(i);        ascend[2 * i] = allocate(Layout::from_size_align(size, ALIGN).unwrap());        ascend[2 * i + 1] = allocate(Layout::from_size_align(size, ALIGN).unwrap());    }    for i in 0..COUNT / 2 {        let (p0, p1, size) = (ascend[2 * i], ascend[2 * i + 1], idx_to_size(i));        for j in 0..size {            *p0.add(j) = i as u8;            *p1.add(j) = i as u8;        }    }    sanity_check(&*ascend);    test_1(ascend);    test_2(ascend);    test_3(ascend);    test_4(ascend);    for i in 0..COUNT / 2 {        let size = idx_to_size(i);        deallocate(ascend[2 * i], Layout::from_size_align(size, ALIGN).unwrap());        deallocate(ascend[2 * i + 1], Layout::from_size_align(size, ALIGN).unwrap());    }    true    }",
        "instruction": "Demonstrates memory allocation, deallocation, and reallocation in a triangle memory shape, checking for buffer overruns and memory integrity."
    },
    {
        "output": "Attempts to mutate immutable bindings introduced by `ref` or `ref mut` patterns",
        "input": "fn main() { let (mut one_two, mut three_four) = ((1, 2), (3, 4)); let &mut (ref a, ref mut b) = &mut one_two; a = &three_four.0; b = &mut three_four.1; }",
        "instruction": "The code demonstrates an attempt to mutate immutable bindings introduced using `ref` or `ref mut` patterns, showing compiler errors when attempting to reassign values to these immutable references."
    },
    {
        "output": "Calls the test harness main function",
        "input": "#[cfg(test)]fn _unused() { test_main(); }",
        "instruction": "This code snippet defines an unused function that calls the test harness main function. The #[cfg(test)] attribute ensures this code is only compiled in test mode."
    },
    {
        "output": "Defines a Rust module with unused extern crates 'removing_extern_crate' and 'core'.",
        "input": "mod another {\n    extern crate removing_extern_crate as foo;\n    extern crate core;\n}",
        "instruction": "Demonstrates defining a module in Rust and unused extern crates within the module."
    },
    {
        "output": "Prints the value of a Cell wrapped in a struct",
        "input": "use std::cell::Cell;\n\n#[derive(Debug)]\nstruct r<'a> {\n    i: &'a Cell<isize>,\n}\n\nimpl<'a> Drop for r<'a> {\n    fn drop(&mut self) {\n        self.i.set(self.i.get() + 1);\n    }\n}\n\nfn r(i: &Cell<isize>) -> r {\n    r {\n        i: i\n    }\n}\n\npub fn main() {\n    let i = &Cell::new(0);\n    {\n        let a = r(i);\n        let b = (a, 10);\n        let (c, _d) = b;\n        println!(\"{:?}\", c);\n    }\n    assert_eq!(i.get(), 1);\n}",
        "instruction": "Defines a struct containing a reference to a Cell, increments the Cell value on struct drop, creates instances of the struct, prints the struct content, and asserts the modified Cell value."
    },
    {
        "output": "Prints 'Hello!' to the console, decrements the value in 'my_total', and asserts the changes",
        "input": "use std::cell::Cell; struct shrinky_pointer<'a> { i: &'a Cell<isize>, } impl<'a> Drop for shrinky_pointer<'a> { fn drop(&mut self) { println!(\"Hello!\"); self.i.set(self.i.get() - 1); } } impl<'a> shrinky_pointer<'a> { pub fn look_at(&self) -> isize { return self.i.get(); } } fn shrinky_pointer(i: &Cell<isize>) -> shrinky_pointer { shrinky_pointer { i: i } } pub fn main() { let my_total = &Cell::new(10); { let pt = shrinky_pointer(my_total); assert_eq!(pt.look_at(), 10); } println!(\"my_total = {}\", my_total.get()); assert_eq!(my_total.get(), 9); }",
        "instruction": "Defines a struct 'shrinky_pointer' that decrements the value in 'my_total' upon dropping, asserts the changes, and prints messages to the console."
    },
    {
        "output": "Defines a function named 'main' that triggers a fatal error when compiled",
        "input": "fn main() { #[rustc_error] }",
        "instruction": "The code uses the #[rustc_error] attribute which triggers a fatal error when compiled. This demonstrates how Rust allows custom attributes to modify compiler behavior."
    },
    {
        "output": "Defines a trait and two implementations in Rust",
        "input": "fn main() {\ttrait Seq { }\timpl<T> Seq for Vec<T> { }\timpl Seq<bool> for u32 { }\t}",
        "instruction": "The code defines a trait `Seq` and two implementations: one for a generic `Vec` type and another for a specific `u32` type. There's an error message indicating that the trait should not have any generic arguments, which is being violated in the implementations."
    },
    {
        "output": "Defines a trait called QueryId with a constant property",
        "input": "pub trait QueryId {    const SOME_PROPERTY: bool;}",
        "instruction": "Defines a trait with a constant property named SOME_PROPERTY of type bool within the trait QueryId."
    },
    {
        "output": "Implements QueryId trait for a struct bool",
        "input": "pub struct bool; impl QueryId for bool { const SOME_PROPERTY: core::primitive::bool = true; }",
        "instruction": "Implements the QueryId trait for a struct named bool, setting the constant SOME_PROPERTY to true."
    },
    {
        "output": "Calls the function 'f' from the module 'foo' using the alias 'bar'",
        "input": "mod foo {    pub fn f() {}    pub use self::f as bar;    use foo as bar;}fn main() {    foo::bar();}",
        "instruction": "Defines a module 'foo' with a function 'f', creates an alias 'bar' for 'f', and calls 'f' using the alias 'bar'."
    },
    {
        "output": "The Rust code attempts to call a function 'foo' with a string argument and then tries to call a method 'salut' on an unsigned integer variable, which is not defined in the standard library.",
        "input": "fn foo(_: u32) {}\nfn main() {\n    foo(\"Bonjour\".to_owned());\n    let x = 0u32;\n    x.salut();\n}",
        "instruction": "The code defines a function 'foo' that takes an unsigned 32-bit integer as an argument. In the 'main' function, it tries to call 'foo' with a string argument instead of an integer. Additionally, it attempts to call a method 'salut' on an unsigned integer variable 'x', which is not a valid method on an unsigned integer."
    },
    {
        "output": "Defines a SIMD vector struct and a function that takes the struct as an argument",
        "input": "#![no_core]\n#![feature(no_core, lang_items, repr_simd)]\n#![allow(improper_ctypes_definitions)]\n\n#[lang = \"sized\"]\ntrait Sized {}\n#[lang = \"copy\"]\ntrait Copy {}\n\n#[repr(simd)]\npub struct SimdVec([i32; 4]);\n\npub extern \"C\" fn pass_by_vec(_: SimdVec) {}",
        "instruction": "The code defines a SIMD vector struct named 'SimdVec' with an array of 4 i32 values. It also declares a function 'pass_by_vec' that takes an argument of type 'SimdVec'."
    },
    {
        "output": "Defines several structs and trait implementations for SIMD vector types in Rust. Includes functions that use SIMD vectors as arguments and return values. Some functions require the 'vector' target feature to be enabled.",
        "input": "#![feature(no_core, lang_items, repr_simd, s390x_target_feature)]\n#![no_core]\n#![crate_type = \"lib\"]\n#![allow(non_camel_case_types, improper_ctypes_definitions)]\n#![deny(abi_unsupported_vector_types)]\n#[lang = \"sized\"]\npub trait Sized {}\n#[lang = \"copy\"]\npub trait Copy {}\n#[lang = \"freeze\"]\npub trait Freeze {}\nimpl<T: Copy, const N: usize> Copy for [T; N] {}\n#[repr(simd)]\npub struct i8x8([i8; 8]);\n#[repr(simd)]\npub struct i8x16([i8; 16]);\n#[repr(simd)]\npub struct i8x32([i8; 32]);\n#[repr(C)]\npub struct Wrapper<T>(T);\n#[repr(transparent)]\npub struct TransparentWrapper<T>(T);\nimpl Copy for i8 {}\nimpl Copy for i64 {}\nimpl Copy for i8x8 {}\nimpl Copy for i8x16 {}\nimpl Copy for i8x32 {}\nimpl<T: Copy> Copy for Wrapper<T> {}\nimpl<T: Copy> Copy for TransparentWrapper<T> {}\n#[no_mangle]\nextern \"C\" fn vector_ret_small(x: &i8x8) -> i8x8 {*x}\n#[no_mangle]\nextern \"C\" fn vector_ret(x: &i8x16) -> i8x16 {*x}\n#[no_mangle]\nextern \"C\" fn vector_ret_large(x: &i8x32) -> i8x32 {*x}\n#[no_mangle]\n#[target_feature(enable = \"vector\")]\nunsafe extern \"C\" fn vector_ret_target_feature_small(x: &i8x8) -> i8x8 {*x}\n#[no_mangle]\n#[target_feature(enable = \"vector\")]\nunsafe extern \"C\" fn vector_target_feature_ret(x: &i8x16) -> i8x16 {*x}\n#[no_mangle]\n#[target_feature(enable = \"vector\")]\nunsafe extern \"C\" fn vector_ret_target_feature_large(x: &i8x32) -> i8x32 {*x}\n#[no_mangle]\nextern \"C\" fn vector_wrapper_ret_small(x: &Wrapper<i8x8>) -> Wrapper<i8x8> {*x}\n#[no_mangle]\nextern \"C\" fn vector_wrapper_ret(x: &Wrapper<i8x16>) -> Wrapper<i8x16> {*x}\n#[no_mangle]\nextern \"C\" fn vector_wrapper_ret_large(x: &Wrapper<i8x32>) -> Wrapper<i8x32> {*x}\n#[no_mangle]\nextern \"C\" fn vector_transparent_wrapper_ret_small(x: &TransparentWrapper<i8x8>) -> TransparentWrapper<i8x8> {*x}\n#[no_mangle]\nextern \"C\" fn vector_transparent_wrapper_ret(x: &TransparentWrapper<i8x16>) -> TransparentWrapper<i8x16> {*x}\n#[no_mangle]\nextern \"C\" fn vector_transparent_wrapper_ret_large(x: &TransparentWrapper<i8x32>) -> TransparentWrapper<i8x32> {*x}\n#[no_mangle]\nextern \"C\" fn vector_arg_small(x: i8x8) -> i64 {unsafe { *(&x as *const i8x8 as *const i64) }}\n#[no_mangle]\nextern \"C\" fn vector_arg(x: i8x16) -> i64 {unsafe { *(&x as *const i8x16 as *const i64) }}\n#[no_mangle]\nextern \"C\" fn vector_arg_large(x: i8x32) -> i64 {unsafe { *(&x as *const i8x32 as *const i64) }}\n#[no_mangle]\nextern \"C\" fn vector_wrapper_arg_small(x: Wrapper<i8x8>) -> i64 {unsafe { *(&x as *const Wrapper<i8x8> as *const i64) }}\n#[no_mangle]\nextern \"C\" fn vector_wrapper_arg(x: Wrapper<i8x16>) -> i64 {unsafe { *(&x as *const Wrapper<i8x16> as *const i64) }}\n#[no_mangle]\nextern \"C\" fn vector_wrapper_arg_large(x: Wrapper<i8x32>) -> i64 {unsafe { *(&x as *const Wrapper<i8x32> as *const i64) }}\n#[no_mangle]\nextern \"C\" fn vector_transparent_wrapper_arg_small(x: TransparentWrapper<i8x8>) -> i64 {unsafe { *(&x as *const TransparentWrapper<i8x8> as *const i64) }}\n#[no_mangle]\nextern \"C\" fn vector_transparent_wrapper_arg(x: TransparentWrapper<i8x16>) -> i64 {unsafe { *(&x as *const TransparentWrapper<i8x16> as *const i64) }}\n#[no_mangle]\nextern \"C\" fn vector_transparent_wrapper_arg_large(x: TransparentWrapper<i8x32>) -> i64 {unsafe { *(&x as *const TransparentWrapper<i8x32> as *const i64) }}",
        "instruction": "Demonstrates defining SIMD vector types and functions using them as arguments and return values. Functions require specific target features like 'vector'. Shows how to handle SIMD vector types in Rust."
    },
    {
        "output": "Demonstrates the usage of SIMD vector types and target features in Rust code",
        "input": "fn main() {    unsafe {        f(g());    }    unsafe {        gavx(favx());    }    unsafe {        test();    }    unsafe {        w(Wrapper(g()));    }    unsafe {        in_closure()();    }    unsafe {        #[expect(improper_ctypes)]        extern \"C\" {            fn some_extern() -> __m256;        }        some_extern();    }}#[target_feature(enable = \"avx2\")]unsafe extern \"C\" fn gavx(_: __m256) {    todo!()}#[target_feature(enable = \"avx\")]unsafe extern \"C\" fn favx() -> __m256 {    todo!()}fn as_f64x8(d: __m512d) -> std::simd::f64x8 {    unsafe { std::mem::transmute(d) }}unsafe fn test() {    let arg = std::mem::transmute([0.0f64; 8]);    as_f64x8(arg);}unsafe extern \"C\" fn f(_: __m256) {    todo!()}unsafe extern \"C\" fn g() -> __m256 {    todo!()}struct Wrapper(__m256);unsafe extern \"C\" fn w(_: Wrapper) {    todo!()}unsafe fn in_closure() -> impl FnOnce() -> __m256 {    #[inline(always)] || g() }#[no_mangle]#[target_feature(enable = \"avx\")]fn some_extern() -> __m256 {    todo!()}",
        "instruction": "The code showcases Rust code utilizing SIMD vector types with specific target features enabled, demonstrating the use of unsafe code, transmutation, function calls, and closures."
    },
    {
        "output": "Defines two functions, 'bar' and 'foo', where 'bar' takes a type parameter 'T' that must implement the 'Sized' trait and 'foo' calls 'bar' with a reference to type 'T'. The 'main' function is empty.",
        "input": "fn bar<T: Sized>() {}\nfn foo<T>() { bar::<&T>(); }\npub fn main() {}",
        "instruction": "Demonstrates defining functions that take type parameters and calling a function with a reference to a type parameter in Rust."
    },
    {
        "output": "Defines two structs, 'Baz' and 'Foo', where 'Foo' contains an optional 'Baz' and 'Baz' contains an optional 'Foo'. An error is raised due to the recursive relationship causing infinite size.",
        "input": "struct Baz { q: Option<Foo> } struct Foo { q: Option<Baz> } impl Foo { fn bar(&self) {} } fn main() {}",
        "instruction": "Illustrates the issue of recursive types 'Baz' and 'Foo' causing infinite size, which is not allowed in Rust."
    },
    {
        "output": "Defines two generic functions, 'bar' and 'foo', where 'bar' takes a generic type 'T' that must be Sized and 'foo' calls 'bar' with 'Box<T>'. The 'main' function is empty.",
        "input": "fn bar<T: Sized>() {}\nfn foo<T>() { bar::<Box<T>>(); }\npub fn main() {}",
        "instruction": "Demonstrates defining generic functions in Rust with trait bounds. 'bar' takes a Sized type 'T', and 'foo' calls 'bar' with 'Box<T>'. The 'main' function is left empty in this example."
    },
    {
        "output": "Defines a Rust struct for a SSE vector and an external function that operates on this vector",
        "input": "#![feature(no_core, lang_items, repr_simd)]\n#![no_core]\n#![allow(improper_ctypes_definitions)]\n\n#[repr(simd)]\npub struct SseVector([i64; 2]);\n\n#[no_mangle]\npub unsafe extern \"C\" fn f(_: SseVector) {}",
        "instruction": "This code defines a struct representing a SSE vector using SIMD (Single Instruction, Multiple Data) and an external function that takes this SSE vector as an argument. The code also includes feature flags and attributes to control compilation behavior."
    },
    {
        "output": "Checks for the presence of the SSE2 target feature on x86 and x86_64 platforms and asserts its availability. Skips tests on i586-unknown-linux-gnu platform where SSE2 is disabled.",
        "input": "use std::env;fn main() {    match env::var(\"TARGET\") {        Ok(s) => {            if s.contains(\"i586\") {                return            }        }        Err(_) => return,    }    if cfg!(any(target_arch = \"x86\", target_arch = \"x86_64\")) {        assert!(cfg!(target_feature = \"sse2\"),                \"SSE2 was not detected as available on an x86 platform\");    }    #[expect(unexpected_cfgs)]    { assert!(cfg!(not(target_feature = \"ferris_wheel\")),            \"\ud83c\udfa1 shouldn't be detected as available by default on any platform\") };}",
        "instruction": "The code checks for the availability of the SSE2 target feature on x86 and x86_64 platforms, skipping tests on i586-unknown-linux-gnu where SSE2 is disabled. It also demonstrates the usage of conditional compilation with `cfg!` and handling different platform configurations."
    },
    {
        "output": "The code asserts that the address of the variable 'foo' is the same as the address of 'foo' itself.",
        "input": "fn main() {\n    let foo: isize = 1;\n    assert_eq!(&foo as *const isize, &foo as *const isize);\n}",
        "instruction": "Defines a variable 'foo' of type isize with value 1, then asserts that the address of 'foo' is equal to the address of 'foo' itself using raw pointers in Rust."
    },
    {
        "output": "Creates atomic variables of different types and attempts to move them out of shared references, triggering move errors",
        "input": "use std::sync::atomic::*;use std::ptr;fn main() {    let x = AtomicBool::new(false);    let x = *&x; //~ ERROR: cannot move out of a shared reference    let x = AtomicIsize::new(0);    let x = *&x; //~ ERROR: cannot move out of a shared reference    let x = AtomicUsize::new(0);    let x = *&x; //~ ERROR: cannot move out of a shared reference    let x: AtomicPtr<usize> = AtomicPtr::new(ptr::null_mut());    let x = *&x; //~ ERROR: cannot move out of a shared reference}",
        "instruction": "The code demonstrates the Rust error 'cannot move out of a shared reference' when trying to move atomic values out of shared references, which is not allowed due to the atomic nature of these values."
    },
    {
        "output": "A multi-threaded Rust program that runs a test concurrently on multiple threads",
        "input": "use std::env;use std::io::prelude::*;use std::process::Command;use std::thread;const THREADS: usize = 20;const WRITES: usize = 100;const WRITE_SIZE: usize = 1024 * 32;fn main() {let args = env::args().collect::<Vec<_>>();if args.len() == 1 {parent();} else {child();}}fn parent() {let me = env::current_exe().unwrap();let mut cmd = Command::new(me);cmd.arg(\"run-the-test\");let output = cmd.output().unwrap();assert!(output.status.success());assert_eq!(output.stderr.len(), 0);assert_eq!(output.stdout.len(), WRITES * THREADS * WRITE_SIZE);for &byte in output.stdout.iter() {assert_eq!(byte, b'a');}}fn child() {let threads = (0..THREADS).map(|_| {thread::spawn(|| {let buf = [b'a'; WRITE_SIZE];for _ in 0..WRITES {write_all(&buf);}})}).collect::<Vec<_>>();for t in threads {t.join().unwrap();}}#[cfg(unix)]fn write_all(buf: &[u8]) {use std::fs::File;use std::mem;use std::os::unix::prelude::*;let mut file = unsafe { File::from_raw_fd(1) };let res = file.write_all(buf);mem::forget(file);res.unwrap();}#[cfg(windows)]fn write_all(buf: &[u8]) {use std::fs::File;use std::mem;use std::os::windows::raw::*;use std::os::windows::prelude::*;const STD_OUTPUT_HANDLE: u32 = (-11i32) as u32;extern \"system\" {fn GetStdHandle(handle: u32) -> HANDLE;}let mut file = unsafe {let handle = GetStdHandle(STD_OUTPUT_HANDLE);assert!(!handle.is_null());File::from_raw_handle(handle)};let res = file.write_all(buf);mem::forget(file);res.unwrap();}",
        "instruction": "The program creates 20 threads, each writing the character 'a' 100 times with a buffer size of 32KB. The parent process runs a test using the output of a command, ensuring success and specific output length. The child threads write to the output in parallel using platform-specific file handling."
    },
    {
        "output": "Creates instances of error trait boxes with different trait bounds and lifetimes",
        "input": "fn main() {\n    let _err1: Box<dyn Error + Send + Sync> = From::from(\"test\".to_string());\n    let _err2: Box<dyn Error> = From::from(\"test\".to_string());\n    let _err3: Box<dyn Error + Send + Sync + 'static> = From::from(\"test\");\n    let _err4: Box<dyn Error> = From::from(\"test\");\n}",
        "instruction": "The code demonstrates creating instances of error trait boxes with varying trait bounds and lifetimes using the `From` trait in Rust."
    },
    {
        "output": "Calculates and prints the size of the struct Foo in bytes",
        "input": "//@ run-pass\nfn size_of_val<T>(_: &T) -> usize {\n    std::mem::size_of::<T>()\n}\n\nstruct Foo(#[allow(dead_code)] i64);\n\nfn main() {\n    size_of_val(&Foo(0));\n    size_of_val(&Foo);\n}",
        "instruction": "Defines a function size_of_val that calculates the size of a given type in bytes using std::mem::size_of. Creates a struct Foo with an i64 field and calculates the size of Foo by passing references to Foo(0) and Foo to size_of_val."
    },
    {
        "output": "A minimal Rust program with a compilation error due to an excessive number of leading `super` keywords.",
        "input": "fn main() { }",
        "instruction": "The code defines a main function, which serves as the entry point for the program. The compilation error arises from an incorrect use of the `super` keyword."
    },
    {
        "output": "Defines a module 'a' with a function 'f' and a submodule 'b' with a function 'g' that calls 'f' from the parent module. Also defines a main function outside the module.",
        "input": "mod a {    pub fn f() {}    mod b {        fn g() {            super::f();        }    }}fn main() {}",
        "instruction": "Demonstrates Rust module system with nested modules and functions. Shows the usage of 'super' keyword to access items from the parent module."
    },
    {
        "output": "Calls the function 'foo' from the 'b' crate",
        "input": "extern crate a; extern crate b; fn main() { b::foo(); }",
        "instruction": "Imports two external crates 'a' and 'b', then calls the function 'foo' from the 'b' crate in the 'main' function."
    },
    {
        "output": "Swaps the values of two mutable variables",
        "input": "fn main() {    let mut x = 3;    let mut y = 7;    std::mem::swap(&mut x, &mut y);    assert_eq!(x, 7);    assert_eq!(y, 3); }",
        "instruction": "Defines two mutable variables x and y, then swaps their values using std::mem::swap function, and finally asserts that the values have been swapped correctly."
    },
    {
        "output": "Swaps the fields of a struct in-place",
        "input": "use std::ptr;fn main() {    let mut test = TestDescAndFn {        desc: TestDesc {            name: TestName::DynTestName(\"test\".to_string()),            should_fail: false        },        testfn: TestFn::DynTestFn(22),    };    do_swap(&mut test);}fn do_swap(test: &mut TestDescAndFn) {    unsafe {        ptr::swap(&mut test.desc, &mut test.testfn);    }}pub enum TestName {    DynTestName(String)}pub enum TestFn {    DynTestFn(isize),    DynBenchFn(isize),}pub struct TestDesc {    name: TestName,    should_fail: bool}pub struct TestDescAndFn {    desc: TestDesc,    testfn: TestFn,}",
        "instruction": "Demonstrates swapping struct fields in Rust using mutable references and the `ptr::swap` function. The `do_swap` function swaps the `desc` and `testfn` fields of a `TestDescAndFn` struct in place using raw pointers."
    },
    {
        "output": "Rust code assigns an integer value to a String reference variable",
        "input": "fn main() { let var = 10i32; let ref string: String = var.to_string(); }",
        "instruction": "The code demonstrates assigning an integer value to a String reference variable in Rust. The `to_string()` method is used to convert the integer to a String type."
    },
    {
        "output": "Defines a struct Foo and assigns it to a concatenated identifier F_oo using concat_idents! macro. Also, tests the usage of concat_idents! in type positions and call-site hygiene.",
        "input": "fn main() {\n    struct Foo;\n    let _: F_oo = Foo;\n    let asdf_fdsa = \"<.<\".to_string();\n    assert!(asd_f_f_dsa == \"<.<\".to_string());\n    assert_eq!(stringify!(use_mention_distinction), \"use_mention_distinction\");\n}",
        "instruction": "Demonstrates the usage of concat_idents! macro to concatenate identifiers in type positions and test call-site hygiene. Also shows the stringify! macro for converting identifiers to strings."
    },
    {
        "output": "The code defines an enum named Quux with a generic type parameter T, but the parameter T is never used. There is a function foo that takes a variable c of type Quux, but the function body contains an assertion that always fails. Finally, the main function calls the panic macro, which will cause the program to panic and print an error message.",
        "input": "enum Quux<T> { Bar }fn foo(c: Quux<()>) { assert!(false); }fn main() { panic!(); }",
        "instruction": "The code demonstrates defining an enum with a generic type, writing a function that takes an instance of the enum, and invoking the panic macro to terminate the program abruptly."
    },
    {
        "output": "Defines an enum `NonNullary` with two variants and implements the `From` trait for conversion to `isize`. In `main`, it creates a value of `NonNullary::Nullary` and attempts to convert it to `isize`, triggering a compilation error due to a non-primitive cast.",
        "input": "#![allow(dead_code, unused_variables)]\nenum NonNullary {\n    Nullary,\n    Other(isize),\n}\n\nimpl From<NonNullary> for isize {\n    fn from(val: NonNullary) -> isize {\n        match val {\n            NonNullary::Nullary => 0,\n            NonNullary::Other(i) => i,\n        }\n    }\n}\n\nfn main() {\n    let v = NonNullary::Nullary;\n    let val = v as isize; // E0605: non-primitive cast: `NonNullary` as `isize`\n}",
        "instruction": "Demonstrates defining an enum, implementing a trait for conversion, and attempting a non-primitive cast in Rust, which leads to a compilation error."
    },
    {
        "output": "The Rust code defines a function 'inner' that takes a String 'dummy' and a boolean 'b' as parameters. If 'b' is true, the function recursively calls itself with 'dummy' and false as arguments. The main function then calls 'inner' with the initial values 'hi' and true.",
        "input": "fn inner(dummy: String, b: bool) { if b { return inner(dummy, false); } }fn main() { inner(\"hi\".to_string(), true); }",
        "instruction": "Demonstrates recursive function calls in Rust, where the function 'inner' conditionally calls itself with different arguments based on the boolean parameter 'b'."
    },
    {
        "output": "Prints 'evenk', the value of n, 'oddk', and the respective value of n for each function call",
        "input": "fn main() { let k = checktrue; evenk(42, k); oddk(45, k); }fn evenk(n: isize, k: fn(bool) -> bool) -> bool {    println!(\"evenk\");    println!(\"{}\", n);    if n == 0 { return k(true); } else { return oddk(n - 1, k); }}fn oddk(n: isize, k: fn(bool) -> bool) -> bool {    println!(\"oddk\");    println!(\"{}\", n);    if n == 0 { return k(false); } else { return evenk(n - 1, k); }}fn checktrue(rs: bool) -> bool { assert!(rs); return true; }",
        "instruction": "Defines two functions 'evenk' and 'oddk' that recursively call each other based on the parity of the input number 'n', and prints the function name and 'n' value during each call."
    },
    {
        "output": "Calls function f which returns an isize, which in turn calls function g that returns a usize. The code then assigns the result of function f to variable y in the main function.",
        "input": "fn f() -> isize { return g() as isize; } fn g() -> usize { return 0; } fn main() { let y = f(); }",
        "instruction": "The code demonstrates function calls and type conversions in Rust. It shows how functions can return different types and how type conversions can be applied to match expected return types."
    },
    {
        "output": "Defines multiple Rust structures, an enum, and a function. Invokes various methods and operations on these defined types.",
        "input": "fn f<T,>(_: T,) {}\nstruct Foo<T,>(#[allow(dead_code)] T);\nstruct Bar;\nimpl Bar {\n    fn f(_: isize,) {}\n    fn g(self, _: isize,) {}\n    fn h(self) {}\n}\nenum Baz {\n    Qux(#[allow(dead_code)] isize,)\n}\n#[allow(unused,)]\npub fn main() {\n    f::<isize,>(0,);\n    let (_, _,) = (1, 1,);\n    let [_, _,] = [1, 1,];\n    let [_, _, .., _,] = [1, 1, 1, 1,];\n    let [_, _, _, ..,] = [1, 1, 1, 1,];\n    let x: Foo<isize,> = Foo::<isize,>(1);\n    Bar::f(0,);\n    Bar.g(0,);\n    Bar.h();\n    let x = Baz::Qux(1,);\n}",
        "instruction": "Defines generic function, structures, enum, and methods. Demonstrates method invocation and pattern matching in Rust."
    },
    {
        "output": "Defines a trait 'Foo' with a method 'foo' that takes two i32 parameters and returns an i32. Implements the trait 'Foo' for the i32 type.",
        "input": "trait Foo { fn foo(&mut self, x: i32, y: i32) -> i32; } impl Foo for i32 { fn foo(&mut self, x: i32, y: i32) -> i32 { *self } } fn main() {}",
        "instruction": "Declares a trait 'Foo' with a method 'foo' that takes two i32 parameters and returns a value of type i32. The trait 'Foo' is then implemented for the i32 type by defining the method 'foo' to return the value of 'self'."
    },
    {
        "output": "Defines an unsafe function 'noop' that takes a type 'F' implementing 'Foo', extracts 'F::Bar' from 'foo', and returns it after transmuting the value",
        "input": "//@ check-passtrait Foo {    type Bar;}unsafe fn noop<F: Foo>(foo: F::Bar) -> F::Bar {    ::std::mem::transmute(foo)}fn main() {}",
        "instruction": "Demonstrates the use of generics, associated types, and unsafe code in Rust. The function 'noop' transmutes the input type 'foo' to 'F::Bar' and returns it."
    },
    {
        "output": "Transmutes a single-element array of isize to isize",
        "input": "fn main() { unsafe { ::std::mem::transmute::<[isize; 1], isize>([1]) }; }",
        "instruction": "The code uses unsafe Rust to perform a transmutation, converting a single-element array of isize to a single isize value. This operation is unsafe and should be used with caution due to potential memory layout and type system violations."
    },
    {
        "output": "Demonstrates various type coercions in Rust including numeric, pointer, array, trait, and function conversions",
        "input": "trait Foo { fn foo(&self) {} } pub struct Bar; impl Foo for Bar {} pub fn main() { let _ = 42_i32 as i32; let _ = 42_u8 as u8; let x: &u32 = &42; let _ = x as *const u32; let x: &mut u32 = &mut 42; let _ = x as *mut u32; let x: &[u32; 3] = &[42, 43, 44]; let _ = x as &[u32]; let _ = x as *const [u32]; let x: &mut [u32; 3] = &mut [42, 43, 44]; let _ = x as &mut [u32]; let _ = x as *mut [u32]; let x: Box<[u32; 3]> = Box::new([42, 43, 44]); let _ = x as Box<[u32]>; let x: &Bar = &Bar; let _ = x as &dyn Foo; let _ = x as *const dyn Foo; let x: &mut Bar = &mut Bar; let _ = x as &mut dyn Foo; let _ = x as *mut dyn Foo; let x: Box<Bar> = Box::new(Bar); let _ = x as Box<dyn Foo); fn baz(_x: i32) {} let _ = &baz as &dyn Fn(i32); let x = |_x: i32| {}; let _ = &x as &dyn Fn(i32); } pub fn test_subtyping<'a, 'b: 'a>(a: &'a Bar, b: &'b Bar) { let _ = a as &'a Bar; let _ = b as &'a Bar; let _ = b as &'b Bar; }",
        "instruction": "The code showcases different type coercions in Rust such as numeric conversions, pointer conversions, array conversions, trait object conversions, and function conversions. It also includes an example of subtyping in Rust."
    },
    {
        "output": "Checks if converting an unsigned 32-bit integer to an unsigned 8-bit integer is successful",
        "input": "fn main() {\n    let x: u32 = 125;\n    let y: Result<u8, TryFromIntError> = u8::try_from(x);\n    y == Ok(125);\n}",
        "instruction": "The code demonstrates the use of the TryFrom trait to convert a u32 integer to a u8 integer, then checks if the conversion result is equal to Ok(125)."
    },
    {
        "output": "The code defines a function named parse that attempts to parse the string '1' as an integer and returns the result. It also includes two constants, val with the value 'a' and err with the value 'b'. The main function asserts that the result of calling parse is Ok(1), indicating a successful parsing of the string '1' to an integer.",
        "input": "fn main() {\n    assert_eq!(parse(), Ok(1));\n}\n\nfn parse() -> Result<i32, ParseIntError> {\n    const val: char = 'a';\n    const err: char = 'b';\n    Ok(\"1\".parse::<i32>()?)\n}",
        "instruction": "The code demonstrates the use of constants in Rust and error handling with the Result type. It shows parsing a string to an integer and returning a Result with either the parsed integer or a ParseIntError."
    },
    {
        "output": "The Rust code defines multiple functions that demonstrate different ways of handling errors when parsing integers from strings and manipulating the parsed values.",
        "input": "fn on_method() -> Result<i32, ParseIntError> {    Ok(\"1\".parse::<i32>()? + \"2\".parse::<i32>()?)}fn in_chain() -> Result<String, ParseIntError> {    Ok(\"3\".parse::<i32>()?.to_string())}fn on_call() -> Result<i32, ParseIntError> {    fn parse<T: FromStr>(s: &str) -> Result<T, T::Err> {        s.parse()    }    Ok(parse(\"4\")?)}fn nested() -> Result<i32, ParseIntError> {    Ok(\"5\".parse::<i32>()?.to_string().parse()?)}fn on_path() -> Result<i32, ParseIntError> {    let x = \"6\".parse::<i32>();    Ok(x?)}fn on_macro() -> Result<i32, ParseIntError> {    macro_rules! id {        ($e:expr) => { $e }    }    Ok(id!(\"7\".parse::<i32>())?)}fn on_parens() -> Result<i32, ParseIntError> {    let x = \"8\".parse::<i32>();    Ok((x)?)}fn on_block() -> Result<i32, ParseIntError> {    let x = \"9\".parse::<i32>();    Ok({x}?)}fn on_field() -> Result<i32, ParseIntError> {    struct Pair<A, B> { a: A, b: B }    let x = Pair { a: \"10\".parse::<i32>(), b: 0 };    Ok(x.a?)}fn on_tuple_field() -> Result<i32, ParseIntError> {    let x = (\"11\".parse::<i32>(), 0);    Ok(x.0?)}fn on_try() -> Result<i32, ParseIntError> {    let x = \"12\".parse::<i32>().map(|i| i.to_string().parse::<i32>());    Ok(x??)}fn on_binary_op() -> Result<i32, ParseIntError> {    let x = 13 - \"14\".parse::<i32>()?;    let y = \"15\".parse::<i32>()? - 16;    let z = \"17\".parse::<i32>()? - \"18\".parse::<i32>()?;    Ok(x + y + z)}fn on_index() -> Result<i32, ParseIntError> {    let x = [19];    let y = \"0\".parse::<usize>();    Ok(x[y?])}fn on_args() -> Result<i32, ParseIntError> {    fn sub(x: i32, y: i32) -> i32 { x - y }    let x = \"20\".parse();    let y = \"21\".parse();    Ok(sub(x?, y?))}fn on_if() -> Result<i32, ParseIntError> {    Ok(if true {        \"22\".parse::<i32>()    } else {        \"23\".parse::<i32>()    }?)}fn on_if_let() -> Result<i32, ParseIntError> {    Ok(if let Ok(..) = \"24\".parse::<i32>() {        \"25\".parse::<i32>()    } else {        \"26\".parse::<i32>()    }?)}fn on_match() -> Result<i32, ParseIntError> {    Ok(match \"27\".parse::<i32>() {        Err(..) => \"28\".parse::<i32>(),        Ok(..) => \"29\".parse::<i32>(),    }?)}fn tight_binding() -> Result<bool, ()> {    fn ok<T>(x: T) -> Result<T, ()> { Ok(x) }    let x = ok(true);    Ok(!x?)}fn merge_error() -> Result<i32, Error> {    let mut s = String::new();    File::open(\"foo.txt\")?.read_to_string(&mut s)?;    Ok(s.parse::<i32>()? + 1)}",
        "instruction": "The code showcases various error handling techniques when parsing integers from strings and manipulating the parsed values. Each function demonstrates a different scenario, such as using macros, blocks, tuples, binary operations, if statements, and matching patterns."
    },
    {
        "output": "The code defines a generic struct Foo with a single field x. In the main function, it asserts that the type name of isize is 'isize' and the type name of Foo<usize> is 'tydesc_name::Foo<usize>'.",
        "input": "use std::any::type_name;struct Foo<T> { x: T } pub fn main() { assert_eq!(type_name::<isize>(), \"isize\"); assert_eq!(type_name::<Foo<usize>>(), \"tydesc_name::Foo<usize>\"); }",
        "instruction": "Defining a generic struct and using the type_name function to check type names in Rust."
    },
    {
        "output": "Demonstrates handling lifetimes and type conversions in Rust",
        "input": "fn main() {    use std::any::Any;    struct Foo<'a>(&'a str);    fn good(s: &String) -> Foo { Foo(s) }    fn bad1(s: String) -> Option<&'static str> {        let a: Box<dyn Any> = Box::new(good as fn(&String) -> Foo);        a.downcast_ref::<fn(&String) -> Foo<'static>>().map(|f| f(&s).0)    }    trait AsStr<'a, 'b> {        fn get(&'a self) -> &'b str;    }    impl<'a> AsStr<'a, 'a> for String {        fn get(&'a self) -> &'a str { self }    }    fn bad2(s: String) -> Option<&'static str> {        let a: Box<dyn Any> = Box::new(Box::new(s) as Box<dyn for<'a> AsStr<'a, 'a>>);        a.downcast_ref::<Box<dyn for<'a> AsStr<'a, 'static>>>().map(|x| x.get())    }    assert_eq!(bad1(String::from(\"foo\")), None);    assert_eq!(bad2(String::from(\"bar\")), None);}",
        "instruction": "The code defines a struct, functions, and traits to handle lifetimes and type conversions. It demonstrates using trait objects and downcasting in Rust."
    },
    {
        "output": "Defines a struct named A with a single field 'a' of type isize. Defines a function a that takes an instance of struct A as input and returns the value of field 'a'. In the main function, creates an instance x of struct A with 'a' value of 1, then asserts that calling function a with x as argument returns 1.",
        "input": "struct A { a: isize }\n\nfn a(a: A) -> isize { return a.a; }\n\npub fn main() {\n    let x: A = A { a: 1 };\n    assert_eq!(a(x), 1);\n}",
        "instruction": "Illustrates defining a struct, passing a struct as a function argument, and using assert_eq macro for testing in Rust."
    },
    {
        "output": "Defines functions that take different types of arguments and do nothing with them",
        "input": "//@ run-pass\n#![allow(non_camel_case_types)]\n#![allow(dead_code)]\nfn p_foo<T>(_pinned: T) { }\nfn s_foo<T>(_shared: T) { }\nfn u_foo<T: Send>(_unique: T) { }\nstruct r { i: isize, }\nimpl Drop for r { fn drop(&mut self) { }}\nfn r(i: isize) -> r { r { i: i }}\npub fn main() { p_foo(r(10)); p_foo::<Box<_>>(Box::new(r(10))); p_foo::<Box<_>>(Box::new(10)); p_foo(10); s_foo::<Box<_>>(Box::new(10)); s_foo(10); u_foo::<Box<_>>(Box::new(10)); u_foo(10); }",
        "instruction": "Defines functions that take different types of arguments but do nothing with them. Demonstrates the use of generic functions with trait bounds in Rust."
    },
    {
        "output": "Defines a generic type 'lteq' that represents a function pointer taking a value of type T and returning a boolean. The function pointer is defined as an external function using the 'extern C' ABI calling convention.",
        "input": "type lteq<T> = extern \"C\" fn(T) -> bool; pub fn main() { }",
        "instruction": "The code demonstrates the definition of a generic type 'lteq' representing a function pointer in Rust. It showcases the usage of 'extern C' for defining functions with C ABI and defining function pointers."
    },
    {
        "output": "Defines two functions that take a raw pointer as an argument and return a raw pointer",
        "input": "fn f(a: *const isize) -> *const isize { return a; }fn g(a: *const isize) -> *const isize { let b = f(a); return b; }",
        "instruction": "The code demonstrates the usage of raw pointers in Rust, where one function takes a raw pointer as an argument and returns it, and another function calls the first function and returns the result."
    },
    {
        "output": "Writes a value to a mutable reference using unsafe code",
        "input": "fn main() { unsafe { let mut x: bool = false; std::ptr::write(&mut x, false); }}",
        "instruction": "The code demonstrates the use of unsafe Rust to write a value to a mutable reference. The function ptr::write is used to write the value false to the mutable reference x in an unsafe block."
    },
    {
        "output": "Defines a macro that creates type aliases for tuples of the same type recursively.",
        "input": "macro_rules! link {    ($id:ident, $t:ty) => {        pub type $id = ($t, $t, $t);    }}link! { A1, B1 }link! { B1, C1 }link! { C1, D1 }link! { D1, E1 }link! { E1, A }link! { A, B }link! { B, C }link! { C, D }link! { D, E }link! { E, F }link! { F, G<Option<i32>, Option<i32>> }",
        "instruction": "The macro `link` creates type aliases for tuples of the same type. This code demonstrates creating a chain of type aliases and ends with a struct definition using PhantomData for type erasure."
    },
    {
        "output": "The code performs various TypeId comparisons and function pointer checks",
        "input": "fn main() {\n    assert_eq!(TypeId::of::<other1::A>(), other1::id_A());\n    assert_eq!(TypeId::of::<other1::B>(), other1::id_B());\n    assert_eq!(TypeId::of::<other1::C>(), other1::id_C());\n    assert_eq!(TypeId::of::<other1::D>(), other1::id_D());\n    assert_eq!(TypeId::of::<other1::E>(), other1::id_E());\n    assert_eq!(TypeId::of::<other1::F>(), other1::id_F());\n    assert_eq!(TypeId::of::<other1::G>(), other1::id_G());\n    assert_eq!(TypeId::of::<other1::H>(), other1::id_H());\n    assert_eq!(TypeId::of::<other1::I>(), other1::id_I());\n    assert_eq!(TypeId::of::<other2::A>(), other2::id_A());\n    assert_eq!(TypeId::of::<other2::B>(), other2::id_B());\n    assert_eq!(TypeId::of::<other2::C>(), other2::id_C());\n    assert_eq!(TypeId::of::<other2::D>(), other2::id_D());\n    assert_eq!(TypeId::of::<other2::E>(), other2::id_E());\n    assert_eq!(TypeId::of::<other2::F>(), other2::id_F());\n    assert_eq!(TypeId::of::<other2::G>(), other2::id_G());\n    assert_eq!(TypeId::of::<other2::H>(), other2::id_H());\n    assert_eq!(TypeId::of::<other1::I>(), other2::id_I());\n    assert_eq!(other1::id_F(), other2::id_F());\n    assert_eq!(other1::id_G(), other2::id_G());\n    assert_eq!(other1::id_H(), other2::id_H());\n    assert_eq!(other1::id_I(), other2::id_I());\n    assert_eq!(TypeId::of::<isize>(), other2::foo::<isize>());\n    assert_eq!(TypeId::of::<isize>(), other1::foo::<isize>());\n    assert_eq!(other2::foo::<isize>(), other1::foo::<isize>());\n    assert_eq!(TypeId::of::<A>(), other2::foo::<A>());\n    assert_eq!(TypeId::of::<A>(), other1::foo::<A>());\n    assert_eq!(other2::foo::<A>(), other1::foo::<A>());\n    let (a, b, c) = (TypeId::of::<usize>(), TypeId::of::<&'static str>(), TypeId::of::<Test>());\n    let (d, e, f) = (TypeId::of::<usize>(), TypeId::of::<&'static str>(), TypeId::of::<Test>());\n    assert!(a != b);\n    assert!(a != c);\n    assert!(b != c);\n    assert_eq!(a, d);\n    assert_eq!(b, e);\n    assert_eq!(c, f);\n    let (a, b) = (TypeId::of::<usize>(), TypeId::of::<usize>());\n    let mut s1 = SipHasher::new();\n    a.hash(&mut s1);\n    let mut s2 = SipHasher::new();\n    b.hash(&mut s2);\n    assert_eq!(s1.finish(), s2.finish());\n    assert_eq!(TypeId::of::<other1::I32Iterator>(), other1::id_i32_iterator());\n    assert_eq!(TypeId::of::<other1::U32Iterator>(), other1::id_u32_iterator());\n    assert_eq!(other1::id_i32_iterator(), other2::id_i32_iterator());\n    assert_eq!(other1::id_u32_iterator(), other2::id_u32_iterator());\n    assert_ne!(other1::id_i32_iterator(), other1::id_u32_iterator());\n    assert_ne!(TypeId::of::<other1::I32Iterator>(), TypeId::of::<other1::U32Iterator>());\n    assert_ne!(TypeId::of::<fn(fn(A) -> A) -> A>(), TypeId::of::<fn(fn() -> A, A) -> A>());\n    assert_ne!(TypeId::of::<for<'a> fn(&'a i32) -> &'a i32>(), TypeId::of::<for<'a> fn(&'a i32) -> &'static i32>());\n    assert_ne!(TypeId::of::<for<'a, 'b> fn(&'a i32, &'b i32) -> &'a i32>(), TypeId::of::<for<'a, 'b> fn(&'b i32, &'a i32) -> &'a i32>());\n}",
        "instruction": "The code demonstrates TypeId comparisons, function pointer checks, and hash calculations in Rust, ensuring the correctness of TypeId mappings and function pointer collisions."
    },
    {
        "output": "Defines two variables x and y with values 10 and 20 respectively, then adds them together and stores the result in variable z. Finally, it asserts that z is equal to 30.",
        "input": "fn main() { let (x, y) = (10, 20); let z = x + y; assert_eq!(z, 30); }",
        "instruction": "Declares variables, performs addition, and uses an assertion to check the result in Rust."
    },
    {
        "output": "The code attempts to use the `None` value in a context where type annotations are missing, leading to a compilation error.",
        "input": "fn main() { let _ = None; }",
        "instruction": "The fixed code initializes a variable with the value `None` to demonstrate using the `None` option in Rust."
    },
    {
        "output": "Defines a struct `S` that holds a reference to an `Option` of any type. Attempts to create an instance of `S` with a reference to `None`, triggering a compilation error due to missing type annotations.",
        "input": "struct S<'a, T: 'a> { o: &'a Option<T> } fn main() { S { o: &None }; }",
        "instruction": "Demonstrates defining a generic struct `S` in Rust that holds a reference to an `Option` of any type, showcasing the necessity of providing type annotations to resolve compilation errors."
    },
    {
        "output": "The Rust code defines a macro called 'identity' that takes an identifier and returns the same identifier. It then tries to use the macro to assign the value 10 to an identifier, but encounters an error due to using the reserved identifier '_'.",
        "input": "macro_rules! identity { ($i: ident) => ( $i ) } fn main() { let identity!(x) = 10; //~ ERROR no rules expected reserved identifier '_' }",
        "instruction": "This code showcases the creation and usage of a simple macro in Rust. It demonstrates how macros can be used to perform pattern matching and code generation at compile time."
    },
    {
        "output": "Defines multiple functions and a struct in Rust, creates instances of the struct, and calls the functions with references",
        "input": "fn main() {\n    struct Foo<'a>(&'a u8);\n    fn foo(x: &u8) -> Foo<'_> {\n        Foo(x)\n    }\n    fn foo2(x: &u8) -> Foo<'_> {\n        Foo(x)\n    }\n    fn foo3(x: &u8) -> Foo {\n        Foo(x)\n    }\n    fn foo4(_: Foo<'_>) {}\n    struct Foo2<'a, 'b> {\n        a: &'a u8,\n        b: &'b u8,\n    }\n    fn foo5<'b>(foo: Foo2<'_, 'b>) -> &'b u8 {\n        foo.b\n    }\n    let x = &5;\n    let _ = foo(x);\n    let _ = foo2(x);\n    let _ = foo3(x);\n    foo4(Foo(x));\n    let _ = foo5(Foo2 {\n        a: x,\n        b: &6,\n    });\n}",
        "instruction": "The code defines multiple functions, a struct `Foo`, and a generic struct `Foo2` with references. It then creates instances of `Foo` and `Foo2`, passing references and calling the functions with these instances."
    },
    {
        "output": "Calls the method '_method_on_numbers' on the integer 42",
        "input": "trait Tr : Sized { fn _method_on_numbers(self) {} } impl Tr for i32 {} fn main() { 42._method_on_numbers(); }",
        "instruction": "Defines a trait 'Tr' with a method '_method_on_numbers' that takes 'self' as a parameter, implements the trait for the type i32, and calls the method on the integer 42 in the main function."
    },
    {
        "output": "Defines a trait 'Foo' with a function 'foo' and implements it for an empty array of size 1. Calls the 'foo' function associated with the implemented trait for an empty array of size 0 in the main function, causing a compilation error E0277.",
        "input": "trait Foo { fn foo(); } impl Foo for [(); 1] { fn foo() {} } fn main() { <[(); 0] as Foo>::foo() }",
        "instruction": "Demonstrates defining a trait, implementing the trait for a specific type, and invoking the trait function, leading to a compile-time error due to an associated function not being implemented for a different type."
    },
    {
        "output": "Uses the `MaybeUninit` and `uninitialized` constructs to create uninitialized instances of `Foo` and arrays of `Foo`.",
        "input": "fn main() {\n    unsafe {\n        // `Foo` and `[Foo; 2]` are both zero sized and inhabited, so this is safe.\n        let _x: Foo = MaybeUninit::uninit().assume_init();\n        let _x: [Foo; 2] = MaybeUninit::uninit().assume_init();\n        let _x: Foo = std::mem::uninitialized();\n        let _x: [Foo; 2] = std::mem::uninitialized();\n    }\n}",
        "instruction": "Uses unsafe Rust code to demonstrate creating uninitialized instances of `Foo` and arrays of `Foo` using `MaybeUninit` and `uninitialized` constructs."
    },
    {
        "output": "Defines a function 'f' that takes a unit type input and returns it. Initializes variables 'u1' and 'u2' with unit type values, calls function 'f' with 'u1', updates 'u2' to a unit value, and returns a unit value from the main function.",
        "input": "fn f(u: ()) -> () { u } fn main() { let u1: () = (); let mut u2: () = f(u1); u2 = (); }",
        "instruction": "Demonstrates defining a function that takes and returns a unit type, variable initialization with unit values, function call, and variable update in Rust."
    },
    {
        "output": "Defines a Rust function 'bar' that returns a never type '!' and contains an infinite loop",
        "input": "#![allow(unused)]\nfn bar() -> ! {\n    loop {}\n}\nfn main() {}",
        "instruction": "The code defines a function 'bar' that returns a never type '!' and contains an infinite loop. The 'bar' function will never return a value, hence the '!' type, indicating that the function does not produce a normal result."
    },
    {
        "output": "Defines an empty main function",
        "input": "fn main() {}",
        "instruction": "This Rust code snippet contains the main function, which serves as the entry point for the program. In this case, the main function is empty, indicating that there is no specific functionality defined within it."
    },
    {
        "output": "Calls the function 'called' with the function 'good' as an argument",
        "input": "fn good(_a: &isize) {}\nfn called<F>(_f: F) where F: FnOnce(&isize) {}\npub fn main() {\n    called(good);\n}",
        "instruction": "Defines two functions 'good' and 'called', where 'good' takes a reference to an isize as an argument. The 'main' function calls 'called' with 'good' as an argument, passing a reference to an isize."
    },
    {
        "output": "The code defines a function 'id' that takes a boolean input and returns the same boolean value. It then defines a function 'call_id' that panics when called and tries to pass the result to the 'id' function, which is not possible due to the panic. Lastly, 'call_id_3' attempts to use the 'return' keyword as a function call argument, which is invalid in Rust syntax.",
        "input": "fn id(x: bool) -> bool { x }fn call_id() { let c = panic!(); id(c); }fn call_id_3() { id(return) && id(return); }pub fn main() {}",
        "instruction": "The code demonstrates function definitions, panic macro usage, and invalid syntax with the 'return' keyword in function argument passing."
    },
    {
        "output": "Defines several functions and a main function with no functionality",
        "input": "fn id(x: bool) -> bool { x }fn call_id() { let c = panic!(); id(c); }fn call_id_2() { id(true) && id(return); }fn call_id_3() { id(return) && id(return); }fn ret_guard() { match 2 { x if (return) => { x; } x if let true = return => { x; } _ => {} }}pub fn main() {}",
        "instruction": "Defines multiple functions demonstrating Rust function syntax and control flow structures like match expressions and if let guards. However, some code snippets might not compile due to unreachable code or incorrect usage of return in expressions."
    },
    {
        "output": "Defines a Rust module that uses unsafe fields, demonstrates accessing, setting, and destructuring unsafe fields in a struct",
        "input": "extern crate unsafe_fields_crate_dep;use unsafe_fields_crate_dep::WithUnsafeField;fn new_without_unsafe() -> WithUnsafeField {    WithUnsafeField {        unsafe_field: 0,        safe_field: 0,    }}fn operate_on_safe_field(s: &mut WithUnsafeField) {    s.safe_field = 2;    &s.safe_field;    s.safe_field;}fn set_unsafe_field(s: &mut WithUnsafeField) {    unsafe {        s.unsafe_field = 2;    }}fn read_unsafe_field(s: &WithUnsafeField) -> u32 {    unsafe { s.unsafe_field }}fn ref_unsafe_field(s: &WithUnsafeField) -> &u32 {    unsafe { &s.unsafe_field }}fn destructure(s: &WithUnsafeField) {    unsafe {        let WithUnsafeField { safe_field, unsafe_field } = s;    }}fn set_unsafe_field_without_unsafe(s: &mut WithUnsafeField) {    s.unsafe_field = 2;    //~^ ERROR}fn read_unsafe_field_without_unsafe(s: &WithUnsafeField) -> u32 {    s.unsafe_field    //~^ ERROR}fn ref_unsafe_field_without_unsafe(s: &WithUnsafeField) -> &u32 {    &s.unsafe_field    //~^ ERROR}fn destructure_without_unsafe(s: &WithUnsafeField) {    let WithUnsafeField { safe_field, unsafe_field } = s;    //~^ ERROR    let WithUnsafeField { safe_field, .. } = s;}",
        "instruction": "The code defines functions that interact with a struct containing both safe and unsafe fields. It showcases how to work with unsafe fields by setting, reading, and destructuring them, both with and without using the 'unsafe' keyword."
    },
    {
        "output": "Defines an enum `A` with a variant `TupleLike` that takes an unsafe unsigned 32-bit integer as a parameter and a struct `B` that contains an unsafe unsigned 32-bit integer field.",
        "input": "#![allow(incomplete_features)]\n#![feature(unsafe_fields)]\n\nenum A {\n    TupleLike(unsafe u32),\n}\n\nstruct B(unsafe u32);",
        "instruction": "The code demonstrates defining an enum variant and a struct with fields marked as unsafe in Rust."
    },
    {
        "output": "Defines a struct containing unsafe and safe fields, an enum variant using the struct, and various methods to interact with the fields including unsafe operations.",
        "input": "#![allow(incomplete_features)]\n#![feature(unsafe_fields)]\n\nstruct WithUnsafeField {\n    unsafe unsafe_field: u32,\n    safe_field: u32,\n}\n\nenum A {\n    WithUnsafeField {\n        unsafe unsafe_field: u32,\n        safe_field: u32,\n    },\n}\n\nimpl WithUnsafeField {\n    fn new() -> WithUnsafeField {\n        unsafe {\n            WithUnsafeField {\n                unsafe_field: 0,\n                safe_field: 0,\n            }\n        }\n    }\n\n    fn operate_on_safe_field(&mut self) {\n        self.safe_field = 2;\n        &self.safe_field;\n        self.safe_field;\n    }\n\n    fn set_unsafe_field(&mut self) {\n        unsafe {\n            self.unsafe_field = 2;\n        }\n    }\n\n    fn read_unsafe_field(&self) -> u32 {\n        unsafe {\n            self.unsafe_field\n        }\n    }\n\n    fn ref_unsafe_field(&self) -> &u32 {\n        unsafe {\n            &self.unsafe_field\n        }\n    }\n\n    fn destructure(&self) {\n        unsafe {\n            let Self { safe_field, unsafe_field } = self;\n        }\n    }\n\n    fn offset_of(&self) -> usize {\n        std::mem::offset_of!(WithUnsafeField, unsafe_field)\n    }\n\n    fn raw_const(&self) -> *const u32 {\n        &raw const self.unsafe_field\n    }\n}",
        "instruction": "Defines a struct with safe and unsafe fields, an enum using the struct, and methods showcasing interactions with these fields including unsafe operations like raw pointers."
    },
    {
        "output": "Declares a variable 'x' with a value that causes a compilation error due to applying a unary operator '-' on an unsigned integer type",
        "input": "fn main() { let x: u32 = -1; }",
        "instruction": "The code attempts to assign a negative value to an unsigned 32-bit integer variable 'x', which is not allowed in Rust, resulting in a compilation error."
    },
    {
        "output": "Creates a boxed value containing the integer 1 and then defines a closure that takes no arguments and does nothing. Finally, the closure is called.",
        "input": "fn main() { let _x: Box<_> = Box::new(1); let lam_move = || {}; lam_move(); }",
        "instruction": "Declares a boxed value holding an integer and demonstrates the creation and invocation of a simple closure in Rust."
    },
    {
        "output": "Illustrates using a custom macro to generate print statements for variables of different types.",
        "input": "macro_rules! print_var { ($var:expr) => { println!(\"Value: {:?}\", $var); } }fn main() { let num = 42; let name = \"Alice\"; print_var!(num); print_var!(name); }",
        "instruction": "Define a custom macro `print_var` that prints the value of any expression using `println!`. Demonstrate its usage with different variable types."
    },
    {
        "output": "Demonstrates using a closure to multiply a vector of integers by a constant factor.",
        "input": "fn main() { let multiplier = 5; let multiply = |x: &mut i32| *x *= multiplier; let mut numbers = vec![1, 2, 3, 4]; for num in numbers.iter_mut() { multiply(num); } println!(\"Multiplied numbers: {:?}\", numbers); }",
        "instruction": "Create a closure named `multiply` that multiplies a mutable reference to an integer by a constant. Apply this closure to a vector of integers and print the modified vector."
    },
    {
        "output": "Illustrates error handling with Result type, showing how to open a file and read its contents.",
        "input": "use std::fs::File; use std::io::prelude::*;fn main() { let mut file = File::open(\"example.txt\").expect(\"File not found\"); let mut contents = String::new(); file.read_to_string(&mut contents).expect(\"Error reading the file\"); println!(\"File content: {:?}\", contents); }",
        "instruction": "Import necessary file I/O traits, open a file, read its content into a string, and print the content. Handle errors using Result type and unwrap for simplicity."
    },
    {
        "output": "Demonstrates error handling with Result by parsing a string into an integer and handling the potential error.",
        "input": "fn main() { let num_str = \"10\"; let num: Result<i32, _> = num_str.parse(); match num { Ok(val) => println!(\"Parsed number: {}\", val), Err(_) => println!(\"Failed to parse number\"); } }",
        "instruction": "Parse a string into an integer using Result and handle the success or failure case accordingly."
    },
    {
        "output": "Illustrates ownership and borrowing with functions taking ownership of input parameters and returning modified data.",
        "input": "fn double_value(mut val: i32) -> i32 { val *= 2; val } fn main() { let num = 5; let doubled_num = double_value(num); println!(\"Doubled value: {}\", doubled_num); }",
        "instruction": "Create a function that takes ownership of an integer parameter, modifies it, and returns the updated value."
    },
    {
        "output": "Shows the use of custom macros to simplify and automate logging with different log levels.",
        "input": "macro_rules! log { ($lvl:expr, $msg:expr) => (println!(\"[{}] {}\", $lvl, $msg)); } fn main() { log!(\"INFO\", \"This is an informational message\"); log!(\"ERROR\", \"An error occurred\"); }",
        "instruction": "Define a macro that takes a log level and message to generate formatted log entries and use it for logging different messages."
    },
    {
        "output": "Demonstrates error handling using Result enum and the expect method to handle potential errors.",
        "input": "fn divide(a: f32, b: f32) -> f32 { if b == 0.0 { return Err(\"Cannot divide by zero\").unwrap_err(); } a / b } fn main() { let result = divide(10.0, 2.0); println!(\"Result: {:?}\", result); }",
        "instruction": "Define a function that returns a Result to handle potential division by zero error using the expect method."
    },
    {
        "output": "Illustrates a trait implementation with a default method.",
        "input": "trait Greeting { fn greet(&self) -> String; fn default_greeting(&self) -> String { format!(\"Hello, Rustacean!\") } } struct Person; impl Greeting for Person { fn greet(&self) -> String { format!(\"Hello!\") } } fn main() { let person = Person; println!(\"{}\n{}\", person.greet(), person.default_greeting()); }",
        "instruction": "Create a trait with a method and a default method, implement the trait for a struct, and call both methods on an instance."
    },
    {
        "output": "Shows the implementation of a custom macro for basic arithmetic operations.",
        "input": "macro_rules! arithmetic { ($x:expr, $y:expr) => { ($x + $y, $x - $y, $x * $y, $x / $y) }; } fn main() { let values = arithmetic!(10, 2); println!(\"Add: {}, Subtract: {}, Multiply: {}, Divide: {}\", values.0, values.1, values.2, values.3); }",
        "instruction": "Define a custom macro using macro_rules! to perform basic arithmetic operations and print the results in a main function."
    },
    {
        "output": "Defines a struct called `Point` with x and y coordinates and implements a method to calculate the distance from the origin.",
        "input": "struct Point { x: f64, y: f64 } impl Point { fn distance_from_origin(&self) -> f64 { (self.x.powi(2) + self.y.powi(2)).sqrt() } } fn main() { let p = Point { x: 3.0, y: 4.0 }; println!(\"Distance from origin: {}\", p.distance_from_origin()); }",
        "instruction": "Create a struct to represent a point in 2D space and a method to calculate its distance from the origin."
    },
    {
        "output": "Demonstrates a custom error type `MyError` and error handling using the `Result` enum with the `?` operator in a function.",
        "input": "use std::fs::File;use std::io::prelude::*;#[derive(Debug)] enum MyError { IoError(std::io::Error) } fn read_file() -> Result<String, MyError> { let mut file = File::open(\"example.txt\").map_err(MyError::IoError)?; let mut contents = String::new(); file.read_to_string(&mut contents).map_err(MyError::IoError)?; Ok(contents) }",
        "instruction": "Create a custom error type, use the Result enum with the ? operator for error propagation in a file reading function."
    },
    {
        "output": "Illustrates using an async function `fetch_data` with a GET request using reqwest crate to fetch data from a URL.",
        "input": "use reqwest::Error;async fn fetch_data() -> Result<(), Error> { let response = reqwest::get(\"https://jsonplaceholder.typicode.com/todos/1\").await?; println!(\"Response status: {}\", response.status()); Ok(()) }",
        "instruction": "Write an async function that fetches data from a URL using reqwest and handles potential errors in the process."
    },
    {
        "output": "Implements a custom iterator for a range of numbers and prints each number squared.",
        "input": "struct Squares(u32); impl Iterator for Squares { type Item = u32; fn next(&mut self) -> Option<Self::Item> { self.0 += 1; Some(self.0 * self.0) } } fn main() { let mut squares = Squares(0); for i in 0..5 { println!(\"{}\", squares.next().unwrap()); } }",
        "instruction": "Define a custom iterator struct that yields squared numbers and use it to print the squares of a range of values."
    },
    {
        "output": "Demonstrates error handling using Result and the unwrap method with panic.",
        "input": "fn potentially_error_fn(val: u32) -> Result<u32, &'static str> { if val < 10 { Ok(val) } else { Err(\"Value too large\") } } fn main() { let result = potentially_error_fn(5).unwrap(); println!(\"Result: {}\", result); }",
        "instruction": "Create a function that returns a Result type and uses unwrap to handle the potential error case by causing a panic."
    },
    {
        "output": "Illustrates ownership transfer with mutable borrowing through a simple swap function.",
        "input": "fn swap_values(vec: &mut Vec<i32>, i: usize, j: usize) { vec.swap(i, j); } fn main() { let mut numbers = vec![1, 2, 3]; swap_values(&mut numbers, 0, 2); println!(\"Swapped result: {:?}\", numbers); }",
        "instruction": "Define a function that swaps elements in a vector by borrowing them mutably, showing how ownership transfer works in Rust."
    },
    {
        "output": "Demonstrates a custom macro that prints 'Hello, World!' whenever invoked.",
        "input": "macro_rules! custom_macro { () => ( println!('Hello, World!'); ) } fn main() { custom_macro!(); }",
        "instruction": "Create and use a simple custom macro to print a message. Macros can reduce code duplication and improve code organization."
    },
    {
        "output": "Illustrates a simple ownership example where a string is borrowed and its length is printed.",
        "input": "fn main() { let my_string = String::from('Rust is awesome!'); let str_length = get_string_length(&my_string); println!(\"Length: {}\", str_length); } fn get_string_length(s: &String) -> usize { s.len() }",
        "instruction": "Explore ownership and borrowing in Rust by borrowing a string and calculating its length without taking ownership of the string."
    },
    {
        "output": "Defines an enum representing different types of shapes and uses match to print corresponding messages.",
        "input": "enum Shape { Circle, Square, Triangle } fn main() { let my_shape = Shape::Square; match my_shape { Shape::Circle => println!('This is a circle'), Shape::Square => println!('This is a square'), Shape::Triangle => println!('This is a triangle'), } }",
        "instruction": "Introduce enums and pattern matching in Rust to handle different cases efficiently. Enums are useful for representing different variants of a type."
    },
    {
        "output": "Demonstrates a custom macro that prints 'Hello, World!' when used.",
        "input": "macro_rules! hello_macro { () => { println!(\"Hello, World!\"); } } fn main() { hello_macro!(); }",
        "instruction": "Define a custom macro using `macro_rules!` that outputs a specific message when invoked."
    },
    {
        "output": "Illustrates a struct called 'Book' with an associated function to create a new instance.",
        "input": "struct Book { title: String, author: String } impl Book { fn new(title: &str, author: &str) -> Self { Book { title: title.to_string(), author: author.to_string() } } } fn main() { let book = Book::new(\"Rust Programming\", \"Jane Doe\"); println!(\"Book title: {}\", book.title); }",
        "instruction": "Define a struct 'Book' and implement a function to construct a new instance, showcasing struct usage."
    },
    {
        "output": "Utilizes an enum to represent different types of fruits and demonstrates pattern matching with 'match'.",
        "input": "enum Fruit { Apple, Banana, Mango } fn main() { let my_fruit = Fruit::Banana; match my_fruit { Fruit::Apple => println!(\"Selected fruit: Apple\"), Fruit::Banana => println!(\"Selected fruit: Banana\"), Fruit::Mango => println!(\"Selected fruit: Mango\") } }",
        "instruction": "Create an enum 'Fruit' with various variants and use 'match' to handle different cases in Rust."
    },
    {
        "output": "Creates a custom Result type to handle division, returning either the result or an error message.",
        "input": "struct DivisionError; fn divide(a: i32, b: i32) -> Result<i32, DivisionError> { if b == 0 { Err(DivisionError) } else { Ok(a / b) } } fn main() { match divide(10, 2) { Ok(result) => println!(\"Result: {}\", result), Err(_) => println!(\"Error: Cannot divide by zero\"), } }",
        "instruction": "Define a custom Result type for error handling in a division function and match on the result in main to print the division result or an error message."
    },
    {
        "output": "Illustrates the use of the async and await keywords to fetch data asynchronously from a URL.",
        "input": "use reqwest; async fn fetch_url(url: &str) -> Result<String, reqwest::Error> { reqwest::get(url).await?.text().await } #[tokio::main] async fn main() { match fetch_url(\"https://jsonplaceholder.typicode.com/posts/1\").await { Ok(response) => println!(\"Response: {}\", response), Err(e) => eprintln!(\"Error: {}\", e), } }",
        "instruction": "Demonstrate fetching data asynchronously from a URL using the reqwest crate, async/await keywords, and handling the result using match and error handling."
    },
    {
        "output": "Defines a generic function that finds the largest element in a slice of comparable elements.",
        "input": "fn find_largest<T: PartialOrd>(list: &[T]) -> Option<&T> { list.iter().max() } fn main() { let numbers = vec![3, 5, 2, 8, 1]; match find_largest(&numbers) { Some(largest) => println!(\"Largest: {}\", largest), None => println!(\"List is empty!\"), } }",
        "instruction": "Create a generic function to find the largest element in a slice and use Option to handle the case where the list is empty or non-comparable."
    },
    {
        "output": "Demonstrates a simple for loop iterating over a range of numbers and printing each number.",
        "input": "fn main() { for i in 0..5 { println!(\"Number: {}\", i); } }",
        "instruction": "Run a for loop over a range of numbers and display each number using println macro."
    },
    {
        "output": "Illustrates a custom enum type that represents different types of shapes and uses match to calculate their areas.",
        "input": "enum Shape { Circle(f64), Rectangle(f64, f64), Triangle(f64, f64) } fn calculate_area(shape: &Shape) -> f64 { match shape { Shape::Circle(radius) => 3.14 * radius * radius, Shape::Rectangle(width, height) => width * height, Shape::Triangle(base, height) => 0.5 * base * height, } } fn main() { let circle = Shape::Circle(3.0); println!(\"Area of the circle: {}\", calculate_area(&circle)); }",
        "instruction": "Define an enum for various shapes, implement a function to calculate their areas using match, and then calculate and display the area of a circle."
    },
    {
        "output": "Shows implementation of a simple trait 'Drawable' with a method 'draw' for multiple structs.",
        "input": "trait Drawable { fn draw(&self); } struct Circle { radius: f64 } struct Square { side: f64 } impl Drawable for Circle { fn draw(&self) { println!(\"Drawing a circle with radius: {}\", self.radius); } } impl Drawable for Square { fn draw(&self) { println!(\"Drawing a square with side: {}\", self.side); } } fn main() { let c = Circle { radius: 3.0 }; let s = Square { side: 2.5 }; c.draw(); s.draw(); }",
        "instruction": "Create a trait 'Drawable' with a draw method, implement it for multiple structs (Circle and Square), create instances of each type, and call the draw method on each instance."
    },
    {
        "output": "Demonstrates a simple loop that prints numbers from 1 to 5.",
        "input": "fn main() { for i in 1..=5 { println!(\"{}\", i); } }",
        "instruction": "This code showcases a basic for loop in Rust that iterates over a range to print numbers from 1 to 5."
    },
    {
        "output": "Illustrates an enum with variants and a function using match to handle different cases.",
        "input": "enum Direction { Up, Down, Left, Right } fn move_player(dir: Direction) { match dir { Direction::Up => println!(\"Moving Up\"), Direction::Down => println!(\"Moving Down\"), Direction::Left => println!(\"Moving Left\"), Direction::Right => println!(\"Moving Right\"), } }",
        "instruction": "Define an enum representing directions and implement a function that uses pattern matching (match) to handle each variant."
    },
    {
        "output": "Shows a generic function with trait bounds to find the maximum of two values.",
        "input": "fn find_max<T: PartialOrd>(a: T, b: T) -> T { if a > b { a } else { b } } fn main() { let max_num = find_max(10, 20); println!(\"Max: {}\", max_num); }",
        "instruction": "Create a generic function that finds the maximum of two values, showcasing the use of trait bounds to enable comparison (PartialOrd)."
    },
    {
        "output": "Demonstrates error handling with a custom Result enum to handle success or specific errors.",
        "input": "enum MyResult { Success(String), Error(String) } fn parse_input(input: &str) -> MyResult { if input == \"valid\" { MyResult::Success(String::from(\"Parsed successfully\")) } else { MyResult::Error(String::from(\"Invalid input\")) } }",
        "instruction": "Define a custom Result enum to handle parsing input with success or error cases and return the appropriate variant based on input validity."
    },
    {
        "output": "Illustrates a custom macro to simplify printing debugging information with line number and file name.",
        "input": "macro_rules! debug_print { () => (println!(\"File: {}, Line: {}\", file!(), line!())); } fn main() { debug_print!(); }",
        "instruction": "Create a custom macro 'debug_print' to print the current file name and line number usage, helpful for debugging and tracing code flow."
    },
    {
        "output": "Shows an example of using generics to create a function that swaps elements in a vector.",
        "input": "fn swap<T>(vec: &mut Vec<T>, i: usize, j: usize) { let temp = vec[i]; vec[i] = vec[j]; vec[j] = temp; }",
        "instruction": "Define a generic function 'swap' that takes a mutable vector and swaps elements at given indices, showcasing the flexibility of generics in Rust."
    },
    {
        "output": "Demonstrates the use of a custom macro to print a message with additional information about the code location.",
        "input": "macro_rules! custom_print { () => { println!(\"Message from file: {}, line: {}\", file!(), line!()); }; } fn main() { custom_print!(); }",
        "instruction": "Define a custom macro using macro_rules! that provides information about the file and line where it is called and invoke it in main()."
    },
    {
        "output": "Illustrates a simple error handling scenario using Result to divide two numbers, handling the division by zero error.",
        "input": "fn divide(a: i32, b: i32) -> Result<i32, &'static str> { if b == 0 { Err(\"Division by zero!\") } else { Ok(a / b) } } fn main() { match divide(10, 2) { Ok(result) => println!(\"Result: {}\", result), Err(err) => println!(\"Error: {}\", err), } }",
        "instruction": "Create a function that returns a Result to handle division by zero error, then use pattern matching in main() to print the result or error message."
    },
    {
        "output": "Defines a simple struct Circle with a method to calculate its area using traits and associated types.",
        "input": "struct Circle { radius: f64 } trait CalculateArea { type Output; fn area(&self) -> Self::Output; } impl CalculateArea for Circle { type Output = f64; fn area(&self) -> f64 { std::f64::consts::PI * self.radius * self.radius } } fn main() { let circle = Circle { radius: 3.0 }; println!(\"Area: {}\", circle.area()); }",
        "instruction": "Create a struct Circle and a trait CalculateArea with associated types to calculate the area, then implement the trait for Circle and calculate the area in main()."
    },
    {
        "output": "Demonstrates a simple implementation of a custom macro that prints 'Hello, World!' when called.",
        "input": "macro_rules! hello { () => { println!(\"Hello, World!\"); } } fn main() { hello!(); }",
        "instruction": "Create and utilize a custom macro to print a greeting message in Rust."
    },
    {
        "output": "Illustrates a basic implementation of error handling using Result to divide two numbers, returning the division result or an error message.",
        "input": "fn divide(a: f64, b: f64) -> Result<f64, &'static str> { if b == 0.0 { Err(\"Division by zero!\") } else { Ok(a / b) } } fn main() { match divide(8.0, 2.0) { Ok(result) => println!(\"Result: {}\", result), Err(error) => println!(\"Error: {}\", error), } }",
        "instruction": "Define a function that uses Result to handle errors when dividing two numbers in Rust."
    },
    {
        "output": "Demonstrates the usage of an asynchronously created random number using async/await syntax.",
        "input": "use rand::Rng; async fn generate_random() -> u32 { rand::thread_rng().gen_range(1..=100) } async fn main() { let result = generate_random().await; println!(\"Generated random number: {}\", result); }",
        "instruction": "Create an async function to generate a random number and then await its result for further processing."
    },
    {
        "output": "Illustrates a custom macro to print a message with line number and file name.",
        "input": "macro_rules! log_message {() => { println!(\"Hello! (Line: {}, File: {})\", line!(), file!()); }} fn main() { log_message!(); }",
        "instruction": "Define a custom macro using macro_rules! to print a message with the line number and file name at the call site."
    },
    {
        "output": "Demonstrates an enum with associated data and a match expression to process different event types.",
        "input": "enum Event { Click(u32), KeyPress(char), Move { x: i32, y: i32 } } fn process_event(event: Event) { match event { Event::Click(val) => println!(\"Clicked at: {}\", val), Event::KeyPress(key) => println!(\"Pressed key: {}\", key), Event::Move { x, y } => println!(\"Moved to ({}, {})\", x, y), } }",
        "instruction": "Define an enum with different variants and associated data, then use a match expression to process each variant accordingly."
    },
    {
        "output": "Shows a trait definition with a method that returns an iterator, allowing iteration over certain values.",
        "input": "trait Device { fn get_input_values(&self) -> Box<dyn Iterator<Item = u8>>; } struct Keyboard { keys: [u8; 5] } impl Device for Keyboard { fn get_input_values(&self) -> Box<dyn Iterator<Item = u8>> { Box::new(self.keys.iter().cloned()) } }",
        "instruction": "Define a trait that provides a method returning an iterator, implement it for a struct, and allow iteration over the struct's values using the trait."
    },
    {
        "output": "Defines an enum representing different colors and uses a match statement to print a message based on the color.",
        "input": "enum Color { Red, Green, Blue } fn main() { let color = Color::Green; match color { Color::Red => println!(\"The color is Red\"), Color::Green => println!(\"The color is Green\"), Color::Blue => println!(\"The color is Blue\") } }",
        "instruction": "Create an enum for colors and match on the enum variant to print a message."
    },
    {
        "output": "Illustrates a custom macro that prints 'Hello, World!' with some additional customization.",
        "input": "macro_rules! custom_hello { () => { println!(\"Hello, World!\"); } } fn main() { custom_hello!(); }",
        "instruction": "Define a custom macro using `macro_rules!` to print 'Hello, World!' with additional flexibility."
    },
    {
        "output": "Illustrates a simple model using enums and a match expression to handle different states of a process.",
        "input": "enum State { InProgress, Completed(u32) } fn main() { let progress = State::InProgress; match progress { State::InProgress => println!(\"Task is in progress.\"), State::Completed(num) => println!(\"Task completed with result: {}\", num), } }",
        "instruction": "Define an enum to represent different states, use a match statement to handle each state accordingly."
    },
    {
        "output": "Shows an example of defining a trait and implementing it for a custom struct to enable a specific behavior.",
        "input": "trait Drawable { fn draw(&self); } struct Rectangle { width: u32, height: u32 } impl Drawable for Rectangle { fn draw(&self) { println!(\"Drawing a rectangle of width {} and height {}.\", self.width, self.height); } } fn main() { let rect = Rectangle { width: 10, height: 5 }; rect.draw(); }",
        "instruction": "Define a trait for a specific behavior, implement the trait for a custom struct, and call the behavior method on an instance."
    },
    {
        "output": "Creates a simple enum representing different directions (North, South, East, West) and uses a match expression to print a message based on the direction.",
        "input": "enum Direction { North, South, East, West } fn main() { let current_direction = Direction::East; match current_direction { Direction::North => println!(\"Moving North\"), Direction::South => println!(\"Moving South\"), Direction::East => println!(\"Moving East\"), Direction::West => println!(\"Moving West\") } }",
        "instruction": "Define an enum for directions and use a match statement to handle different direction cases."
    },
    {
        "output": "Demonstrates error handling using the Result enum where a function returns a Result with either a valid value or an error, showcasing how to handle both cases.",
        "input": "fn divide(a: i32, b: i32) -> Result<i32, String> { if b == 0 { return Err(\"Division by zero\".to_string()); } Ok(a / b) } fn main() { let result = divide(10, 0); match result { Ok(value) => println!(\"Result: {}\", value), Err(msg) => println!(\"Error: {}\", msg), } }",
        "instruction": "Define a function that uses a Result enum to handle division by zero errors and demonstrates both successful and errored outcomes."
    },
    {
        "output": "Illustrates a simple example of ownership where a variable is moved into a function and returned as a result, showcasing Rust's ownership transfer at play.",
        "input": "fn take_and_give_back(a_string: String) -> String { a_string } fn main() { let original_string = String::from(\"Hello\"); let returned_string = take_and_give_back(original_string); println!(\"Returned: {}\", returned_string); }",
        "instruction": "Pass a String variable by ownership into a function and observe how ownership is transferred back after the function call."
    },
    {
        "output": "Demonstrates a custom error type and error handling using the Result enum and match expression.",
        "input": "struct CustomError; impl std::fmt::Display for CustomError { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { write!(f, \"Custom error occurred\") } } fn main() -> Result<(), CustomError> { Err(CustomError).map_err(|e| match e { CustomError => CustomError }) }",
        "instruction": "Define a custom error type, implement the Display trait for it, and showcase error handling using Result and match expressions."
    },
    {
        "output": "Illustrates ownership transfer with a function that takes ownership of a vector and returns its length.",
        "input": "fn get_vec_length(vec: Vec<i32>) -> usize { vec.len() } fn main() { let my_vec = vec![1, 2, 3]; let length = get_vec_length(my_vec); println!(\"Length of the vector: {}\", length); }",
        "instruction": "Create a function that takes ownership of a vector to return its length, demonstrating the concept of ownership transfer in Rust."
    },
    {
        "output": "Shows a simple usage of async/await with a function that simulates an asynchronous task returning a string.",
        "input": "async fn async_task() -> String { \"Async task completed\".to_string() } fn main() { let result = futures::executor::block_on(async_task()); println!(\"Result: {}\", result); }",
        "instruction": "Define an asynchronous function using async/await that returns a string, then run and print the result blocking the main thread."
    },
    {
        "output": "Defines a custom macro to print 'Hello, World!' with additional information.",
        "input": "macro_rules! hello_world { () => { println!(\"Hello, World! This is a custom macro\"); } } fn main() { hello_world!(); }",
        "instruction": "Create a custom macro using the macro_rules! keyword to print a message with additional information."
    },
    {
        "output": "Illustrates ownership transfer with a function that takes ownership of a string and returns its length.",
        "input": "fn string_length(s: String) -> usize { s.len() } fn main() { let my_string = String::from(\"Hello\"); let length = string_length(my_string); println!(\"Length: {}\", length); }",
        "instruction": "Pass ownership of a string to a function, get its length, and observe the ownership transfer mechanism in Rust."
    },
    {
        "output": "Demonstrates using Traits to define behavior and implementing it for a custom type Vec2D.",
        "input": "trait Vector { fn magnitude(&self) -> f64; } struct Vec2D { x: f64, y: f64 } impl Vector for Vec2D { fn magnitude(&self) -> f64 { (self.x.powi(2) + self.y.powi(2)).sqrt() } } fn main() { let vec = Vec2D { x: 3.0, y: 4.0 }; println!(\"Magnitude: {}\", vec.magnitude()); }",
        "instruction": "Define a trait Vector with a method magnitude() to calculate the magnitude of a vector and implement it for the custom type Vec2D."
    },
    {
        "output": "Uses a custom macro to assert whether the given expression is equal to 42.",
        "input": "macro_rules! assert_42 { ($x:expr) => { assert_eq!($x, 42); } } fn main() { let answer = 42; assert_42!(answer); }",
        "instruction": "Define a custom macro to simplify asserting a specific value and use it to check the value of a variable."
    },
    {
        "output": "Demonstrates ownership, borrowing, and a closure to multiply a number by a factor.",
        "input": "fn main() { let mut number = 5; { let multiply_by = |x: &mut i32| *x *= 2; multiply_by(&mut number); } println!(\"Result: {}\", number); }",
        "instruction": "Explore how closures can capture and work with references, modifying a mutable variable outside their scope."
    },
    {
        "output": "Shows the usage of Result and unwrap to retrieve values or panic in case of an error.",
        "input": "fn maybe_return_error(err: bool) -> Result<i32, &str> { if err { Err(\"An error occurred!\") } else { Ok(42) } } fn main() { let result = maybe_return_error(false).unwrap(); println!(\"Result: {}\", result); }",
        "instruction": "Create a function that returns a Result and demonstrate using unwrap to handle the value or potential error."
    },
    {
        "output": "Demonstrates a simple for loop iterating over a range and printing each number.",
        "input": "fn main() {\n    for i in 0..5 {\n        println!(\"{}\", i);\n    }\n}",
        "instruction": "Use a for loop to iterate over a range of numbers and print each value."
    },
    {
        "output": "Illustrates the use of an enum with a match expression to handle different states.",
        "input": "enum State {\n    Active, Inactive\n}\nfn main() {\n    let state = State::Active;\n    match state {\n        State::Active => println!(\"The state is active.\"),\n        State::Inactive => println!(\"The state is inactive.\"),\n    }\n}",
        "instruction": "Define an enum representing different states and use a match expression to handle each state accordingly."
    },
    {
        "output": "Shows a custom macro that squares a given input parameter.",
        "input": "macro_rules! square {\n    ($x:expr) => ($x * $x);\n}\nfn main() {\n    let num = 5;\n    println!(\"Square of {} is {}\", num, square!(num));\n}",
        "instruction": "Define a macro called 'square' to calculate the square of a given input value and use it within the code."
    },
    {
        "output": "Demonstrates a custom macro that prints 'Hello, World!' with a given number of exclamation marks.",
        "input": "macro_rules! custom_hello { () => { println!(\"Hello, World!\"); }; ( $num:expr ) => { for _ in 0..$num { println!(\"Hello, World!\"); } }; } fn main() { custom_hello!(); custom_hello!(3); }",
        "instruction": "Create and use a custom macro to print a message along with the number of exclamation marks specified."
    },
    {
        "output": "Illustrates a simple struct definition and implementation with associated methods in Rust.",
        "input": "struct Circle { radius: f64 } impl Circle { fn area(&self) -> f64 { std::f64::consts::PI * self.radius * self.radius } fn circumference(&self) -> f64 { 2.0 * std::f64::consts::PI * self.radius } } fn main() { let circle = Circle { radius: 3.0 }; println!(\"Area: {}\", circle.area()); }",
        "instruction": "Define a struct representing a circle, implement methods to calculate its area and circumference, then utilize these methods in the main function."
    },
    {
        "output": "Shows an async function that fetches a webpage using reqwest in Rust.",
        "input": "async fn fetch_webpage(url: &str) -> Result<String, reqwest::Error> { reqwest::get(url).await?.text().await } #[tokio::main] async fn main() { let url = \"https://example.com\"; match fetch_webpage(url).await { Ok(body) => println!(\"Fetched webpage: {}\", body), Err(err) => eprintln!(\"Error: {}\", err), }; }",
        "instruction": "Create an async function that uses reqwest to fetch a webpage and then handle the result using match to print the fetched content or an error message."
    },
    {
        "output": "Demonstrates a custom macro to print a message with file and line number information.",
        "input": "macro_rules! print_message {() => (println!(\"Message printed from file: {} line: {}\", file!(), line!()))} fn main() { print_message!(); }",
        "instruction": "Define a custom macro using `macro_rules!` to print useful debugging information like file and line number."
    },
    {
        "output": "Illustrates usage of a simple struct with a method to calculate the area of a circle.",
        "input": "struct Circle { radius: f64 } impl Circle { fn area(&self) -> f64 { std::f64::consts::PI * self.radius * self.radius } } fn main() { let circle = Circle { radius: 5.0 }; println!(\"Area: {}\", circle.area()); }",
        "instruction": "Define a struct to represent a circle and implement an area calculation method, demonstrating basic struct usage."
    },
    {
        "output": "Explores ownership in Rust by transferring ownership of a string to a function through a move.",
        "input": "fn take_ownership(data: String) { println!(\"Received data: {}\", data); } fn main() { let message = String::from(\"Hello, Ownership!\"); take_ownership(message); // Ownership transfer }",
        "instruction": "Showcases how ownership works in Rust by transferring ownership of a string to a function."
    },
    {
        "output": "Implements a custom macro to print 'Hello, World!' with a line break using println!",
        "input": "macro_rules! custom_hello { () => { println!(\"Hello,\\n World!\"); } } fn main() { custom_hello!(); }",
        "instruction": "Define a custom macro to print a message with an embedded newline character and demonstrate its usage in the main function."
    },
    {
        "output": "Defines a struct Point with x and y coordinates implementing the Display trait for custom formatting.",
        "input": "use std::fmt; struct Point { x: i32, y: i32 } impl fmt::Display for Point { fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result { write!(f, \"({}, {})\", self.x, self.y) } } fn main() { let point = Point { x: 3, y: 7 }; println!(\"The point is: {}\",& point); }",
        "instruction": "Create a struct with coordinates and implement the Display trait to define custom formatting of the struct when printed."
    },
    {
        "output": "Demonstrates error handling with Result, returning an error message when the input value is zero.",
        "input": "fn divide(a: f64, b: f64) -> Result<f64, String> { if b == 0.0 { return Err(String::from(\"Cannot divide by zero\")); } Ok(a / b) } fn main() { let result = divide(10.0, 0.0); match result { Ok(value) => println!(\"Result: {}\", value), Err(message) => println!(\"Error: {}\", message), } }",
        "instruction": "Create a function that divides two numbers and returns a Result where division by zero raises an error that is handled using a match statement."
    },
    {
        "output": "Demonstrates a custom macro to print 'Hello, World!' using a single macro invocation.",
        "input": "macro_rules! hello_world { () => { println!(\"Hello, World!\"); } } fn main() { hello_world!(); }",
        "instruction": "Create and use a custom macro named 'hello_world' to streamline printing of 'Hello, World!' in Rust."
    },
    {
        "output": "Illustrates a trait with a method to calculate the square of a number, implemented for u32 type.",
        "input": "trait Square { fn square(&self) -> u32; } impl Square for u32 { fn square(&self) -> u32 { self * self } } fn main() { let num: u32 = 5; println!(\"Square: {}\", num.square()); }",
        "instruction": "Define a trait 'Square' with a method to calculate the square, implement it for u32, and use it to find the square of a number."
    },
    {
        "output": "Shows a simple demonstration of ownership and borrowing by moving and borrowing a variable in Rust.",
        "input": "fn main() { let original = String::from(\"Hello\"); let borrowed = &original; println!(\"Original (moved): {}\", original); println!(\"Borrowed: {}\", borrowed); }",
        "instruction": "Exemplifies the concept of ownership and borrowing by moving and borrowing a String variable in Rust."
    },
    {
        "output": "Demonstrates error handling using Result and unwrap.",
        "input": "fn main() { let result: Result<i32, &str> = Ok(5); let value = result.unwrap(); println!(\"Value: {}\", value); }",
        "instruction": "Create a Result with an Ok variant, unwrap it to access the value, and print it."
    },
    {
        "output": "Illustrates the usage of macros for debugging purposes.",
        "input": "macro_rules! debug { () => { println!(\"Debugging...\"); } } fn main() { debug!(); }",
        "instruction": "Define a simple macro to print a debug message and use it in the main function."
    },
    {
        "output": "Shows the concept of ownership and borrowing with a simple function.",
        "input": "fn print_length(s: &str) { println!(\"Length: {}\", s.len()); } fn main() { let text = String::from(\"Hello, JSON!\"); print_length(&text); }",
        "instruction": "Define a function that borrows a string reference and prints its length, demonstrating borrowing in Rust."
    },
    {
        "output": "Demonstrates a for loop iterating over a range and summing the elements.",
        "input": "fn main() { let sum: i32 = (1..=5).fold(0, |acc, x| acc + x); println!(\"Sum: {}\", sum); }",
        "instruction": "Use a for loop to iterate over a range, fold to sum the elements, and print the total sum."
    },
    {
        "output": "Illustrates error handling using a Result type and match expression.",
        "input": "fn main() -> Result<(), String> { let result: Result<i32, String> = Err(\"An error occurred\".to_string()); match result { Ok(val) => println!(\"Value: {}\", val), Err(err) => return Err(err), } Ok(()) }",
        "instruction": "Define a function that returns Result, create an Err variant, handle it using match, and print or propagate the error."
    },
    {
        "output": "Defines a trait with a method and applies it to a struct using the impl keyword.",
        "input": "trait Print { fn print(&self); } struct Message { text: String } impl Print for Message { fn print(&self) { println!(\"Message: {}\", self.text); } } fn main() { let msg = Message { text: \"Hello, World\".to_string() }; msg.print(); }",
        "instruction": "Create a trait with a method, implement it for a struct, and call the trait method on an instance of the struct."
    },
    {
        "output": "An example demonstrating ownership transfer through a function call using a struct.",
        "input": "struct Dog { name: String } fn take_dog(d: Dog) { println!(\"Received dog: {}\", d.name); } fn main() { let my_dog = Dog { name: \"Buddy\".to_string() }; take_dog(my_dog); }",
        "instruction": "Create a struct representing a Dog, pass it to a function transferring ownership, and print the received dog's name."
    },
    {
        "output": "Illustrates the use of closures to define an anonymous function and invoke it with different arguments.",
        "input": "fn main() { let multiply = |a, b| a * b; let result1 = multiply(5, 3); let result2 = multiply(8, 2); println!(\"Result 1: {}\", result1); println!(\"Result 2: {}\", result2); }",
        "instruction": "Create a closure that multiplies two numbers, apply it with different values, and print the results."
    },
    {
        "output": "An example demonstrating error handling using the Result type to manage the success or failure of a function.",
        "input": "fn possibly_fails() -> Result<(), &str> { Err(\"Function failed\") } fn main() { match possibly_fails() { Ok(_) => println!(\"Function succeeded\"), Err(e) => println!(\"Error: {}\", e), } }",
        "instruction": "Define a function that may fail returning a Result, then handle both failure and success cases using a match expression."
    },
    {
        "output": "Demonstrates a custom macro for printing a message multiple times using a loop.",
        "input": "macro_rules! repeat_message { ($msg:expr, $times:expr) => { for _ in 0..$times { println!($msg); } } } fn main() { repeat_message!(\"Hello, world!\", 3); }",
        "instruction": "Create and use a custom macro to print a message multiple times by specifying the message and the number of repetitions."
    },
    {
        "output": "Illustrates a struct with associated methods using a trait for representing shapes and implementing area calculation.",
        "input": "trait Shape { fn area(&self) -> f64; } struct Circle { radius: f64 } impl Shape for Circle { fn area(&self) -> f64 { std::f64::consts::PI * self.radius * self.radius } } fn main() { let circle = Circle { radius: 5.0 }; println!(\"Circle area: {:.2}\", circle.area()); }",
        "instruction": "Define a trait for shapes with an area method, implement the trait for a struct representing a circle, and compute the area of a circle instance."
    },
    {
        "output": "Uses Result to handle file read errors and display file contents if successful.",
        "input": "use std::fs::File; use std::io::Read; fn main() { let mut file = File::open(\"example.txt\").expect(\"File not found\"); let mut contents = String::new(); file.read_to_string(&mut contents).unwrap(); println!(\"File contents: {}\", contents); }",
        "instruction": "Attempt to open and read a file, handling the possibility of errors with Result and displaying the file contents if the operation succeeds."
    },
    {
        "output": "Demonstrates a custom error type using enums and the Result type for error handling.",
        "input": "enum CustomError { NotFound, Unauthorized, InternalServerError } fn main() { let result: Result<(), CustomError> = Err(CustomError::InternalServerError); }",
        "instruction": "Define a custom error type as an enum and use it with the Result type for error handling in Rust."
    },
    {
        "output": "Shows a simple generic function that swaps two elements in a vector.",
        "input": "fn swap<T: Clone>(v: &mut Vec<T>, i: usize, j: usize) { let temp = v[i].clone(); v[i] = v[j].clone(); v[j] = temp; }",
        "instruction": "Create a generic function that swaps elements in a vector, showcasing how generics can be used for flexibility and type safety."
    },
    {
        "output": "Illustrates a closure that increments a given number by a specified amount.",
        "input": "fn main() { let adder = |x, y| x + y; let result = adder(5, 3); println!(\"Result: {}\", result); }",
        "instruction": "Define a closure that adds two numbers and demonstrates how closures provide a concise way to define functionality."
    },
    {
        "output": "Uses a custom macro to log a message with specified level and text.",
        "input": "macro_rules! custom_log { ($level:expr, $message:expr) => { println!(\"[{}] {}\", $level, $message); } } fn main() { custom_log!(\"DEBUG\", \"This is a debug message\"); }",
        "instruction": "Define a custom macro that logs messages with a specified level and message text, providing flexibility in logging output."
    },
    {
        "output": "Demonstrates a simple error handling scenario with Result type and unwrap.",
        "input": "fn divide(a: f32, b: f32) -> Result<f32, &'static str> { if b == 0.0 { Err(\"Division by zero\") } else { Ok(a / b) } } fn main() { let result = divide(8.0, 4.0).unwrap(); println!(\"Result: {}\", result); }",
        "instruction": "Define a function to perform division with error handling using Result type and unwrap to extract the result or handle an error message."
    },
    {
        "output": "Illustrates a simple implementation of a generic function to find the max of two values.",
        "input": "fn find_max<T: PartialOrd>(x: T, y: T) -> T { if x > y { x } else { y } } fn main() { let max_value = find_max(15, 30); println!(\"Max value: {}\", max_value); }",
        "instruction": "Create a generic function that finds the maximum value among two input values, showcasing the use of generics in Rust."
    },
    {
        "output": "Defines a custom error type and demonstrates how to propagate an error using the Result type and the '?' operator.",
        "input": "\nuse std::fs::File;\nuse std::io::prelude::*;\nuse std::io;\n\ncustom_error! { \n  MyError\n    Io { source: io::Error }\n}\n\nfn read_file(path: &str) -> Result<String, MyError> {\n    let mut file = File::open(path)?;\n    let mut content = String::new();\n    file.read_to_string(&mut content)?;\n    Ok(content)\n}\n",
        "instruction": "Define a custom error type, read a file contents into a string, and propagate errors using the '?' operator."
    },
    {
        "output": "Defines a simple enum representing geometric shapes and uses pattern matching to calculate their areas.",
        "input": "\nenum Shape {\n    Rectangle { width: u32, height: u32 },\n    Circle { radius: f64 }\n}\n\nfn calculate_area(shape: Shape) -> f64 {\n    match shape {\n        Shape::Rectangle { width, height } => f64::from(width * height),\n        Shape::Circle { radius } => std::f64::consts::PI * radius * radius,\n    }\n}\n",
        "instruction": "Define an enum representing shapes, calculate the area based on the shape type, using pattern matching."
    },
    {
        "output": "Implements a trait for a custom struct and a function that highlights the trait's methods.",
        "input": "\ntrait Printable {\n    fn print(&self);\n}\n\nstruct Message { content: String }\nimpl Printable for Message {\n    fn print(&self) {\n        println!(\"Message content: {}\", self.content);\n    }\n}\n\nfn display_message(message: &impl Printable) {\n    message.print();\n}\n",
        "instruction": "Create a trait with a print method, implement the trait for a struct, and use a function that takes a trait object to print the message content."
    },
    {
        "output": "Defines a custom enum and uses a match statement to display different messages based on enum variants.",
        "input": "enum State { Active, Inactive } fn main() { let current_state = State::Active; match current_state { State::Active => println!(\"System is active\"), State::Inactive => println!(\"System is inactive\"), }; }",
        "instruction": "Create an enum representing two states, then use a match expression to handle different states with specific actions."
    },
    {
        "output": "Demonstrates the use of generics in a simple function to find the maximum of two comparable values.",
        "input": "fn find_max<T: PartialOrd>(a: T, b: T) -> T { if a > b { a } else { b } } fn main() { let max_num = find_max(5, 10); println!(\"Maximum: {}\", max_num); }",
        "instruction": "Define a generic function that finds the larger value among two inputs of the same type, then call the function with different types and print the result."
    },
    {
        "output": "Demonstrates error handling with the Result type and unwrapping the result with expect.",
        "input": "fn divide(a: f64, b: f64) -> Result<f64, String> { if b == 0.0 { return Err(String::from(\"Cannot divide by zero\")); } Ok(a / b) } fn main() { let result = divide(10.0, 2.0).expect(\"Division failed\"); }",
        "instruction": "Learn to handle errors gracefully using Result and expect."
    },
    {
        "output": "Illustrates defining a struct with associated methods and implementing a trait for the struct.",
        "input": "struct Point { x: i32, y: i32 } trait Drawable { fn draw(&self); } impl Drawable for Point { fn draw(&self) { println!(\"Drawing point at ({}, {})\", self.x, self.y); } } fn main() { let point = Point { x: 5, y: 10 }; point.draw(); }",
        "instruction": "Create a struct, define methods, implement a trait, and call the trait method to print the point coordinates."
    },
    {
        "output": "Demonstrates a custom error type with its implementation and usage in a function with Result type.",
        "input": "struct CustomError; impl std::fmt::Display for CustomError { fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result { write!(f, 'Custom Error!') } } fn parse_input(input: &str) -> Result<i32, CustomError> { input.parse().map_err(|_| CustomError) }",
        "instruction": "Create a custom error type, implement Error trait for it, and use it in a function returning a Result."
    },
    {
        "output": "Illustrates the usage of a custom macro to print a given expression with additional information.",
        "input": "macro_rules! print_with_info { ($val:expr) => { println!('Info: {} = {}', stringify!($val), $val); }; } fn main() { let var = 42; print_with_info!(var); }",
        "instruction": "Define a custom macro using macro_rules! and utilize it to print an expression along with its name."
    }
]